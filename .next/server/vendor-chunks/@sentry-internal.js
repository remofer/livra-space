"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sentry-internal";
exports.ids = ["vendor-chunks/@sentry-internal"];
exports.modules = {

/***/ "(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/debug-build.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@sentry-internal/browser-utils/build/esm/debug-build.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEBUG_BUILD: () => (/* binding */ DEBUG_BUILD)\n/* harmony export */ });\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);\n\n\n//# sourceMappingURL=debug-build.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS9kZWJ1Zy1idWlsZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5LWludGVybmFsL2Jyb3dzZXItdXRpbHMvYnVpbGQvZXNtL2RlYnVnLWJ1aWxkLmpzPzc1ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIHNlcnZlcyBhcyBhIGJ1aWxkIHRpbWUgZmxhZyB0aGF0IHdpbGwgYmUgdHJ1ZSBieSBkZWZhdWx0LCBidXQgZmFsc2UgaW4gbm9uLWRlYnVnIGJ1aWxkcyBvciBpZiB1c2VycyByZXBsYWNlIGBfX1NFTlRSWV9ERUJVR19fYCBpbiB0aGVpciBnZW5lcmF0ZWQgY29kZS5cbiAqXG4gKiBBVFRFTlRJT046IFRoaXMgY29uc3RhbnQgbXVzdCBuZXZlciBjcm9zcyBwYWNrYWdlIGJvdW5kYXJpZXMgKGkuZS4gYmUgZXhwb3J0ZWQpIHRvIGd1YXJhbnRlZSB0aGF0IGl0IGNhbiBiZSB1c2VkIGZvciB0cmVlIHNoYWtpbmcuXG4gKi9cbmNvbnN0IERFQlVHX0JVSUxEID0gKHR5cGVvZiBfX1NFTlRSWV9ERUJVR19fID09PSAndW5kZWZpbmVkJyB8fCBfX1NFTlRSWV9ERUJVR19fKTtcblxuZXhwb3J0IHsgREVCVUdfQlVJTEQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYnVnLWJ1aWxkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/debug-build.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/getNativeImplementation.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@sentry-internal/browser-utils/build/esm/getNativeImplementation.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearCachedImplementation: () => (/* binding */ clearCachedImplementation),\n/* harmony export */   fetch: () => (/* binding */ fetch),\n/* harmony export */   getNativeImplementation: () => (/* binding */ getNativeImplementation),\n/* harmony export */   setTimeout: () => (/* binding */ setTimeout)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/supports.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/logger.js\");\n/* harmony import */ var _debug_build_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debug-build.js */ \"(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/debug-build.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/types.js\");\n\n\n\n\n/**\n * We generally want to use window.fetch / window.setTimeout.\n * However, in some cases this may be wrapped (e.g. by Zone.js for Angular),\n * so we try to get an unpatched version of this from a sandboxed iframe.\n */\n\nconst cachedImplementations = {};\n\n/**\n * Get the native implementation of a browser function.\n *\n * This can be used to ensure we get an unwrapped version of a function, in cases where a wrapped function can lead to problems.\n *\n * The following methods can be retrieved:\n * - `setTimeout`: This can be wrapped by e.g. Angular, causing change detection to be triggered.\n * - `fetch`: This can be wrapped by e.g. ad-blockers, causing an infinite loop when a request is blocked.\n */\nfunction getNativeImplementation(\n  name,\n) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n\n  let impl = _types_js__WEBPACK_IMPORTED_MODULE_0__.WINDOW[name] ;\n\n  // Fast path to avoid DOM I/O\n  if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_1__.isNativeFunction)(impl)) {\n    return (cachedImplementations[name] = impl.bind(_types_js__WEBPACK_IMPORTED_MODULE_0__.WINDOW) );\n  }\n\n  const document = _types_js__WEBPACK_IMPORTED_MODULE_0__.WINDOW.document;\n  // eslint-disable-next-line deprecation/deprecation\n  if (document && typeof document.createElement === 'function') {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = contentWindow[name] ;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      // Could not create sandbox iframe, just use window.xxx\n      _debug_build_js__WEBPACK_IMPORTED_MODULE_2__.DEBUG_BUILD && _sentry_core__WEBPACK_IMPORTED_MODULE_3__.logger.warn(`Could not create sandbox iframe for ${name} check, bailing to window.${name}: `, e);\n    }\n  }\n\n  // Sanity check: This _should_ not happen, but if it does, we just skip caching...\n  // This can happen e.g. in tests where fetch may not be available in the env, or similar.\n  if (!impl) {\n    return impl;\n  }\n\n  return (cachedImplementations[name] = impl.bind(_types_js__WEBPACK_IMPORTED_MODULE_0__.WINDOW) );\n}\n\n/** Clear a cached implementation. */\nfunction clearCachedImplementation(name) {\n  cachedImplementations[name] = undefined;\n}\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nfunction fetch(...rest) {\n  return getNativeImplementation('fetch')(...rest);\n}\n\n/**\n * Get an unwrapped `setTimeout` method.\n * This ensures that even if e.g. Angular wraps `setTimeout`, we get the native implementation,\n * avoiding triggering change detection.\n */\nfunction setTimeout(...rest) {\n  return getNativeImplementation('setTimeout')(...rest);\n}\n\n\n//# sourceMappingURL=getNativeImplementation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS9nZXROYXRpdmVJbXBsZW1lbnRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF3RDtBQUNUO0FBQ1g7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSw2Q0FBTTs7QUFFbkI7QUFDQSxNQUFNLDhEQUFnQjtBQUN0QixvREFBb0QsNkNBQU07QUFDMUQ7O0FBRUEsbUJBQW1CLDZDQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNLHdEQUFXLElBQUksZ0RBQU0sNkNBQTZDLE1BQU0sMkJBQTJCLEtBQUs7QUFDOUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCw2Q0FBTTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlGO0FBQ2pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzZW50cnktaW50ZXJuYWwvYnJvd3Nlci11dGlscy9idWlsZC9lc20vZ2V0TmF0aXZlSW1wbGVtZW50YXRpb24uanM/M2Y4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc05hdGl2ZUZ1bmN0aW9uLCBsb2dnZXIgfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuaW1wb3J0IHsgREVCVUdfQlVJTEQgfSBmcm9tICcuL2RlYnVnLWJ1aWxkLmpzJztcbmltcG9ydCB7IFdJTkRPVyB9IGZyb20gJy4vdHlwZXMuanMnO1xuXG4vKipcbiAqIFdlIGdlbmVyYWxseSB3YW50IHRvIHVzZSB3aW5kb3cuZmV0Y2ggLyB3aW5kb3cuc2V0VGltZW91dC5cbiAqIEhvd2V2ZXIsIGluIHNvbWUgY2FzZXMgdGhpcyBtYXkgYmUgd3JhcHBlZCAoZS5nLiBieSBab25lLmpzIGZvciBBbmd1bGFyKSxcbiAqIHNvIHdlIHRyeSB0byBnZXQgYW4gdW5wYXRjaGVkIHZlcnNpb24gb2YgdGhpcyBmcm9tIGEgc2FuZGJveGVkIGlmcmFtZS5cbiAqL1xuXG5jb25zdCBjYWNoZWRJbXBsZW1lbnRhdGlvbnMgPSB7fTtcblxuLyoqXG4gKiBHZXQgdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGJyb3dzZXIgZnVuY3Rpb24uXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBlbnN1cmUgd2UgZ2V0IGFuIHVud3JhcHBlZCB2ZXJzaW9uIG9mIGEgZnVuY3Rpb24sIGluIGNhc2VzIHdoZXJlIGEgd3JhcHBlZCBmdW5jdGlvbiBjYW4gbGVhZCB0byBwcm9ibGVtcy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIG1ldGhvZHMgY2FuIGJlIHJldHJpZXZlZDpcbiAqIC0gYHNldFRpbWVvdXRgOiBUaGlzIGNhbiBiZSB3cmFwcGVkIGJ5IGUuZy4gQW5ndWxhciwgY2F1c2luZyBjaGFuZ2UgZGV0ZWN0aW9uIHRvIGJlIHRyaWdnZXJlZC5cbiAqIC0gYGZldGNoYDogVGhpcyBjYW4gYmUgd3JhcHBlZCBieSBlLmcuIGFkLWJsb2NrZXJzLCBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3Agd2hlbiBhIHJlcXVlc3QgaXMgYmxvY2tlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlSW1wbGVtZW50YXRpb24oXG4gIG5hbWUsXG4pIHtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGVkSW1wbGVtZW50YXRpb25zW25hbWVdO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuXG4gIGxldCBpbXBsID0gV0lORE9XW25hbWVdIDtcblxuICAvLyBGYXN0IHBhdGggdG8gYXZvaWQgRE9NIEkvT1xuICBpZiAoaXNOYXRpdmVGdW5jdGlvbihpbXBsKSkge1xuICAgIHJldHVybiAoY2FjaGVkSW1wbGVtZW50YXRpb25zW25hbWVdID0gaW1wbC5iaW5kKFdJTkRPVykgKTtcbiAgfVxuXG4gIGNvbnN0IGRvY3VtZW50ID0gV0lORE9XLmRvY3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgaWYgKGRvY3VtZW50ICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNhbmRib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIHNhbmRib3guaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2FuZGJveCk7XG4gICAgICBjb25zdCBjb250ZW50V2luZG93ID0gc2FuZGJveC5jb250ZW50V2luZG93O1xuICAgICAgaWYgKGNvbnRlbnRXaW5kb3cgJiYgY29udGVudFdpbmRvd1tuYW1lXSkge1xuICAgICAgICBpbXBsID0gY29udGVudFdpbmRvd1tuYW1lXSA7XG4gICAgICB9XG4gICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHNhbmRib3gpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIENvdWxkIG5vdCBjcmVhdGUgc2FuZGJveCBpZnJhbWUsIGp1c3QgdXNlIHdpbmRvdy54eHhcbiAgICAgIERFQlVHX0JVSUxEICYmIGxvZ2dlci53YXJuKGBDb3VsZCBub3QgY3JlYXRlIHNhbmRib3ggaWZyYW1lIGZvciAke25hbWV9IGNoZWNrLCBiYWlsaW5nIHRvIHdpbmRvdy4ke25hbWV9OiBgLCBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBTYW5pdHkgY2hlY2s6IFRoaXMgX3Nob3VsZF8gbm90IGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMsIHdlIGp1c3Qgc2tpcCBjYWNoaW5nLi4uXG4gIC8vIFRoaXMgY2FuIGhhcHBlbiBlLmcuIGluIHRlc3RzIHdoZXJlIGZldGNoIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIHRoZSBlbnYsIG9yIHNpbWlsYXIuXG4gIGlmICghaW1wbCkge1xuICAgIHJldHVybiBpbXBsO1xuICB9XG5cbiAgcmV0dXJuIChjYWNoZWRJbXBsZW1lbnRhdGlvbnNbbmFtZV0gPSBpbXBsLmJpbmQoV0lORE9XKSApO1xufVxuXG4vKiogQ2xlYXIgYSBjYWNoZWQgaW1wbGVtZW50YXRpb24uICovXG5mdW5jdGlvbiBjbGVhckNhY2hlZEltcGxlbWVudGF0aW9uKG5hbWUpIHtcbiAgY2FjaGVkSW1wbGVtZW50YXRpb25zW25hbWVdID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbCB1c2VjYXNlIGZvciBpbmNvcnJlY3RseSB3cmFwcGVkIEZldGNoIEFQSXMgaW4gY29uanVuY3Rpb24gd2l0aCBhZC1ibG9ja2Vycy5cbiAqIFdoZW5ldmVyIHNvbWVvbmUgd3JhcHMgdGhlIEZldGNoIEFQSSBhbmQgcmV0dXJucyB0aGUgd3JvbmcgcHJvbWlzZSBjaGFpbixcbiAqIHRoaXMgY2hhaW4gYmVjb21lcyBvcnBoYW5lZCBhbmQgdGhlcmUgaXMgbm8gcG9zc2libGUgd2F5IHRvIGNhcHR1cmUgaXQncyByZWplY3Rpb25zXG4gKiBvdGhlciB0aGFuIGFsbG93aW5nIGl0IGJ1YmJsZSB1cCB0byB0aGlzIHZlcnkgaGFuZGxlci4gZWcuXG4gKlxuICogY29uc3QgZiA9IHdpbmRvdy5mZXRjaDtcbiAqIHdpbmRvdy5mZXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAqICAgY29uc3QgcCA9IGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAqXG4gKiAgIHAudGhlbihmdW5jdGlvbigpIHtcbiAqICAgICBjb25zb2xlLmxvZygnaGkuJyk7XG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIHA7XG4gKiB9XG4gKlxuICogYHAudGhlbihmdW5jdGlvbiAoKSB7IC4uLiB9KWAgaXMgcHJvZHVjaW5nIGEgY29tcGxldGVseSBzZXBhcmF0ZSBwcm9taXNlIGNoYWluLFxuICogaG93ZXZlciwgd2hhdCdzIHJldHVybmVkIGlzIGBwYCAtIHRoZSByZXN1bHQgb2Ygb3JpZ2luYWwgYGZldGNoYCBjYWxsLlxuICpcbiAqIFRoaXMgbWVhbiwgdGhhdCB3aGVuZXZlciB3ZSB1c2UgdGhlIEZldGNoIEFQSSB0byBzZW5kIG91ciBvd24gcmVxdWVzdHMsIF9hbmRfXG4gKiBzb21lIGFkLWJsb2NrZXIgYmxvY2tzIGl0LCB0aGlzIG9ycGhhbmVkIGNoYWluIHdpbGwgX2Fsd2F5c18gcmVqZWN0LFxuICogZWZmZWN0aXZlbHkgY2F1c2luZyBhbm90aGVyIGV2ZW50IHRvIGJlIGNhcHR1cmVkLlxuICogVGhpcyBtYWtlcyBhIHdob2xlIHByb2Nlc3MgYmVjb21lIGFuIGluZmluaXRlIGxvb3AsIHdoaWNoIHdlIG5lZWQgdG8gc29tZWhvd1xuICogZGVhbCB3aXRoLCBhbmQgYnJlYWsgaXQgaW4gb25lIHdheSBvciBhbm90aGVyLlxuICpcbiAqIFRvIGRlYWwgd2l0aCB0aGlzIGlzc3VlLCB3ZSBhcmUgbWFraW5nIHN1cmUgdGhhdCB3ZSBfYWx3YXlzXyB1c2UgdGhlIHJlYWxcbiAqIGJyb3dzZXIgRmV0Y2ggQVBJLCBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gd2hhdCBgd2luZG93LmZldGNoYCBleHBvc2VzLlxuICogVGhlIG9ubHkgZG93bnNpZGUgdG8gdGhpcyB3b3VsZCBiZSBtaXNzaW5nIG91ciBvd24gcmVxdWVzdHMgYXMgYnJlYWRjcnVtYnMsXG4gKiBidXQgYmVjYXVzZSB3ZSBhcmUgYWxyZWFkeSBub3QgZG9pbmcgdGhpcywgaXQgc2hvdWxkIGJlIGp1c3QgZmluZS5cbiAqXG4gKiBQb3NzaWJsZSBmYWlsZWQgZmV0Y2ggZXJyb3IgbWVzc2FnZXMgcGVyLWJyb3dzZXI6XG4gKlxuICogQ2hyb21lOiAgRmFpbGVkIHRvIGZldGNoXG4gKiBFZGdlOiAgICBGYWlsZWQgdG8gRmV0Y2hcbiAqIEZpcmVmb3g6IE5ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2VcbiAqIFNhZmFyaTogIHJlc291cmNlIGJsb2NrZWQgYnkgY29udGVudCBibG9ja2VyXG4gKi9cbmZ1bmN0aW9uIGZldGNoKC4uLnJlc3QpIHtcbiAgcmV0dXJuIGdldE5hdGl2ZUltcGxlbWVudGF0aW9uKCdmZXRjaCcpKC4uLnJlc3QpO1xufVxuXG4vKipcbiAqIEdldCBhbiB1bndyYXBwZWQgYHNldFRpbWVvdXRgIG1ldGhvZC5cbiAqIFRoaXMgZW5zdXJlcyB0aGF0IGV2ZW4gaWYgZS5nLiBBbmd1bGFyIHdyYXBzIGBzZXRUaW1lb3V0YCwgd2UgZ2V0IHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24sXG4gKiBhdm9pZGluZyB0cmlnZ2VyaW5nIGNoYW5nZSBkZXRlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNldFRpbWVvdXQoLi4ucmVzdCkge1xuICByZXR1cm4gZ2V0TmF0aXZlSW1wbGVtZW50YXRpb24oJ3NldFRpbWVvdXQnKSguLi5yZXN0KTtcbn1cblxuZXhwb3J0IHsgY2xlYXJDYWNoZWRJbXBsZW1lbnRhdGlvbiwgZmV0Y2gsIGdldE5hdGl2ZUltcGxlbWVudGF0aW9uLCBzZXRUaW1lb3V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXROYXRpdmVJbXBsZW1lbnRhdGlvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/getNativeImplementation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/instrument/dom.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@sentry-internal/browser-utils/build/esm/instrument/dom.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClickKeypressInstrumentationHandler: () => (/* binding */ addClickKeypressInstrumentationHandler),\n/* harmony export */   instrumentDOM: () => (/* binding */ instrumentDOM)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/instrument/handlers.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/object.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/misc.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.js */ \"(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/types.js\");\n\n\n\nconst DEBOUNCE_DURATION = 1000;\n\nlet debounceTimerID;\nlet lastCapturedEventType;\nlet lastCapturedEventTargetId;\n\n/**\n * Add an instrumentation handler for when a click or a keypress happens.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addClickKeypressInstrumentationHandler(handler) {\n  const type = 'dom';\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addHandler)(type, handler);\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.maybeInstrument)(type, instrumentDOM);\n}\n\n/** Exported for tests only. */\nfunction instrumentDOM() {\n  if (!_types_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW.document) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = _sentry_core__WEBPACK_IMPORTED_MODULE_0__.triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  _types_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  _types_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target) => {\n    const globalObject = _types_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW ;\n    const targetObj = globalObject[target];\n    const proto = targetObj && targetObj.prototype;\n\n    // eslint-disable-next-line no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_2__.fill)(proto, 'addEventListener', function (originalAddEventListener) {\n      return function ( type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const handlers = (this.__sentry_instrumentation_handlers__ =\n              this.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_2__.fill)(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener) {\n        return function ( type, listener, options) {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const handlers = this.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount--;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete this.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListeners` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\n/**\n * Check whether the event is similar to the last captured one. For example, two click events on the same button.\n */\nfunction isSimilarToLastCapturedEvent(event) {\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (event.type !== lastCapturedEventType) {\n    return false;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (!event.target || (event.target )._sentryId !== lastCapturedEventTargetId) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return true;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(eventType, target) {\n  // We are only interested in filtering `keypress` events for now.\n  if (eventType !== 'keypress') {\n    return false;\n  }\n\n  if (!target || !target.tagName) {\n    return true;\n  }\n\n  // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n  // e.g.tabbing through elements, hotkeys, etc.\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n */\nfunction makeDOMEventHandler(\n  handler,\n  globalListener = false,\n) {\n  return (event) => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || event['_sentryCaptured']) {\n      return;\n    }\n\n    const target = getEventTarget(event);\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event.type, target)) {\n      return;\n    }\n\n    // Mark event as \"seen\"\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_2__.addNonEnumerableProperty)(event, '_sentryCaptured', true);\n\n    if (target && !target._sentryId) {\n      // Add UUID to event target so we can identify if\n      (0,_sentry_core__WEBPACK_IMPORTED_MODULE_2__.addNonEnumerableProperty)(target, '_sentryId', (0,_sentry_core__WEBPACK_IMPORTED_MODULE_3__.uuid4)());\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no last captured event, it means that we can safely capture the new event and store it for future comparisons.\n    // If there is a last captured event, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    if (!isSimilarToLastCapturedEvent(event)) {\n      const handlerData = { event, name, global: globalListener };\n      handler(handlerData);\n      lastCapturedEventType = event.type;\n      lastCapturedEventTargetId = target ? target._sentryId : undefined;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = _types_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW.setTimeout(() => {\n      lastCapturedEventTargetId = undefined;\n      lastCapturedEventType = undefined;\n    }, DEBOUNCE_DURATION);\n  };\n}\n\nfunction getEventTarget(event) {\n  try {\n    return event.target ;\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n    return null;\n  }\n}\n\n\n//# sourceMappingURL=dom.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS9pbnN0cnVtZW50L2RvbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBbUg7QUFDOUU7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx3REFBVTtBQUNaLEVBQUUsNkRBQWU7QUFDakI7O0FBRUE7QUFDQTtBQUNBLE9BQU8sNkNBQU07QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5REFBZTtBQUMzQztBQUNBLEVBQUUsNkNBQU07QUFDUixFQUFFLDZDQUFNOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBTTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksa0RBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCx5RUFBeUUsYUFBYTs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxJQUFJLGtEQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLHNFQUF3Qjs7QUFFNUI7QUFDQTtBQUNBLE1BQU0sc0VBQXdCLHNCQUFzQixtREFBSztBQUN6RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDZDQUFNO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUU7QUFDakUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS9pbnN0cnVtZW50L2RvbS5qcz9iY2FmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkZEhhbmRsZXIsIG1heWJlSW5zdHJ1bWVudCwgdHJpZ2dlckhhbmRsZXJzLCBmaWxsLCBhZGROb25FbnVtZXJhYmxlUHJvcGVydHksIHV1aWQ0IH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IFdJTkRPVyB9IGZyb20gJy4uL3R5cGVzLmpzJztcblxuY29uc3QgREVCT1VOQ0VfRFVSQVRJT04gPSAxMDAwO1xuXG5sZXQgZGVib3VuY2VUaW1lcklEO1xubGV0IGxhc3RDYXB0dXJlZEV2ZW50VHlwZTtcbmxldCBsYXN0Q2FwdHVyZWRFdmVudFRhcmdldElkO1xuXG4vKipcbiAqIEFkZCBhbiBpbnN0cnVtZW50YXRpb24gaGFuZGxlciBmb3Igd2hlbiBhIGNsaWNrIG9yIGEga2V5cHJlc3MgaGFwcGVucy5cbiAqXG4gKiBVc2UgYXQgeW91ciBvd24gcmlzaywgdGhpcyBtaWdodCBicmVhayB3aXRob3V0IGNoYW5nZWxvZyBub3RpY2UsIG9ubHkgdXNlZCBpbnRlcm5hbGx5LlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhZGRDbGlja0tleXByZXNzSW5zdHJ1bWVudGF0aW9uSGFuZGxlcihoYW5kbGVyKSB7XG4gIGNvbnN0IHR5cGUgPSAnZG9tJztcbiAgYWRkSGFuZGxlcih0eXBlLCBoYW5kbGVyKTtcbiAgbWF5YmVJbnN0cnVtZW50KHR5cGUsIGluc3RydW1lbnRET00pO1xufVxuXG4vKiogRXhwb3J0ZWQgZm9yIHRlc3RzIG9ubHkuICovXG5mdW5jdGlvbiBpbnN0cnVtZW50RE9NKCkge1xuICBpZiAoIVdJTkRPVy5kb2N1bWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE1ha2UgaXQgc28gdGhhdCBhbnkgY2xpY2sgb3Iga2V5cHJlc3MgdGhhdCBpcyB1bmhhbmRsZWQgLyBidWJibGVkIHVwIGFsbCB0aGUgd2F5IHRvIHRoZSBkb2N1bWVudCB0cmlnZ2VycyBvdXIgZG9tXG4gIC8vIGhhbmRsZXJzLiAoTm9ybWFsbHkgd2UgaGF2ZSBvbmx5IG9uZSwgd2hpY2ggY2FwdHVyZXMgYSBicmVhZGNydW1iIGZvciBlYWNoIGNsaWNrIG9yIGtleXByZXNzLikgRG8gdGhpcyBiZWZvcmVcbiAgLy8gd2UgaW5zdHJ1bWVudCBgYWRkRXZlbnRMaXN0ZW5lcmAgc28gdGhhdCB3ZSBkb24ndCBlbmQgdXAgYXR0YWNoaW5nIHRoaXMgaGFuZGxlciB0d2ljZS5cbiAgY29uc3QgdHJpZ2dlckRPTUhhbmRsZXIgPSB0cmlnZ2VySGFuZGxlcnMuYmluZChudWxsLCAnZG9tJyk7XG4gIGNvbnN0IGdsb2JhbERPTUV2ZW50SGFuZGxlciA9IG1ha2VET01FdmVudEhhbmRsZXIodHJpZ2dlckRPTUhhbmRsZXIsIHRydWUpO1xuICBXSU5ET1cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBnbG9iYWxET01FdmVudEhhbmRsZXIsIGZhbHNlKTtcbiAgV0lORE9XLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZ2xvYmFsRE9NRXZlbnRIYW5kbGVyLCBmYWxzZSk7XG5cbiAgLy8gQWZ0ZXIgaG9va2luZyBpbnRvIGNsaWNrIGFuZCBrZXlwcmVzcyBldmVudHMgYnViYmxlZCB1cCB0byBgZG9jdW1lbnRgLCB3ZSBhbHNvIGhvb2sgaW50byB1c2VyLWhhbmRsZWRcbiAgLy8gY2xpY2tzICYga2V5cHJlc3NlcywgYnkgYWRkaW5nIGFuIGV2ZW50IGxpc3RlbmVyIG9mIG91ciBvd24gdG8gYW55IGVsZW1lbnQgdG8gd2hpY2ggdGhleSBhZGQgYSBsaXN0ZW5lci4gVGhhdFxuICAvLyB3YXksIHdoZW5ldmVyIG9uZSBvZiB0aGVpciBoYW5kbGVycyBpcyB0cmlnZ2VyZWQsIG91cnMgd2lsbCBiZSwgdG9vLiAoVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGVpciBoYW5kbGVyXG4gIC8vIGNvdWxkIHBvdGVudGlhbGx5IHByZXZlbnQgdGhlIGV2ZW50IGZyb20gYnViYmxpbmcgdXAgdG8gb3VyIGdsb2JhbCBsaXN0ZW5lcnMuIFRoaXMgd2F5LCBvdXIgaGFuZGxlciBhcmUgc3RpbGxcbiAgLy8gZ3VhcmFudGVlZCB0byBmaXJlIGF0IGxlYXN0IG9uY2UuKVxuICBbJ0V2ZW50VGFyZ2V0JywgJ05vZGUnXS5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICBjb25zdCBnbG9iYWxPYmplY3QgPSBXSU5ET1cgO1xuICAgIGNvbnN0IHRhcmdldE9iaiA9IGdsb2JhbE9iamVjdFt0YXJnZXRdO1xuICAgIGNvbnN0IHByb3RvID0gdGFyZ2V0T2JqICYmIHRhcmdldE9iai5wcm90b3R5cGU7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgaWYgKCFwcm90byB8fCAhcHJvdG8uaGFzT3duUHJvcGVydHkgfHwgIXByb3RvLmhhc093blByb3BlcnR5KCdhZGRFdmVudExpc3RlbmVyJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmaWxsKHByb3RvLCAnYWRkRXZlbnRMaXN0ZW5lcicsIGZ1bmN0aW9uIChvcmlnaW5hbEFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnY2xpY2snIHx8IHR5cGUgPT0gJ2tleXByZXNzJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9ICh0aGlzLl9fc2VudHJ5X2luc3RydW1lbnRhdGlvbl9oYW5kbGVyc19fID1cbiAgICAgICAgICAgICAgdGhpcy5fX3NlbnRyeV9pbnN0cnVtZW50YXRpb25faGFuZGxlcnNfXyB8fCB7fSk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyRm9yVHlwZSA9IChoYW5kbGVyc1t0eXBlXSA9IGhhbmRsZXJzW3R5cGVdIHx8IHsgcmVmQ291bnQ6IDAgfSk7XG5cbiAgICAgICAgICAgIGlmICghaGFuZGxlckZvclR5cGUuaGFuZGxlcikge1xuICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gbWFrZURPTUV2ZW50SGFuZGxlcih0cmlnZ2VyRE9NSGFuZGxlcik7XG4gICAgICAgICAgICAgIGhhbmRsZXJGb3JUeXBlLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICAgICAgICBvcmlnaW5hbEFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlckZvclR5cGUucmVmQ291bnQrKztcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBBY2Nlc3NpbmcgZG9tIHByb3BlcnRpZXMgaXMgYWx3YXlzIGZyYWdpbGUuXG4gICAgICAgICAgICAvLyBBbHNvIGFsbG93cyB1cyB0byBza2lwIGBhZGRFdmVudExpc3RlbmVyc2AgY2FsbHMgd2l0aCBubyBwcm9wZXIgYHRoaXNgIGNvbnRleHQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBmaWxsKFxuICAgICAgcHJvdG8sXG4gICAgICAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsXG4gICAgICBmdW5jdGlvbiAob3JpZ2luYWxSZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PSAna2V5cHJlc3MnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX19zZW50cnlfaW5zdHJ1bWVudGF0aW9uX2hhbmRsZXJzX18gfHwge307XG4gICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJGb3JUeXBlID0gaGFuZGxlcnNbdHlwZV07XG5cbiAgICAgICAgICAgICAgaWYgKGhhbmRsZXJGb3JUeXBlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlckZvclR5cGUucmVmQ291bnQtLTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gbG9uZ2VyIGFueSBjdXN0b20gaGFuZGxlcnMgb2YgdGhlIGN1cnJlbnQgdHlwZSBvbiB0aGlzIGVsZW1lbnQsIHdlIGNhbiByZW1vdmUgb3VycywgdG9vLlxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyRm9yVHlwZS5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICBvcmlnaW5hbFJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBoYW5kbGVyRm9yVHlwZS5oYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZXJGb3JUeXBlLmhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgaGFuZGxlcnNbdHlwZV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGxvbmdlciBhbnkgY3VzdG9tIGhhbmRsZXJzIG9mIGFueSB0eXBlIG9uIHRoaXMgZWxlbWVudCwgY2xlYW51cCBldmVyeXRoaW5nLlxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhoYW5kbGVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fX3NlbnRyeV9pbnN0cnVtZW50YXRpb25faGFuZGxlcnNfXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gQWNjZXNzaW5nIGRvbSBwcm9wZXJ0aWVzIGlzIGFsd2F5cyBmcmFnaWxlLlxuICAgICAgICAgICAgICAvLyBBbHNvIGFsbG93cyB1cyB0byBza2lwIGBhZGRFdmVudExpc3RlbmVyc2AgY2FsbHMgd2l0aCBubyBwcm9wZXIgYHRoaXNgIGNvbnRleHQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZXZlbnQgaXMgc2ltaWxhciB0byB0aGUgbGFzdCBjYXB0dXJlZCBvbmUuIEZvciBleGFtcGxlLCB0d28gY2xpY2sgZXZlbnRzIG9uIHRoZSBzYW1lIGJ1dHRvbi5cbiAqL1xuZnVuY3Rpb24gaXNTaW1pbGFyVG9MYXN0Q2FwdHVyZWRFdmVudChldmVudCkge1xuICAvLyBJZiBib3RoIGV2ZW50cyBoYXZlIGRpZmZlcmVudCB0eXBlLCB0aGVuIHVzZXIgZGVmaW5pdGVseSBwZXJmb3JtZWQgdHdvIHNlcGFyYXRlIGFjdGlvbnMuIGUuZy4gY2xpY2sgKyBrZXlwcmVzcy5cbiAgaWYgKGV2ZW50LnR5cGUgIT09IGxhc3RDYXB0dXJlZEV2ZW50VHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gSWYgYm90aCBldmVudHMgaGF2ZSB0aGUgc2FtZSB0eXBlLCBpdCdzIHN0aWxsIHBvc3NpYmxlIHRoYXQgYWN0aW9ucyB3ZXJlIHBlcmZvcm1lZCBvbiBkaWZmZXJlbnQgdGFyZ2V0cy5cbiAgICAvLyBlLmcuIDIgY2xpY2tzIG9uIGRpZmZlcmVudCBidXR0b25zLlxuICAgIGlmICghZXZlbnQudGFyZ2V0IHx8IChldmVudC50YXJnZXQgKS5fc2VudHJ5SWQgIT09IGxhc3RDYXB0dXJlZEV2ZW50VGFyZ2V0SWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBqdXN0IGFjY2Vzc2luZyBgdGFyZ2V0YCBwcm9wZXJ0eSBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGluIHNvbWUgcmFyZSBjaXJjdW1zdGFuY2VzXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy84MzhcbiAgfVxuXG4gIC8vIElmIGJvdGggZXZlbnRzIGhhdmUgdGhlIHNhbWUgdHlwZSBfYW5kXyBzYW1lIGB0YXJnZXRgIChhbiBlbGVtZW50IHdoaWNoIHRyaWdnZXJlZCBhbiBldmVudCwgX25vdCBuZWNlc3NhcmlseV9cbiAgLy8gdG8gd2hpY2ggYW4gZXZlbnQgbGlzdGVuZXIgd2FzIGF0dGFjaGVkKSwgd2UgdHJlYXQgdGhlbSBhcyB0aGUgc2FtZSBhY3Rpb24sIGFzIHdlIHdhbnQgdG8gY2FwdHVyZVxuICAvLyBvbmx5IG9uZSBicmVhZGNydW1iLiBlLmcuIG11bHRpcGxlIGNsaWNrcyBvbiB0aGUgc2FtZSBidXR0b24sIG9yIHR5cGluZyBpbnNpZGUgYSB1c2VyIGlucHV0IGJveC5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgYW4gZXZlbnQgc2hvdWxkIGJlIGNhcHR1cmVkLlxuICogQHBhcmFtIGV2ZW50IGV2ZW50IHRvIGJlIGNhcHR1cmVkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNraXBET01FdmVudChldmVudFR5cGUsIHRhcmdldCkge1xuICAvLyBXZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIGZpbHRlcmluZyBga2V5cHJlc3NgIGV2ZW50cyBmb3Igbm93LlxuICBpZiAoZXZlbnRUeXBlICE9PSAna2V5cHJlc3MnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC50YWdOYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBPbmx5IGNvbnNpZGVyIGtleXByZXNzIGV2ZW50cyBvbiBhY3R1YWwgaW5wdXQgZWxlbWVudHMuIFRoaXMgd2lsbCBkaXNyZWdhcmQga2V5cHJlc3NlcyB0YXJnZXRpbmcgYm9keVxuICAvLyBlLmcudGFiYmluZyB0aHJvdWdoIGVsZW1lbnRzLCBob3RrZXlzLCBldGMuXG4gIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCB0YXJnZXQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCB0YXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBXcmFwcyBhZGRFdmVudExpc3RlbmVyIHRvIGNhcHR1cmUgVUkgYnJlYWRjcnVtYnNcbiAqL1xuZnVuY3Rpb24gbWFrZURPTUV2ZW50SGFuZGxlcihcbiAgaGFuZGxlcixcbiAgZ2xvYmFsTGlzdGVuZXIgPSBmYWxzZSxcbikge1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgLy8gSXQncyBwb3NzaWJsZSB0aGlzIGhhbmRsZXIgbWlnaHQgdHJpZ2dlciBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWVcbiAgICAvLyBldmVudCAoZS5nLiBldmVudCBwcm9wYWdhdGlvbiB0aHJvdWdoIG5vZGUgYW5jZXN0b3JzKS5cbiAgICAvLyBJZ25vcmUgaWYgd2UndmUgYWxyZWFkeSBjYXB0dXJlZCB0aGF0IGV2ZW50LlxuICAgIGlmICghZXZlbnQgfHwgZXZlbnRbJ19zZW50cnlDYXB0dXJlZCddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuXG4gICAgLy8gV2UgYWx3YXlzIHdhbnQgdG8gc2tpcCBfc29tZV8gZXZlbnRzLlxuICAgIGlmIChzaG91bGRTa2lwRE9NRXZlbnQoZXZlbnQudHlwZSwgdGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1hcmsgZXZlbnQgYXMgXCJzZWVuXCJcbiAgICBhZGROb25FbnVtZXJhYmxlUHJvcGVydHkoZXZlbnQsICdfc2VudHJ5Q2FwdHVyZWQnLCB0cnVlKTtcblxuICAgIGlmICh0YXJnZXQgJiYgIXRhcmdldC5fc2VudHJ5SWQpIHtcbiAgICAgIC8vIEFkZCBVVUlEIHRvIGV2ZW50IHRhcmdldCBzbyB3ZSBjYW4gaWRlbnRpZnkgaWZcbiAgICAgIGFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eSh0YXJnZXQsICdfc2VudHJ5SWQnLCB1dWlkNCgpKTtcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJyA/ICdpbnB1dCcgOiBldmVudC50eXBlO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbGFzdCBjYXB0dXJlZCBldmVudCwgaXQgbWVhbnMgdGhhdCB3ZSBjYW4gc2FmZWx5IGNhcHR1cmUgdGhlIG5ldyBldmVudCBhbmQgc3RvcmUgaXQgZm9yIGZ1dHVyZSBjb21wYXJpc29ucy5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIGxhc3QgY2FwdHVyZWQgZXZlbnQsIHNlZSBpZiB0aGUgbmV3IGV2ZW50IGlzIGRpZmZlcmVudCBlbm91Z2ggdG8gdHJlYXQgaXQgYXMgYSB1bmlxdWUgb25lLlxuICAgIC8vIElmIHRoYXQncyB0aGUgY2FzZSwgZW1pdCB0aGUgcHJldmlvdXMgZXZlbnQgYW5kIHN0b3JlIGxvY2FsbHkgdGhlIG5ld2x5LWNhcHR1cmVkIERPTSBldmVudC5cbiAgICBpZiAoIWlzU2ltaWxhclRvTGFzdENhcHR1cmVkRXZlbnQoZXZlbnQpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyRGF0YSA9IHsgZXZlbnQsIG5hbWUsIGdsb2JhbDogZ2xvYmFsTGlzdGVuZXIgfTtcbiAgICAgIGhhbmRsZXIoaGFuZGxlckRhdGEpO1xuICAgICAgbGFzdENhcHR1cmVkRXZlbnRUeXBlID0gZXZlbnQudHlwZTtcbiAgICAgIGxhc3RDYXB0dXJlZEV2ZW50VGFyZ2V0SWQgPSB0YXJnZXQgPyB0YXJnZXQuX3NlbnRyeUlkIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IGEgbmV3IGRlYm91bmNlIHRpbWVyIHRoYXQgd2lsbCBwcmV2ZW50IHVzIGZyb20gY2FwdHVyaW5nIG11bHRpcGxlIGV2ZW50cyB0aGF0IHNob3VsZCBiZSBncm91cGVkIHRvZ2V0aGVyLlxuICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVySUQpO1xuICAgIGRlYm91bmNlVGltZXJJRCA9IFdJTkRPVy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGxhc3RDYXB0dXJlZEV2ZW50VGFyZ2V0SWQgPSB1bmRlZmluZWQ7XG4gICAgICBsYXN0Q2FwdHVyZWRFdmVudFR5cGUgPSB1bmRlZmluZWQ7XG4gICAgfSwgREVCT1VOQ0VfRFVSQVRJT04pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xuICB0cnkge1xuICAgIHJldHVybiBldmVudC50YXJnZXQgO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8ganVzdCBhY2Nlc3NpbmcgYHRhcmdldGAgcHJvcGVydHkgY2FuIHRocm93IGFuIGV4Y2VwdGlvbiBpbiBzb21lIHJhcmUgY2lyY3Vtc3RhbmNlc1xuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvODM4XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IHsgYWRkQ2xpY2tLZXlwcmVzc0luc3RydW1lbnRhdGlvbkhhbmRsZXIsIGluc3RydW1lbnRET00gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/instrument/dom.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/instrument/history.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@sentry-internal/browser-utils/build/esm/instrument/history.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addHistoryInstrumentationHandler: () => (/* binding */ addHistoryInstrumentationHandler)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/instrument/handlers.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/vendor/supportsHistory.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/object.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types.js */ \"(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/types.js\");\n\n\n\nlet lastHref;\n\n/**\n * Add an instrumentation handler for when a fetch request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addHistoryInstrumentationHandler(handler) {\n  const type = 'history';\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addHandler)(type, handler);\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.maybeInstrument)(type, instrumentHistory);\n}\n\nfunction instrumentHistory() {\n  if (!(0,_sentry_core__WEBPACK_IMPORTED_MODULE_1__.supportsHistory)()) {\n    return;\n  }\n\n  const oldOnPopState = _types_js__WEBPACK_IMPORTED_MODULE_2__.WINDOW.onpopstate;\n  _types_js__WEBPACK_IMPORTED_MODULE_2__.WINDOW.onpopstate = function ( ...args) {\n    const to = _types_js__WEBPACK_IMPORTED_MODULE_2__.WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    const handlerData = { from, to };\n    (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.triggerHandlers)('history', handlerData);\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function ( ...args) {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        const handlerData = { from, to };\n        (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.triggerHandlers)('history', handlerData);\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_3__.fill)(_types_js__WEBPACK_IMPORTED_MODULE_2__.WINDOW.history, 'pushState', historyReplacementFunction);\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_3__.fill)(_types_js__WEBPACK_IMPORTED_MODULE_2__.WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n\n\n//# sourceMappingURL=history.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS9pbnN0cnVtZW50L2hpc3RvcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUc7QUFDOUQ7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx3REFBVTtBQUNaLEVBQUUsNkRBQWU7QUFDakI7O0FBRUE7QUFDQSxPQUFPLDZEQUFlO0FBQ3RCO0FBQ0E7O0FBRUEsd0JBQXdCLDZDQUFNO0FBQzlCLEVBQUUsNkNBQU07QUFDUixlQUFlLDZDQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixJQUFJLDZEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsUUFBUSw2REFBZTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLGtEQUFJLENBQUMsNkNBQU07QUFDYixFQUFFLGtEQUFJLENBQUMsNkNBQU07QUFDYjs7QUFFNEM7QUFDNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS9pbnN0cnVtZW50L2hpc3RvcnkuanM/ZDg2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGRIYW5kbGVyLCBtYXliZUluc3RydW1lbnQsIHN1cHBvcnRzSGlzdG9yeSwgdHJpZ2dlckhhbmRsZXJzLCBmaWxsIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcbmltcG9ydCB7IFdJTkRPVyB9IGZyb20gJy4uL3R5cGVzLmpzJztcblxubGV0IGxhc3RIcmVmO1xuXG4vKipcbiAqIEFkZCBhbiBpbnN0cnVtZW50YXRpb24gaGFuZGxlciBmb3Igd2hlbiBhIGZldGNoIHJlcXVlc3QgaGFwcGVucy5cbiAqIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIHdoZW4gdGhlIHJlcXVlc3Qgc3RhcnRzIGFuZCBvbmNlIHdoZW4gaXQgZW5kcyxcbiAqIHdoaWNoIGNhbiBiZSBpZGVudGlmaWVkIGJ5IGNoZWNraW5nIGlmIGl0IGhhcyBhbiBgZW5kVGltZXN0YW1wYC5cbiAqXG4gKiBVc2UgYXQgeW91ciBvd24gcmlzaywgdGhpcyBtaWdodCBicmVhayB3aXRob3V0IGNoYW5nZWxvZyBub3RpY2UsIG9ubHkgdXNlZCBpbnRlcm5hbGx5LlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhZGRIaXN0b3J5SW5zdHJ1bWVudGF0aW9uSGFuZGxlcihoYW5kbGVyKSB7XG4gIGNvbnN0IHR5cGUgPSAnaGlzdG9yeSc7XG4gIGFkZEhhbmRsZXIodHlwZSwgaGFuZGxlcik7XG4gIG1heWJlSW5zdHJ1bWVudCh0eXBlLCBpbnN0cnVtZW50SGlzdG9yeSk7XG59XG5cbmZ1bmN0aW9uIGluc3RydW1lbnRIaXN0b3J5KCkge1xuICBpZiAoIXN1cHBvcnRzSGlzdG9yeSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgb2xkT25Qb3BTdGF0ZSA9IFdJTkRPVy5vbnBvcHN0YXRlO1xuICBXSU5ET1cub25wb3BzdGF0ZSA9IGZ1bmN0aW9uICggLi4uYXJncykge1xuICAgIGNvbnN0IHRvID0gV0lORE9XLmxvY2F0aW9uLmhyZWY7XG4gICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBVUkwgc3RhdGUsIGFzIHdlIGFsd2F5cyByZWNlaXZlIG9ubHkgdGhlIHVwZGF0ZWQgc3RhdGVcbiAgICBjb25zdCBmcm9tID0gbGFzdEhyZWY7XG4gICAgbGFzdEhyZWYgPSB0bztcbiAgICBjb25zdCBoYW5kbGVyRGF0YSA9IHsgZnJvbSwgdG8gfTtcbiAgICB0cmlnZ2VySGFuZGxlcnMoJ2hpc3RvcnknLCBoYW5kbGVyRGF0YSk7XG4gICAgaWYgKG9sZE9uUG9wU3RhdGUpIHtcbiAgICAgIC8vIEFwcGFyZW50bHkgdGhpcyBjYW4gdGhyb3cgaW4gRmlyZWZveCB3aGVuIGluY29ycmVjdGx5IGltcGxlbWVudGVkIHBsdWdpbiBpcyBpbnN0YWxsZWQuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8zMzQ0XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnVnc25hZy9idWdzbmFnLWpzL2lzc3Vlcy80NjlcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvbGRPblBvcFN0YXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoX29PKSB7XG4gICAgICAgIC8vIG5vLWVtcHR5XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGhpc3RvcnlSZXBsYWNlbWVudEZ1bmN0aW9uKG9yaWdpbmFsSGlzdG9yeUZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICggLi4uYXJncykge1xuICAgICAgY29uc3QgdXJsID0gYXJncy5sZW5ndGggPiAyID8gYXJnc1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgLy8gY29lcmNlIHRvIHN0cmluZyAodGhpcyBpcyB3aGF0IHB1c2hTdGF0ZSBkb2VzKVxuICAgICAgICBjb25zdCBmcm9tID0gbGFzdEhyZWY7XG4gICAgICAgIGNvbnN0IHRvID0gU3RyaW5nKHVybCk7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgVVJMIHN0YXRlLCBhcyB3ZSBhbHdheXMgcmVjZWl2ZSBvbmx5IHRoZSB1cGRhdGVkIHN0YXRlXG4gICAgICAgIGxhc3RIcmVmID0gdG87XG4gICAgICAgIGNvbnN0IGhhbmRsZXJEYXRhID0geyBmcm9tLCB0byB9O1xuICAgICAgICB0cmlnZ2VySGFuZGxlcnMoJ2hpc3RvcnknLCBoYW5kbGVyRGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxIaXN0b3J5RnVuY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIGZpbGwoV0lORE9XLmhpc3RvcnksICdwdXNoU3RhdGUnLCBoaXN0b3J5UmVwbGFjZW1lbnRGdW5jdGlvbik7XG4gIGZpbGwoV0lORE9XLmhpc3RvcnksICdyZXBsYWNlU3RhdGUnLCBoaXN0b3J5UmVwbGFjZW1lbnRGdW5jdGlvbik7XG59XG5cbmV4cG9ydCB7IGFkZEhpc3RvcnlJbnN0cnVtZW50YXRpb25IYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaXN0b3J5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/instrument/history.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/instrument/xhr.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@sentry-internal/browser-utils/build/esm/instrument/xhr.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SENTRY_XHR_DATA_KEY: () => (/* binding */ SENTRY_XHR_DATA_KEY),\n/* harmony export */   addXhrInstrumentationHandler: () => (/* binding */ addXhrInstrumentationHandler),\n/* harmony export */   instrumentXHR: () => (/* binding */ instrumentXHR)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/instrument/handlers.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/time.js\");\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/is.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.js */ \"(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/types.js\");\n\n\n\nconst SENTRY_XHR_DATA_KEY = '__sentry_xhr_v3__';\n\n/**\n * Add an instrumentation handler for when an XHR request happens.\n * The handler function is called once when the request starts and once when it ends,\n * which can be identified by checking if it has an `endTimestamp`.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addXhrInstrumentationHandler(handler) {\n  const type = 'xhr';\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.addHandler)(type, handler);\n  (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.maybeInstrument)(type, instrumentXHR);\n}\n\n/** Exported only for tests. */\nfunction instrumentXHR() {\n  if (!(_types_js__WEBPACK_IMPORTED_MODULE_1__.WINDOW ).XMLHttpRequest) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  xhrproto.open = new Proxy(xhrproto.open, {\n    apply(originalOpen, xhrOpenThisArg, xhrOpenArgArray) {\n      const startTimestamp = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_2__.timestampInSeconds)() * 1000;\n\n      // open() should always be called with two or more arguments\n      // But to be on the safe side, we actually validate this and bail out if we don't have a method & url\n      const method = (0,_sentry_core__WEBPACK_IMPORTED_MODULE_3__.isString)(xhrOpenArgArray[0]) ? xhrOpenArgArray[0].toUpperCase() : undefined;\n      const url = parseUrl(xhrOpenArgArray[1]);\n\n      if (!method || !url) {\n        return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);\n      }\n\n      xhrOpenThisArg[SENTRY_XHR_DATA_KEY] = {\n        method,\n        url,\n        request_headers: {},\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      if (method === 'POST' && url.match(/sentry_key/)) {\n        xhrOpenThisArg.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = () => {\n        // For whatever reason, this is not the same instance here as from the outer method\n        const xhrInfo = xhrOpenThisArg[SENTRY_XHR_DATA_KEY];\n\n        if (!xhrInfo) {\n          return;\n        }\n\n        if (xhrOpenThisArg.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhrOpenThisArg.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          const handlerData = {\n            endTimestamp: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_2__.timestampInSeconds)() * 1000,\n            startTimestamp,\n            xhr: xhrOpenThisArg,\n          };\n          (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.triggerHandlers)('xhr', handlerData);\n        }\n      };\n\n      if ('onreadystatechange' in xhrOpenThisArg && typeof xhrOpenThisArg.onreadystatechange === 'function') {\n        xhrOpenThisArg.onreadystatechange = new Proxy(xhrOpenThisArg.onreadystatechange, {\n          apply(originalOnreadystatechange, onreadystatechangeThisArg, onreadystatechangeArgArray) {\n            onreadystatechangeHandler();\n            return originalOnreadystatechange.apply(onreadystatechangeThisArg, onreadystatechangeArgArray);\n          },\n        });\n      } else {\n        xhrOpenThisArg.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      // Intercepting `setRequestHeader` to access the request headers of XHR instance.\n      // This will only work for user/library defined headers, not for the default/browser-assigned headers.\n      // Request cookies are also unavailable for XHR, as `Cookie` header can't be defined by `setRequestHeader`.\n      xhrOpenThisArg.setRequestHeader = new Proxy(xhrOpenThisArg.setRequestHeader, {\n        apply(\n          originalSetRequestHeader,\n          setRequestHeaderThisArg,\n          setRequestHeaderArgArray,\n        ) {\n          const [header, value] = setRequestHeaderArgArray;\n\n          const xhrInfo = setRequestHeaderThisArg[SENTRY_XHR_DATA_KEY];\n\n          if (xhrInfo && (0,_sentry_core__WEBPACK_IMPORTED_MODULE_3__.isString)(header) && (0,_sentry_core__WEBPACK_IMPORTED_MODULE_3__.isString)(value)) {\n            xhrInfo.request_headers[header.toLowerCase()] = value;\n          }\n\n          return originalSetRequestHeader.apply(setRequestHeaderThisArg, setRequestHeaderArgArray);\n        },\n      });\n\n      return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);\n    },\n  });\n\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  xhrproto.send = new Proxy(xhrproto.send, {\n    apply(originalSend, sendThisArg, sendArgArray) {\n      const sentryXhrData = sendThisArg[SENTRY_XHR_DATA_KEY];\n\n      if (!sentryXhrData) {\n        return originalSend.apply(sendThisArg, sendArgArray);\n      }\n\n      if (sendArgArray[0] !== undefined) {\n        sentryXhrData.body = sendArgArray[0];\n      }\n\n      const handlerData = {\n        startTimestamp: (0,_sentry_core__WEBPACK_IMPORTED_MODULE_2__.timestampInSeconds)() * 1000,\n        xhr: sendThisArg,\n      };\n      (0,_sentry_core__WEBPACK_IMPORTED_MODULE_0__.triggerHandlers)('xhr', handlerData);\n\n      return originalSend.apply(sendThisArg, sendArgArray);\n    },\n  });\n}\n\nfunction parseUrl(url) {\n  if ((0,_sentry_core__WEBPACK_IMPORTED_MODULE_3__.isString)(url)) {\n    return url;\n  }\n\n  try {\n    // url can be a string or URL\n    // but since URL is not available in IE11, we do not check for it,\n    // but simply assume it is an URL and return `toString()` from it (which returns the full URL)\n    // If that fails, we just return undefined\n    return (url ).toString();\n  } catch (e2) {} // eslint-disable-line no-empty\n\n  return undefined;\n}\n\n\n//# sourceMappingURL=xhr.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS9pbnN0cnVtZW50L3hoci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBHO0FBQ3JFOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsd0RBQVU7QUFDWixFQUFFLDZEQUFlO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxRQUFRLDZDQUFNO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0VBQWtCOztBQUUvQztBQUNBO0FBQ0EscUJBQXFCLHNEQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZ0VBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkRBQWU7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIsc0RBQVEsWUFBWSxzREFBUTtBQUNyRDtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGdFQUFrQjtBQUMxQztBQUNBO0FBQ0EsTUFBTSw2REFBZTs7QUFFckI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0EsTUFBTSxzREFBUTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxjQUFjOztBQUVsQjtBQUNBOztBQUU0RTtBQUM1RSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2VudHJ5LWludGVybmFsL2Jyb3dzZXItdXRpbHMvYnVpbGQvZXNtL2luc3RydW1lbnQveGhyLmpzP2I5ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWRkSGFuZGxlciwgbWF5YmVJbnN0cnVtZW50LCB0aW1lc3RhbXBJblNlY29uZHMsIGlzU3RyaW5nLCB0cmlnZ2VySGFuZGxlcnMgfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuaW1wb3J0IHsgV0lORE9XIH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuXG5jb25zdCBTRU5UUllfWEhSX0RBVEFfS0VZID0gJ19fc2VudHJ5X3hocl92M19fJztcblxuLyoqXG4gKiBBZGQgYW4gaW5zdHJ1bWVudGF0aW9uIGhhbmRsZXIgZm9yIHdoZW4gYW4gWEhSIHJlcXVlc3QgaGFwcGVucy5cbiAqIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIHdoZW4gdGhlIHJlcXVlc3Qgc3RhcnRzIGFuZCBvbmNlIHdoZW4gaXQgZW5kcyxcbiAqIHdoaWNoIGNhbiBiZSBpZGVudGlmaWVkIGJ5IGNoZWNraW5nIGlmIGl0IGhhcyBhbiBgZW5kVGltZXN0YW1wYC5cbiAqXG4gKiBVc2UgYXQgeW91ciBvd24gcmlzaywgdGhpcyBtaWdodCBicmVhayB3aXRob3V0IGNoYW5nZWxvZyBub3RpY2UsIG9ubHkgdXNlZCBpbnRlcm5hbGx5LlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhZGRYaHJJbnN0cnVtZW50YXRpb25IYW5kbGVyKGhhbmRsZXIpIHtcbiAgY29uc3QgdHlwZSA9ICd4aHInO1xuICBhZGRIYW5kbGVyKHR5cGUsIGhhbmRsZXIpO1xuICBtYXliZUluc3RydW1lbnQodHlwZSwgaW5zdHJ1bWVudFhIUik7XG59XG5cbi8qKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0cy4gKi9cbmZ1bmN0aW9uIGluc3RydW1lbnRYSFIoKSB7XG4gIGlmICghKFdJTkRPVyApLlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgeGhycHJvdG8gPSBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGU7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICB4aHJwcm90by5vcGVuID0gbmV3IFByb3h5KHhocnByb3RvLm9wZW4sIHtcbiAgICBhcHBseShvcmlnaW5hbE9wZW4sIHhock9wZW5UaGlzQXJnLCB4aHJPcGVuQXJnQXJyYXkpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZXN0YW1wID0gdGltZXN0YW1wSW5TZWNvbmRzKCkgKiAxMDAwO1xuXG4gICAgICAvLyBvcGVuKCkgc2hvdWxkIGFsd2F5cyBiZSBjYWxsZWQgd2l0aCB0d28gb3IgbW9yZSBhcmd1bWVudHNcbiAgICAgIC8vIEJ1dCB0byBiZSBvbiB0aGUgc2FmZSBzaWRlLCB3ZSBhY3R1YWxseSB2YWxpZGF0ZSB0aGlzIGFuZCBiYWlsIG91dCBpZiB3ZSBkb24ndCBoYXZlIGEgbWV0aG9kICYgdXJsXG4gICAgICBjb25zdCBtZXRob2QgPSBpc1N0cmluZyh4aHJPcGVuQXJnQXJyYXlbMF0pID8geGhyT3BlbkFyZ0FycmF5WzBdLnRvVXBwZXJDYXNlKCkgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCB1cmwgPSBwYXJzZVVybCh4aHJPcGVuQXJnQXJyYXlbMV0pO1xuXG4gICAgICBpZiAoIW1ldGhvZCB8fCAhdXJsKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbE9wZW4uYXBwbHkoeGhyT3BlblRoaXNBcmcsIHhock9wZW5BcmdBcnJheSk7XG4gICAgICB9XG5cbiAgICAgIHhock9wZW5UaGlzQXJnW1NFTlRSWV9YSFJfREFUQV9LRVldID0ge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdF9oZWFkZXJzOiB7fSxcbiAgICAgIH07XG5cbiAgICAgIC8vIGlmIFNlbnRyeSBrZXkgYXBwZWFycyBpbiBVUkwsIGRvbid0IGNhcHR1cmUgaXQgYXMgYSByZXF1ZXN0XG4gICAgICBpZiAobWV0aG9kID09PSAnUE9TVCcgJiYgdXJsLm1hdGNoKC9zZW50cnlfa2V5LykpIHtcbiAgICAgICAgeGhyT3BlblRoaXNBcmcuX19zZW50cnlfb3duX3JlcXVlc3RfXyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9ucmVhZHlzdGF0ZWNoYW5nZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIC8vIEZvciB3aGF0ZXZlciByZWFzb24sIHRoaXMgaXMgbm90IHRoZSBzYW1lIGluc3RhbmNlIGhlcmUgYXMgZnJvbSB0aGUgb3V0ZXIgbWV0aG9kXG4gICAgICAgIGNvbnN0IHhockluZm8gPSB4aHJPcGVuVGhpc0FyZ1tTRU5UUllfWEhSX0RBVEFfS0VZXTtcblxuICAgICAgICBpZiAoIXhockluZm8pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeGhyT3BlblRoaXNBcmcucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0b3VjaGluZyBzdGF0dXNDb2RlIGluIHNvbWUgcGxhdGZvcm1zIHRocm93c1xuICAgICAgICAgICAgLy8gYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICB4aHJJbmZvLnN0YXR1c19jb2RlID0geGhyT3BlblRoaXNBcmcuc3RhdHVzO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBoYW5kbGVyRGF0YSA9IHtcbiAgICAgICAgICAgIGVuZFRpbWVzdGFtcDogdGltZXN0YW1wSW5TZWNvbmRzKCkgKiAxMDAwLFxuICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXAsXG4gICAgICAgICAgICB4aHI6IHhock9wZW5UaGlzQXJnLFxuICAgICAgICAgIH07XG4gICAgICAgICAgdHJpZ2dlckhhbmRsZXJzKCd4aHInLCBoYW5kbGVyRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICgnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiB4aHJPcGVuVGhpc0FyZyAmJiB0eXBlb2YgeGhyT3BlblRoaXNBcmcub25yZWFkeXN0YXRlY2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHhock9wZW5UaGlzQXJnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG5ldyBQcm94eSh4aHJPcGVuVGhpc0FyZy5vbnJlYWR5c3RhdGVjaGFuZ2UsIHtcbiAgICAgICAgICBhcHBseShvcmlnaW5hbE9ucmVhZHlzdGF0ZWNoYW5nZSwgb25yZWFkeXN0YXRlY2hhbmdlVGhpc0FyZywgb25yZWFkeXN0YXRlY2hhbmdlQXJnQXJyYXkpIHtcbiAgICAgICAgICAgIG9ucmVhZHlzdGF0ZWNoYW5nZUhhbmRsZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE9ucmVhZHlzdGF0ZWNoYW5nZS5hcHBseShvbnJlYWR5c3RhdGVjaGFuZ2VUaGlzQXJnLCBvbnJlYWR5c3RhdGVjaGFuZ2VBcmdBcnJheSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4aHJPcGVuVGhpc0FyZy5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgb25yZWFkeXN0YXRlY2hhbmdlSGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVyY2VwdGluZyBgc2V0UmVxdWVzdEhlYWRlcmAgdG8gYWNjZXNzIHRoZSByZXF1ZXN0IGhlYWRlcnMgb2YgWEhSIGluc3RhbmNlLlxuICAgICAgLy8gVGhpcyB3aWxsIG9ubHkgd29yayBmb3IgdXNlci9saWJyYXJ5IGRlZmluZWQgaGVhZGVycywgbm90IGZvciB0aGUgZGVmYXVsdC9icm93c2VyLWFzc2lnbmVkIGhlYWRlcnMuXG4gICAgICAvLyBSZXF1ZXN0IGNvb2tpZXMgYXJlIGFsc28gdW5hdmFpbGFibGUgZm9yIFhIUiwgYXMgYENvb2tpZWAgaGVhZGVyIGNhbid0IGJlIGRlZmluZWQgYnkgYHNldFJlcXVlc3RIZWFkZXJgLlxuICAgICAgeGhyT3BlblRoaXNBcmcuc2V0UmVxdWVzdEhlYWRlciA9IG5ldyBQcm94eSh4aHJPcGVuVGhpc0FyZy5zZXRSZXF1ZXN0SGVhZGVyLCB7XG4gICAgICAgIGFwcGx5KFxuICAgICAgICAgIG9yaWdpbmFsU2V0UmVxdWVzdEhlYWRlcixcbiAgICAgICAgICBzZXRSZXF1ZXN0SGVhZGVyVGhpc0FyZyxcbiAgICAgICAgICBzZXRSZXF1ZXN0SGVhZGVyQXJnQXJyYXksXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IFtoZWFkZXIsIHZhbHVlXSA9IHNldFJlcXVlc3RIZWFkZXJBcmdBcnJheTtcblxuICAgICAgICAgIGNvbnN0IHhockluZm8gPSBzZXRSZXF1ZXN0SGVhZGVyVGhpc0FyZ1tTRU5UUllfWEhSX0RBVEFfS0VZXTtcblxuICAgICAgICAgIGlmICh4aHJJbmZvICYmIGlzU3RyaW5nKGhlYWRlcikgJiYgaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICB4aHJJbmZvLnJlcXVlc3RfaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxTZXRSZXF1ZXN0SGVhZGVyLmFwcGx5KHNldFJlcXVlc3RIZWFkZXJUaGlzQXJnLCBzZXRSZXF1ZXN0SGVhZGVyQXJnQXJyYXkpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvcmlnaW5hbE9wZW4uYXBwbHkoeGhyT3BlblRoaXNBcmcsIHhock9wZW5BcmdBcnJheSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICB4aHJwcm90by5zZW5kID0gbmV3IFByb3h5KHhocnByb3RvLnNlbmQsIHtcbiAgICBhcHBseShvcmlnaW5hbFNlbmQsIHNlbmRUaGlzQXJnLCBzZW5kQXJnQXJyYXkpIHtcbiAgICAgIGNvbnN0IHNlbnRyeVhockRhdGEgPSBzZW5kVGhpc0FyZ1tTRU5UUllfWEhSX0RBVEFfS0VZXTtcblxuICAgICAgaWYgKCFzZW50cnlYaHJEYXRhKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFNlbmQuYXBwbHkoc2VuZFRoaXNBcmcsIHNlbmRBcmdBcnJheSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZW5kQXJnQXJyYXlbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZW50cnlYaHJEYXRhLmJvZHkgPSBzZW5kQXJnQXJyYXlbMF07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhbmRsZXJEYXRhID0ge1xuICAgICAgICBzdGFydFRpbWVzdGFtcDogdGltZXN0YW1wSW5TZWNvbmRzKCkgKiAxMDAwLFxuICAgICAgICB4aHI6IHNlbmRUaGlzQXJnLFxuICAgICAgfTtcbiAgICAgIHRyaWdnZXJIYW5kbGVycygneGhyJywgaGFuZGxlckRhdGEpO1xuXG4gICAgICByZXR1cm4gb3JpZ2luYWxTZW5kLmFwcGx5KHNlbmRUaGlzQXJnLCBzZW5kQXJnQXJyYXkpO1xuICAgIH0sXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVVybCh1cmwpIHtcbiAgaWYgKGlzU3RyaW5nKHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyB1cmwgY2FuIGJlIGEgc3RyaW5nIG9yIFVSTFxuICAgIC8vIGJ1dCBzaW5jZSBVUkwgaXMgbm90IGF2YWlsYWJsZSBpbiBJRTExLCB3ZSBkbyBub3QgY2hlY2sgZm9yIGl0LFxuICAgIC8vIGJ1dCBzaW1wbHkgYXNzdW1lIGl0IGlzIGFuIFVSTCBhbmQgcmV0dXJuIGB0b1N0cmluZygpYCBmcm9tIGl0ICh3aGljaCByZXR1cm5zIHRoZSBmdWxsIFVSTClcbiAgICAvLyBJZiB0aGF0IGZhaWxzLCB3ZSBqdXN0IHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gKHVybCApLnRvU3RyaW5nKCk7XG4gIH0gY2F0Y2ggKGUyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHsgU0VOVFJZX1hIUl9EQVRBX0tFWSwgYWRkWGhySW5zdHJ1bWVudGF0aW9uSGFuZGxlciwgaW5zdHJ1bWVudFhIUiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eGhyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/instrument/xhr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/types.js":
/*!************************************************************************!*\
  !*** ./node_modules/@sentry-internal/browser-utils/build/esm/types.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WINDOW: () => (/* binding */ WINDOW)\n/* harmony export */ });\n/* harmony import */ var _sentry_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/@sentry/core/build/esm/utils-hoist/worldwide.js\");\n\n\nconst WINDOW = _sentry_core__WEBPACK_IMPORTED_MODULE_0__.GLOBAL_OBJ\n\n;\n\n\n//# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNlbnRyeS1pbnRlcm5hbC9icm93c2VyLXV0aWxzL2J1aWxkL2VzbS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQzs7QUFFMUMsZUFBZSxvREFBVTs7QUFFekI7O0FBRWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzZW50cnktaW50ZXJuYWwvYnJvd3Nlci11dGlscy9idWlsZC9lc20vdHlwZXMuanM/OTA1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHTE9CQUxfT0JKIH0gZnJvbSAnQHNlbnRyeS9jb3JlJztcblxuY29uc3QgV0lORE9XID0gR0xPQkFMX09CSlxuXG47XG5cbmV4cG9ydCB7IFdJTkRPVyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sentry-internal/browser-utils/build/esm/types.js\n");

/***/ })

};
;