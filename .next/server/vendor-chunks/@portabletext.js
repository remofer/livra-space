"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@portabletext";
exports.ids = ["vendor-chunks/@portabletext"];
exports.modules = {

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorEventListener: () => (/* binding */ EditorEventListener),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   PortableTextEditable: () => (/* binding */ PortableTextEditable),\n/* harmony export */   PortableTextEditor: () => (/* binding */ PortableTextEditor),\n/* harmony export */   coreBehavior: () => (/* binding */ coreBehavior),\n/* harmony export */   coreBehaviors: () => (/* binding */ coreBehaviors),\n/* harmony export */   createLinkBehaviors: () => (/* binding */ createLinkBehaviors),\n/* harmony export */   createMarkdownBehaviors: () => (/* binding */ createMarkdownBehaviors),\n/* harmony export */   defineBehavior: () => (/* binding */ defineBehavior),\n/* harmony export */   defineSchema: () => (/* binding */ defineSchema),\n/* harmony export */   editorMachine: () => (/* binding */ editorMachine),\n/* harmony export */   keyGenerator: () => (/* binding */ defaultKeyGenerator),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorContext: () => (/* binding */ useEditorContext),\n/* harmony export */   usePortableTextEditor: () => (/* binding */ usePortableTextEditor),\n/* harmony export */   usePortableTextEditorSelection: () => (/* binding */ usePortableTextEditorSelection)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _sanity_schema__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @sanity/schema */ \"(ssr)/./node_modules/@sanity/schema/lib/index.mjs\");\n/* harmony import */ var lodash_startcase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.startcase */ \"(ssr)/./node_modules/lodash.startcase/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _xstate_react__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @xstate/react */ \"(ssr)/./node_modules/@xstate/react/dist/xstate-react.development.esm.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/noop.js */ \"(ssr)/./node_modules/lodash/noop.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! slate-react */ \"(ssr)/./node_modules/slate-react/dist/index.es.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/./node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.esm.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var lodash_throttle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/throttle.js */ \"(ssr)/./node_modules/lodash/throttle.js\");\n/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/debounce.js */ \"(ssr)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var _portabletext_patches__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @portabletext/patches */ \"(ssr)/./node_modules/@portabletext/patches/dist/index.js\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/isPlainObject.js */ \"(ssr)/./node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/./node_modules/get-random-values-esm/index.mjs\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/log-ef30c65f.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var lodash_get_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash/get.js */ \"(ssr)/./node_modules/lodash/get.js\");\n/* harmony import */ var lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash/isUndefined.js */ \"(ssr)/./node_modules/lodash/isUndefined.js\");\n/* harmony import */ var lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lodash/omitBy.js */ \"(ssr)/./node_modules/lodash/omitBy.js\");\n/* harmony import */ var _sanity_block_tools__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @sanity/block-tools */ \"(ssr)/./node_modules/@sanity/block-tools/lib/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction defineBehavior(behavior) {\n  return behavior;\n}\nfunction selectionIsCollapsed(context) {\n  return context.selection?.anchor.path.join() === context.selection?.focus.path.join() && context.selection?.anchor.offset === context.selection?.focus.offset;\n}\nfunction getFocusBlock(context) {\n  const key = context.selection && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}\nfunction getFocusTextBlock(context) {\n  const focusBlock = getFocusBlock(context);\n  return focusBlock && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}\nfunction getFocusBlockObject(context) {\n  const focusBlock = getFocusBlock(context);\n  return focusBlock && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(focusBlock.node) ? {\n    node: focusBlock.node,\n    path: focusBlock.path\n  } : void 0;\n}\nfunction getFocusChild(context) {\n  const focusBlock = getFocusTextBlock(context);\n  if (!focusBlock)\n    return;\n  const key = context.selection && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isKeySegment)(context.selection.focus.path[2]) ? context.selection.focus.path[2]._key : void 0, node = key ? focusBlock.node.children.find((span) => span._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [...focusBlock.path, \"children\", {\n      _key: key\n    }]\n  } : void 0;\n}\nfunction getFocusSpan(context) {\n  const focusChild = getFocusChild(context);\n  return focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan)(focusChild.node) ? {\n    node: focusChild.node,\n    path: focusChild.path\n  } : void 0;\n}\nfunction getSelectionStartBlock(context) {\n  const key = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}\nfunction getSelectionEndBlock(context) {\n  const key = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;\n  return node && key ? {\n    node,\n    path: [{\n      _key: key\n    }]\n  } : void 0;\n}\nfunction getPreviousBlock(context) {\n  let previousBlock;\n  const selectionStartBlock = getSelectionStartBlock(context);\n  if (!selectionStartBlock)\n    return;\n  let foundSelectionStartBlock = !1;\n  for (const block of context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = !0;\n      break;\n    }\n    previousBlock = {\n      node: block,\n      path: [{\n        _key: block._key\n      }]\n    };\n  }\n  if (foundSelectionStartBlock && previousBlock)\n    return previousBlock;\n}\nfunction getNextBlock(context) {\n  let nextBlock;\n  const selectionEndBlock = getSelectionEndBlock(context);\n  if (!selectionEndBlock)\n    return;\n  let foundSelectionEndBlock = !1;\n  for (const block of context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = !0;\n      continue;\n    }\n    if (foundSelectionEndBlock) {\n      nextBlock = {\n        node: block,\n        path: [{\n          _key: block._key\n        }]\n      };\n      break;\n    }\n  }\n  if (foundSelectionEndBlock && nextBlock)\n    return nextBlock;\n}\nfunction isEmptyTextBlock(block) {\n  if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(block))\n    return !1;\n  const onlyText = block.children.every(_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan), blockText = getTextBlockText(block);\n  return onlyText && blockText === \"\";\n}\nfunction getTextBlockText(block) {\n  return block.children.map((child) => child.text ?? \"\").join(\"\");\n}\nconst breakingBlockObject = {\n  on: \"insert break\",\n  guard: ({\n    context\n  }) => !!getFocusBlockObject(context),\n  actions: [() => [{\n    type: \"insert text block\",\n    placement: \"after\"\n  }]]\n}, deletingEmptyTextBlockAfterBlockObject = {\n  on: \"delete backward\",\n  guard: ({\n    context\n  }) => {\n    const focusTextBlock = getFocusTextBlock(context), selectionCollapsed = selectionIsCollapsed(context), previousBlock = getPreviousBlock(context);\n    return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : isEmptyTextBlock(focusTextBlock.node) && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(previousBlock.node) ? {\n      focusTextBlock,\n      previousBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    previousBlock\n  }) => [{\n    type: \"delete block\",\n    blockPath: focusTextBlock.path\n  }, {\n    type: \"select\",\n    selection: {\n      anchor: {\n        path: previousBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: previousBlock.path,\n        offset: 0\n      }\n    }\n  }]]\n}, deletingEmptyTextBlockBeforeBlockObject = {\n  on: \"delete forward\",\n  guard: ({\n    context\n  }) => {\n    const focusTextBlock = getFocusTextBlock(context), selectionCollapsed = selectionIsCollapsed(context), nextBlock = getNextBlock(context);\n    return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : isEmptyTextBlock(focusTextBlock.node) && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(nextBlock.node) ? {\n      focusTextBlock,\n      nextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    nextBlock\n  }) => [{\n    type: \"delete block\",\n    blockPath: focusTextBlock.path\n  }, {\n    type: \"select\",\n    selection: {\n      anchor: {\n        path: nextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: nextBlock.path,\n        offset: 0\n      }\n    }\n  }]]\n}, coreBlockObjectBehaviors = {\n  breakingBlockObject,\n  deletingEmptyTextBlockAfterBlockObject,\n  deletingEmptyTextBlockBeforeBlockObject\n}, decoratorAdd = {\n  on: \"decorator.add\",\n  actions: [({\n    event\n  }) => [{\n    type: \"decorator.add\",\n    decorator: event.decorator\n  }, {\n    type: \"reselect\"\n  }]]\n}, decoratorRemove = {\n  on: \"decorator.remove\",\n  actions: [({\n    event\n  }) => [{\n    type: \"decorator.remove\",\n    decorator: event.decorator\n  }, {\n    type: \"reselect\"\n  }]]\n}, decoratorToggle = {\n  on: \"decorator.toggle\",\n  actions: [({\n    event\n  }) => [{\n    type: \"decorator.toggle\",\n    decorator: event.decorator\n  }, {\n    type: \"reselect\"\n  }]]\n}, coreDecoratorBehaviors = {\n  decoratorAdd,\n  decoratorRemove,\n  decoratorToggle\n}, clearListOnBackspace = {\n  on: \"delete backward\",\n  guard: ({\n    context\n  }) => {\n    const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection.focus.offset === 0 && focusTextBlock.node.level === 1 ? {\n      focusTextBlock\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock\n  }) => [{\n    type: \"unset block\",\n    props: [\"listItem\", \"level\"],\n    paths: [focusTextBlock.path]\n  }]]\n}, unindentListOnBackspace = {\n  on: \"delete backward\",\n  guard: ({\n    context\n  }) => {\n    const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {\n      focusTextBlock,\n      level: focusTextBlock.node.level - 1\n    } : !1;\n  },\n  actions: [(_, {\n    focusTextBlock,\n    level\n  }) => [{\n    type: \"set block\",\n    level,\n    paths: [focusTextBlock.path]\n  }]]\n}, coreListBehaviors = {\n  clearListOnBackspace,\n  unindentListOnBackspace\n}, softReturn = {\n  on: \"insert soft break\",\n  actions: [() => [{\n    type: \"insert text\",\n    text: `\n`\n  }]]\n}, coreBehaviors = [softReturn, coreDecoratorBehaviors.decoratorAdd, coreDecoratorBehaviors.decoratorRemove, coreDecoratorBehaviors.decoratorToggle, coreBlockObjectBehaviors.breakingBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject, coreListBehaviors.clearListOnBackspace, coreListBehaviors.unindentListOnBackspace], coreBehavior = {\n  softReturn,\n  decorators: coreDecoratorBehaviors,\n  blockObjects: coreBlockObjectBehaviors,\n  lists: coreListBehaviors\n};\nfunction createLinkBehaviors(config) {\n  const pasteLinkOnSelection = {\n    on: \"paste\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const selectionCollapsed = selectionIsCollapsed(context), text = event.clipboardData.getData(\"text/plain\"), url = looksLikeUrl(text) ? text : void 0, annotation = url !== void 0 ? config.linkAnnotation?.({\n        url,\n        schema: context.schema\n      }) : void 0;\n      return annotation && !selectionCollapsed ? {\n        annotation\n      } : !1;\n    },\n    actions: [(_, {\n      annotation\n    }) => [{\n      type: \"annotation.add\",\n      annotation\n    }]]\n  }, pasteLinkAtCaret = {\n    on: \"paste\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const focusSpan = getFocusSpan(context), selectionCollapsed = selectionIsCollapsed(context);\n      if (!focusSpan || !selectionCollapsed)\n        return !1;\n      const text = event.clipboardData.getData(\"text/plain\"), url = looksLikeUrl(text) ? text : void 0, annotation = url !== void 0 ? config.linkAnnotation?.({\n        url,\n        schema: context.schema\n      }) : void 0;\n      return url && annotation && selectionCollapsed ? {\n        focusSpan,\n        annotation,\n        url\n      } : !1;\n    },\n    actions: [(_, {\n      annotation,\n      url\n    }) => [{\n      type: \"insert span\",\n      text: url,\n      annotations: [annotation]\n    }]]\n  };\n  return [pasteLinkOnSelection, pasteLinkAtCaret];\n}\nfunction looksLikeUrl(text) {\n  let looksLikeUrl2 = !1;\n  try {\n    new URL(text), looksLikeUrl2 = !0;\n  } catch {\n  }\n  return looksLikeUrl2;\n}\nfunction blockOffsetToSpanSelectionPoint({\n  value,\n  blockOffset\n}) {\n  let offsetLeft = blockOffset.offset, selectionPoint;\n  for (const block of value)\n    if (block._key === blockOffset.path[0]._key && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(block)) {\n      for (const child of block.children)\n        if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan)(child)) {\n          if (offsetLeft === 0) {\n            selectionPoint = {\n              path: [...blockOffset.path, \"children\", {\n                _key: child._key\n              }],\n              offset: 0\n            };\n            break;\n          }\n          if (offsetLeft <= child.text.length) {\n            selectionPoint = {\n              path: [...blockOffset.path, \"children\", {\n                _key: child._key\n              }],\n              offset: offsetLeft\n            };\n            break;\n          }\n          offsetLeft -= child.text.length;\n        }\n    }\n  return selectionPoint;\n}\nfunction spanSelectionPointToBlockOffset({\n  value,\n  selectionPoint\n}) {\n  let offset = 0;\n  for (const block of value)\n    if (block._key === selectionPoint.path[0]._key && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(block)) {\n      for (const child of block.children)\n        if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan)(child)) {\n          if (child._key === selectionPoint.path[2]._key)\n            return {\n              path: [{\n                _key: block._key\n              }],\n              offset: offset + selectionPoint.offset\n            };\n          offset += child.text.length;\n        }\n    }\n}\nfunction isKeyedSegment$1(segment) {\n  return typeof segment == \"object\" && segment !== null && \"_key\" in segment;\n}\nfunction reverseSelection(selection) {\n  return selection && (selection.backward ? {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: !1\n  } : {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: !0\n  });\n}\nfunction getSelectionText({\n  value,\n  selection\n}) {\n  let text = \"\";\n  if (!value || !selection)\n    return text;\n  const forwardSelection = selection.backward ? reverseSelection(selection) : selection;\n  if (!forwardSelection)\n    return text;\n  for (const block of value)\n    if (!(isKeyedSegment$1(forwardSelection.anchor.path[0]) && block._key !== forwardSelection.anchor.path[0]._key) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(block)) {\n      for (const child of block.children)\n        if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan)(child)) {\n          if (isKeyedSegment$1(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key && isKeyedSegment$1(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {\n            text = text + child.text.slice(forwardSelection.anchor.offset, forwardSelection.focus.offset);\n            break;\n          }\n          if (isKeyedSegment$1(forwardSelection.anchor.path[2]) && child._key === forwardSelection.anchor.path[2]._key) {\n            text = text + child.text.slice(forwardSelection.anchor.offset);\n            continue;\n          }\n          if (isKeyedSegment$1(forwardSelection.focus.path[2]) && child._key === forwardSelection.focus.path[2]._key) {\n            text = text + child.text.slice(0, forwardSelection.focus.offset);\n            break;\n          }\n        }\n      if (isKeyedSegment$1(forwardSelection.focus.path[0]) && block._key === forwardSelection.focus.path[0]._key)\n        break;\n    }\n  return text;\n}\nfunction getStartPoint({\n  node,\n  path\n}) {\n  return (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(node) ? {\n    path: [...path, \"children\", {\n      _key: node.children[0]._key\n    }],\n    offset: 0\n  } : {\n    path,\n    offset: 0\n  };\n}\nfunction getBlockTextBefore({\n  value,\n  point\n}) {\n  const key = isKeyedSegment$1(point.path[0]) ? point.path[0]._key : void 0, block = key ? value.find((block2) => block2._key === key) : void 0;\n  if (!block)\n    return \"\";\n  const startPoint = getStartPoint({\n    node: block,\n    path: [{\n      _key: block._key\n    }]\n  });\n  return getSelectionText({\n    value,\n    selection: {\n      anchor: startPoint,\n      focus: point\n    }\n  });\n}\nfunction createMarkdownBehaviors(config) {\n  const automaticBlockquoteOnSpace = {\n    on: \"insert text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: context.selection.focus.offset\n        }\n      });\n      if (!blockOffset)\n        return !1;\n      const blockText = getTextBlockText(focusTextBlock.node), caretAtTheEndOfQuote = blockOffset.offset === 1, looksLikeMarkdownQuote = /^>/.test(blockText), blockquoteStyle = config.blockquoteStyle?.({\n        schema: context.schema\n      });\n      return caretAtTheEndOfQuote && looksLikeMarkdownQuote && blockquoteStyle !== void 0 ? {\n        focusTextBlock,\n        style: blockquoteStyle\n      } : !1;\n    },\n    actions: [() => [{\n      type: \"insert text\",\n      text: \" \"\n    }], (_, {\n      focusTextBlock,\n      style\n    }) => [{\n      type: \"unset block\",\n      props: [\"listItem\", \"level\"],\n      paths: [focusTextBlock.path]\n    }, {\n      type: \"set block\",\n      style,\n      paths: [focusTextBlock.path]\n    }, {\n      type: \"delete text\",\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: 2\n      }\n    }]]\n  }, automaticHr = {\n    on: \"insert text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const hrCharacter = event.text === \"-\" ? \"-\" : event.text === \"*\" ? \"*\" : event.text === \"_\" ? \"_\" : void 0;\n      if (hrCharacter === void 0)\n        return !1;\n      const hrObject = config.horizontalRuleObject?.({\n        schema: context.schema\n      }), focusBlock = getFocusTextBlock(context), selectionCollapsed = selectionIsCollapsed(context);\n      if (!hrObject || !focusBlock || !selectionCollapsed)\n        return !1;\n      const textBefore = getBlockTextBefore({\n        value: context.value,\n        point: context.selection.focus\n      }), hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3\n        }\n      };\n      return textBefore === `${hrCharacter}${hrCharacter}` ? {\n        hrObject,\n        focusBlock,\n        hrCharacter,\n        hrBlockOffsets\n      } : !1;\n    },\n    actions: [(_, {\n      hrCharacter\n    }) => [{\n      type: \"insert text\",\n      text: hrCharacter\n    }], (_, {\n      hrObject,\n      hrBlockOffsets\n    }) => [{\n      type: \"insert block object\",\n      placement: \"before\",\n      blockObject: hrObject\n    }, {\n      type: \"delete text\",\n      ...hrBlockOffsets\n    }]]\n  }, automaticHrOnPaste = {\n    on: \"paste\",\n    guard: ({\n      context,\n      event\n    }) => {\n      const text = event.clipboardData.getData(\"text/plain\"), hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/gm, hrCharacters = text.match(hrRegExp)?.[0], hrObject = config.horizontalRuleObject?.({\n        schema: context.schema\n      }), focusBlock = getFocusBlock(context);\n      return !hrCharacters || !hrObject || !focusBlock ? !1 : {\n        hrCharacters,\n        hrObject,\n        focusBlock\n      };\n    },\n    actions: [(_, {\n      hrCharacters\n    }) => [{\n      type: \"insert text\",\n      text: hrCharacters\n    }], (_, {\n      hrObject,\n      focusBlock\n    }) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(focusBlock.node) ? [{\n      type: \"insert text block\",\n      textBlock: {\n        children: focusBlock.node.children\n      },\n      placement: \"after\"\n    }, {\n      type: \"insert block object\",\n      blockObject: hrObject,\n      placement: \"after\"\n    }, {\n      type: \"delete block\",\n      blockPath: focusBlock.path\n    }] : [{\n      type: \"insert block object\",\n      blockObject: hrObject,\n      placement: \"after\"\n    }]]\n  }, automaticHeadingOnSpace = {\n    on: \"insert text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: context.selection.focus.offset\n        }\n      });\n      if (!blockOffset)\n        return !1;\n      const blockText = getTextBlockText(focusTextBlock.node), markdownHeadingSearch = /^#+/.exec(blockText), level = markdownHeadingSearch ? markdownHeadingSearch[0].length : void 0;\n      if (blockOffset.offset !== level)\n        return !1;\n      const style = level !== void 0 ? config.headingStyle?.({\n        schema: context.schema,\n        level\n      }) : void 0;\n      return level !== void 0 && style !== void 0 ? {\n        focusTextBlock,\n        style,\n        level\n      } : !1;\n    },\n    actions: [() => [{\n      type: \"insert text\",\n      text: \" \"\n    }], (_, {\n      focusTextBlock,\n      style,\n      level\n    }) => [{\n      type: \"unset block\",\n      props: [\"listItem\", \"level\"],\n      paths: [focusTextBlock.path]\n    }, {\n      type: \"set block\",\n      style,\n      paths: [focusTextBlock.path]\n    }, {\n      type: \"delete text\",\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: level + 1\n      }\n    }]]\n  }, clearStyleOnBackspace = {\n    on: \"delete backward\",\n    guard: ({\n      context\n    }) => {\n      const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const atTheBeginningOfBLock = focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection.focus.offset === 0, defaultStyle = config.defaultStyle?.({\n        schema: context.schema\n      });\n      return atTheBeginningOfBLock && defaultStyle && focusTextBlock.node.style !== defaultStyle ? {\n        defaultStyle,\n        focusTextBlock\n      } : !1;\n    },\n    actions: [(_, {\n      defaultStyle,\n      focusTextBlock\n    }) => [{\n      type: \"set block\",\n      style: defaultStyle,\n      paths: [focusTextBlock.path]\n    }]]\n  }, automaticListOnSpace = {\n    on: \"insert text\",\n    guard: ({\n      context,\n      event\n    }) => {\n      if (event.text !== \" \")\n        return !1;\n      const selectionCollapsed = selectionIsCollapsed(context), focusTextBlock = getFocusTextBlock(context), focusSpan = getFocusSpan(context);\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan)\n        return !1;\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [{\n            _key: focusTextBlock.node._key\n          }, \"children\", {\n            _key: focusSpan.node._key\n          }],\n          offset: context.selection.focus.offset\n        }\n      });\n      if (!blockOffset)\n        return !1;\n      const blockText = getTextBlockText(focusTextBlock.node), defaultStyle = config.defaultStyle?.({\n        schema: context.schema\n      }), looksLikeUnorderedList = /^(-|\\*)/.test(blockText), unorderedListStyle = config.unorderedListStyle?.({\n        schema: context.schema\n      }), caretAtTheEndOfUnorderedList = blockOffset.offset === 1;\n      if (defaultStyle && caretAtTheEndOfUnorderedList && looksLikeUnorderedList && unorderedListStyle !== void 0)\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle\n        };\n      const looksLikeOrderedList = /^1\\./.test(blockText), orderedListStyle = config.orderedListStyle?.({\n        schema: context.schema\n      }), caretAtTheEndOfOrderedList = blockOffset.offset === 2;\n      return defaultStyle && caretAtTheEndOfOrderedList && looksLikeOrderedList && orderedListStyle !== void 0 ? {\n        focusTextBlock,\n        listItem: orderedListStyle,\n        listItemLength: 2,\n        style: defaultStyle\n      } : !1;\n    },\n    actions: [() => [{\n      type: \"insert text\",\n      text: \" \"\n    }], (_, {\n      focusTextBlock,\n      style,\n      listItem,\n      listItemLength\n    }) => [{\n      type: \"set block\",\n      listItem,\n      level: 1,\n      style,\n      paths: [focusTextBlock.path]\n    }, {\n      type: \"delete text\",\n      anchor: {\n        path: focusTextBlock.path,\n        offset: 0\n      },\n      focus: {\n        path: focusTextBlock.path,\n        offset: listItemLength + 1\n      }\n    }]]\n  };\n  return [automaticBlockquoteOnSpace, automaticHeadingOnSpace, automaticHr, automaticHrOnPaste, clearStyleOnBackspace, automaticListOnSpace];\n}\nfunction getPortableTextMemberSchemaTypes(portableTextType) {\n  if (!portableTextType)\n    throw new Error(\"Parameter 'portabletextType' missing (required)\");\n  const blockType = portableTextType.of?.find(findBlockType);\n  if (!blockType)\n    throw new Error(\"Block type is not defined in this schema (required)\");\n  const childrenField = blockType.fields?.find((field) => field.name === \"children\");\n  if (!childrenField)\n    throw new Error(\"Children field for block type found in schema (required)\");\n  const ofType = childrenField.type.of;\n  if (!ofType)\n    throw new Error(\"Valid types for block children not found in schema (required)\");\n  const spanType = ofType.find((memberType) => memberType.name === \"span\");\n  if (!spanType)\n    throw new Error(\"Span type not found in schema (required)\");\n  const inlineObjectTypes = ofType.filter((memberType) => memberType.name !== \"span\") || [], blockObjectTypes = portableTextType.of?.filter((field) => field.name !== blockType.name) || [];\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: spanType.annotations\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  const styleField = blockType.fields?.find((btField) => btField.name === \"style\");\n  if (!styleField)\n    throw new Error(\"A field with name 'style' is not defined in the block type (required).\");\n  const textStyles = styleField.type.options?.list && styleField.type.options.list?.filter((style) => style.value);\n  if (!textStyles || textStyles.length === 0)\n    throw new Error(\"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\");\n  return textStyles;\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  const listField = blockType.fields?.find((btField) => btField.name === \"listItem\");\n  if (!listField)\n    throw new Error(\"A field with name 'listItem' is not defined in the block type (required).\");\n  const listItems = listField.type.options?.list && listField.type.options.list.filter((list) => list.value);\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\" ? type : null;\n}\nfunction defineSchema(definition) {\n  return definition;\n}\nfunction compileSchemaDefinition(definition) {\n  const blockObjects = definition?.blockObjects?.map((blockObject) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.defineType)({\n    type: \"object\",\n    // Very naive way to work around `SanitySchema.compile` adding default\n    // fields to objects with the name `image`\n    name: blockObject.name === \"image\" ? \"tmp-image\" : blockObject.name,\n    title: blockObject.title,\n    icon: blockObject.icon,\n    fields: []\n  })) ?? [], inlineObjects = definition?.inlineObjects?.map((inlineObject) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.defineType)({\n    type: \"object\",\n    name: inlineObject.name,\n    title: inlineObject.title,\n    icon: inlineObject.icon,\n    fields: []\n  })) ?? [], portableTextSchema = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.defineField)({\n    type: \"array\",\n    name: \"portable-text\",\n    of: [...blockObjects.map((blockObject) => ({\n      type: blockObject.name\n    })), {\n      type: \"block\",\n      name: \"block\",\n      of: inlineObjects.map((inlineObject) => ({\n        type: inlineObject.name\n      })),\n      marks: {\n        decorators: definition?.decorators?.map((decorator) => ({\n          title: decorator.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(decorator.name),\n          value: decorator.name,\n          icon: decorator.icon\n        })) ?? [],\n        annotations: definition?.annotations?.map((annotation) => ({\n          name: annotation.name,\n          type: \"object\",\n          title: annotation.title,\n          icon: annotation.icon\n        })) ?? []\n      },\n      lists: definition?.lists?.map((list) => ({\n        value: list.name,\n        title: list.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(list.name),\n        icon: list.icon\n      })) ?? [],\n      styles: definition?.styles?.map((style) => ({\n        value: style.name,\n        title: style.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(style.name),\n        icon: style.icon\n      })) ?? []\n    }]\n  }), schema = _sanity_schema__WEBPACK_IMPORTED_MODULE_16__.Schema.compile({\n    types: [portableTextSchema, ...blockObjects, ...inlineObjects]\n  }).get(\"portable-text\"), pteSchema = getPortableTextMemberSchemaTypes(schema);\n  return {\n    ...pteSchema,\n    blockObjects: pteSchema.blockObjects.map((blockObject) => blockObject.name === \"tmp-image\" ? {\n      ...blockObject,\n      name: \"image\",\n      type: {\n        ...blockObject.type,\n        name: \"image\"\n      }\n    } : blockObject)\n  };\n}\nconst rootName = \"sanity-pte:\";\ndebug__WEBPACK_IMPORTED_MODULE_5__(rootName);\nfunction debugWithName(name) {\n  const namespace = `${rootName}${name}`;\n  return debug__WEBPACK_IMPORTED_MODULE_5__ && debug__WEBPACK_IMPORTED_MODULE_5__.enabled(namespace) ? debug__WEBPACK_IMPORTED_MODULE_5__(namespace) : debug__WEBPACK_IMPORTED_MODULE_5__(rootName);\n}\nfunction createKeyedPath(point, value, types) {\n  const blockPath = [point.path[0]];\n  if (!value)\n    return null;\n  const block = value[blockPath[0]];\n  if (!block)\n    return null;\n  const keyedBlockPath = [{\n    _key: block._key\n  }];\n  if (block._type !== types.block.name)\n    return keyedBlockPath;\n  let keyedChildPath;\n  const childPath = point.path.slice(0, 2), child = Array.isArray(block.children) && block.children[childPath[1]];\n  return child && (keyedChildPath = [\"children\", {\n    _key: child._key\n  }]), keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath;\n}\nfunction createArrayedPath(point, editor) {\n  if (!editor)\n    return [];\n  const [block, blockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n    at: [],\n    match: (n) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isKeySegment)(point.path[0]) && n._key === point.path[0]._key\n  }))[0] || [void 0, void 0];\n  if (!block || !slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(block))\n    return [];\n  if (editor.isVoid(block))\n    return [blockPath[0], 0];\n  const childPath = [point.path[2]], childIndex = block.children.findIndex((child) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__([{\n    _key: child._key\n  }], childPath));\n  if (childIndex >= 0 && block.children[childIndex]) {\n    const child = block.children[childIndex];\n    return slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(child) && editor.isVoid(child) ? blockPath.concat(childIndex).concat(0) : blockPath.concat(childIndex);\n  }\n  return blockPath;\n}\nfunction toPortableTextRange(value, range, types) {\n  if (!range)\n    return null;\n  let anchor = null, focus = null;\n  const anchorPath = range.anchor && createKeyedPath(range.anchor, value, types);\n  anchorPath && range.anchor && (anchor = {\n    path: anchorPath,\n    offset: range.anchor.offset\n  });\n  const focusPath = range.focus && createKeyedPath(range.focus, value, types);\n  focusPath && range.focus && (focus = {\n    path: focusPath,\n    offset: range.focus.offset\n  });\n  const backward = !!(slate__WEBPACK_IMPORTED_MODULE_17__.Range.isRange(range) && slate__WEBPACK_IMPORTED_MODULE_17__.Range.isBackward(range));\n  return anchor && focus ? {\n    anchor,\n    focus,\n    backward\n  } : null;\n}\nfunction toSlateRange(selection, editor) {\n  if (!selection || !editor)\n    return null;\n  const anchor = {\n    path: createArrayedPath(selection.anchor, editor),\n    offset: selection.anchor.offset\n  }, focus = {\n    path: createArrayedPath(selection.focus, editor),\n    offset: selection.focus.offset\n  };\n  return focus.path.length === 0 || anchor.path.length === 0 ? null : anchor && focus ? {\n    anchor,\n    focus\n  } : null;\n}\nfunction moveRangeByOperation(range, operation) {\n  const anchor = slate__WEBPACK_IMPORTED_MODULE_17__.Point.transform(range.anchor, operation), focus = slate__WEBPACK_IMPORTED_MODULE_17__.Point.transform(range.focus, operation);\n  return anchor === null || focus === null ? null : slate__WEBPACK_IMPORTED_MODULE_17__.Point.equals(anchor, range.anchor) && slate__WEBPACK_IMPORTED_MODULE_17__.Point.equals(focus, range.focus) ? range : {\n    anchor,\n    focus\n  };\n}\nfunction normalizePoint(point, value) {\n  if (!point || !value)\n    return null;\n  const newPath = [];\n  let newOffset = point.offset || 0;\n  const blockKey = typeof point.path[0] == \"object\" && \"_key\" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == \"object\" && \"_key\" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);\n  if (block)\n    newPath.push({\n      _key: block._key\n    });\n  else\n    return null;\n  if (block && point.path[1] === \"children\") {\n    if (!block.children || Array.isArray(block.children) && block.children.length === 0)\n      return null;\n    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);\n    if (child)\n      newPath.push(\"children\"), newPath.push({\n        _key: child._key\n      }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;\n    else\n      return null;\n  }\n  return {\n    path: newPath,\n    offset: newOffset\n  };\n}\nfunction normalizeSelection(selection, value) {\n  if (!selection || !value || value.length === 0)\n    return null;\n  let newAnchor = null, newFocus = null;\n  const {\n    anchor,\n    focus\n  } = selection;\n  return anchor && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n    _key: blk._key\n  }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n    _key: blk._key\n  }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {\n    anchor: newAnchor,\n    focus: newFocus,\n    backward: selection.backward\n  } : null;\n}\nconst VOID_CHILD_KEY = \"void-child\";\nfunction keepObjectEquality(object, keyMap) {\n  const value = keyMap[object._key];\n  return value && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(object, value) ? value : (keyMap[object._key] = object, object);\n}\nfunction toSlateValue(value, {\n  schemaTypes\n}, keyMap = {}) {\n  return value && Array.isArray(value) ? value.map((block) => {\n    const {\n      _type,\n      _key,\n      ...rest\n    } = block, voidChildren = [{\n      _key: VOID_CHILD_KEY,\n      _type: \"span\",\n      text: \"\",\n      marks: []\n    }];\n    if (block && block._type === schemaTypes.block.name) {\n      const textBlock = block;\n      let hasInlines = !1;\n      const hasMissingStyle = typeof textBlock.style > \"u\", hasMissingMarkDefs = typeof textBlock.markDefs > \"u\", hasMissingChildren = typeof textBlock.children > \"u\", children = (textBlock.children || []).map((child) => {\n        const {\n          _type: cType,\n          _key: cKey,\n          ...cRest\n        } = child;\n        return cType !== \"span\" ? (hasInlines = !0, keepObjectEquality({\n          _type: cType,\n          _key: cKey,\n          children: voidChildren,\n          value: cRest,\n          __inline: !0\n        }, keyMap)) : child;\n      });\n      return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].value), keepObjectEquality({\n        _type,\n        _key,\n        ...rest,\n        children\n      }, keyMap));\n    }\n    return keepObjectEquality({\n      _type,\n      _key,\n      children: voidChildren,\n      value: rest\n    }, keyMap);\n  }) : [];\n}\nfunction fromSlateValue(value, textBlockType, keyMap = {}) {\n  return value.map((block) => {\n    const {\n      _key,\n      _type\n    } = block;\n    if (!_key || !_type)\n      throw new Error(\"Not a valid block\");\n    if (_type === textBlockType && \"children\" in block && Array.isArray(block.children) && _key) {\n      let hasInlines = !1;\n      const children = block.children.map((child) => {\n        const {\n          _type: _cType\n        } = child;\n        if (\"value\" in child && _cType !== \"span\") {\n          hasInlines = !0;\n          const {\n            value: v,\n            _key: k,\n            _type: t,\n            __inline: _i,\n            children: _c,\n            ...rest\n          } = child;\n          return keepObjectEquality({\n            ...rest,\n            ...v,\n            _key: k,\n            _type: t\n          }, keyMap);\n        }\n        return child;\n      });\n      return hasInlines ? keepObjectEquality({\n        ...block,\n        children,\n        _key,\n        _type\n      }, keyMap) : block;\n    }\n    const blockValue = \"value\" in block && block.value;\n    return keepObjectEquality({\n      _key,\n      _type,\n      ...typeof blockValue == \"object\" ? blockValue : {}\n    }, keyMap);\n  });\n}\nfunction isEqualToEmptyEditor(children, schemaTypes) {\n  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && \"style\" in children[0] && children[0].style === schemaTypes.styles[0].value && !(\"listItem\" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(children[0].children[0]) && children[0].children[0]._type === \"span\" && !children[0].children[0].marks?.join(\"\") && children[0].children[0].text === \"\";\n}\nconst IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), IS_PROCESSING_LOCAL_CHANGES = /* @__PURE__ */ new WeakMap(), IS_DRAGGING = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_ELEMENT = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_ELEMENT_TARGET = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_TARGET_POSITION = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), DefaultObject = (props) => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(4);\n  let t0;\n  $[0] !== props.value ? (t0 = JSON.stringify(props.value, null, 2), $[0] = props.value, $[1] = t0) : t0 = $[1];\n  let t1;\n  return $[2] !== t0 ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"pre\", { children: t0 }) }), $[2] = t0, $[3] = t1) : t1 = $[3], t1;\n};\nDefaultObject.displayName = \"DefaultObject\";\nconst DefaultBlockObject = styled_components__WEBPACK_IMPORTED_MODULE_18__.styled.div`\n  user-select: none;\n  border: ${(props) => props.selected ? \"1px solid blue\" : \"1px solid transparent\"};\n`;\nstyled_components__WEBPACK_IMPORTED_MODULE_18__.styled.span`\n  background: #999;\n  border: ${(props) => props.selected ? \"1px solid blue\" : \"1px solid transparent\"};\n`;\nconst DefaultListItem = styled_components__WEBPACK_IMPORTED_MODULE_18__.styled.div`\n  &.pt-list-item {\n    width: fit-content;\n    position: relative;\n    display: block;\n\n    /* Important 'transform' in order to force refresh the ::before and ::after rules\n      in Webkit: https://stackoverflow.com/a/21947628/831480\n    */\n    transform: translateZ(0);\n    margin-left: ${(props) => getLeftPositionForListLevel(props.listLevel)};\n  }\n  &.pt-list-item > .pt-list-item-inner {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    &:before {\n      justify-content: flex-start;\n      vertical-align: top;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner:before {\n      content: '${(props) => getContentForListLevelAndStyle(props.listLevel, props.listStyle)}';\n      font-size: 0.4375rem; /* 7px */\n      line-height: 1.5rem; /* Same as body text */\n      /* Optical alignment */\n      position: relative;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner {\n    &:before {\n      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */\n    }\n  }\n  &.pt-list-item-number {\n    counter-increment: ${(props) => getCounterIncrementForListLevel(props.listLevel)};\n    counter-reset: ${(props) => getCounterResetForListLevel(props.listLevel)};\n  }\n  & + :not(.pt-list-item-number) {\n    counter-reset: listItemNumber;\n  }\n  &.pt-list-item-number > .pt-list-item-inner:before {\n    content: ${(props) => getCounterContentForListLevel(props.listLevel)};\n    min-width: 1.5rem; /* Make sure space between number and text never shrinks */\n    /* Optical alignment */\n    position: relative;\n    top: 1px;\n  }\n`, DefaultListItemInner = styled_components__WEBPACK_IMPORTED_MODULE_18__.styled.div``;\nfunction getLeftPositionForListLevel(level) {\n  switch (Number(level)) {\n    case 1:\n      return \"1.5em\";\n    case 2:\n      return \"3em\";\n    case 3:\n      return \"4.5em\";\n    case 4:\n      return \"6em\";\n    case 5:\n      return \"7.5em\";\n    case 6:\n      return \"9em\";\n    case 7:\n      return \"10.5em\";\n    case 8:\n      return \"12em\";\n    case 9:\n      return \"13.5em\";\n    case 10:\n      return \"15em\";\n    default:\n      return \"0em\";\n  }\n}\nconst bullets = [\"\\u25CF\", \"\\u25CB\", \"\\u25A0\"];\nfunction getContentForListLevelAndStyle(level, style) {\n  const normalizedLevel = (level - 1) % 3;\n  return style === \"bullet\" ? bullets[normalizedLevel] : \"*\";\n}\nfunction getCounterIncrementForListLevel(level) {\n  switch (level) {\n    case 1:\n      return \"listItemNumber\";\n    case 2:\n      return \"listItemAlpha\";\n    case 3:\n      return \"listItemRoman\";\n    case 4:\n      return \"listItemNumberNext\";\n    case 5:\n      return \"listItemLetterNext\";\n    case 6:\n      return \"listItemRomanNext\";\n    case 7:\n      return \"listItemNumberNextNext\";\n    case 8:\n      return \"listItemAlphaNextNext\";\n    case 9:\n      return \"listItemRomanNextNext\";\n    default:\n      return \"listItemNumberNextNextNext\";\n  }\n}\nfunction getCounterResetForListLevel(level) {\n  switch (level) {\n    case 1:\n      return \"listItemAlpha\";\n    case 2:\n      return \"listItemRoman\";\n    case 3:\n      return \"listItemNumberNext\";\n    case 4:\n      return \"listItemLetterNext\";\n    case 5:\n      return \"listItemRomanNext\";\n    case 6:\n      return \"listItemNumberNextNext\";\n    case 7:\n      return \"listItemAlphaNextNext\";\n    case 8:\n      return \"listItemRomanNextNext\";\n    case 9:\n      return \"listItemNumberNextNextNext\";\n    default:\n      return \"listItemNumberNextNextNext\";\n  }\n}\nfunction getCounterContentForListLevel(level) {\n  switch (level) {\n    case 1:\n      return \"counter(listItemNumber) '. '\";\n    case 2:\n      return \"counter(listItemAlpha, lower-alpha) '. '\";\n    case 3:\n      return \"counter(listItemRoman, lower-roman) '. '\";\n    case 4:\n      return \"counter(listItemNumberNext) '. '\";\n    case 5:\n      return \"counter(listItemLetterNext, lower-alpha) '. '\";\n    case 6:\n      return \"counter(listItemRomanNext, lower-roman) '. '\";\n    case 7:\n      return \"counter(listItemNumberNextNext) '. '\";\n    case 8:\n      return \"counter(listItemAlphaNextNext, lower-alpha) '. '\";\n    case 9:\n      return \"counter(listItemRomanNextNext, lower-roman) '. '\";\n    default:\n      return \"counter(listItemNumberNextNextNext) '. '\";\n  }\n}\nconst debug$l = debugWithName(\"components:DraggableBlock\"), DraggableBlock = (t0) => {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(51), {\n    children,\n    element,\n    readOnly,\n    blockRef\n  } = t0, editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_19__.useSlateStatic)(), dragGhostRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(), [isDragOver, setIsDragOver] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1);\n  let t1, t2;\n  $[0] !== editor || $[1] !== element ? (t2 = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.isVoid(editor, element), $[0] = editor, $[1] = element, $[2] = t2) : t2 = $[2], t1 = t2;\n  const isVoid = t1;\n  let t3, t4;\n  $[3] !== editor || $[4] !== element ? (t4 = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.isInline(editor, element), $[3] = editor, $[4] = element, $[5] = t4) : t4 = $[5], t3 = t4;\n  const isInline = t3, [blockElement, setBlockElement] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(null);\n  let t5, t6;\n  $[6] !== blockRef || $[7] !== editor || $[8] !== element ? (t5 = () => setBlockElement(blockRef ? blockRef.current : slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.toDOMNode(editor, element)), t6 = [editor, element, blockRef], $[6] = blockRef, $[7] = editor, $[8] = element, $[9] = t5, $[10] = t6) : (t5 = $[9], t6 = $[10]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t5, t6);\n  let t7;\n  $[11] !== blockElement || $[12] !== editor || $[13] !== element ? (t7 = (event) => {\n    const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);\n    if (!isMyDragOver || !blockElement)\n      return;\n    event.preventDefault(), event.dataTransfer.dropEffect = \"move\", IS_DRAGGING_ELEMENT_TARGET.set(editor, element);\n    const elementRect = blockElement.getBoundingClientRect(), offset = elementRect.top, height = elementRect.height, Y = event.pageY, loc = Math.abs(offset - Y);\n    if (element === editor.children[0] || (loc < height / 2 ? IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, \"top\") : IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, \"bottom\")), isMyDragOver === element) {\n      event.dataTransfer.dropEffect = \"none\";\n      return;\n    }\n    setIsDragOver(!0);\n  }, $[11] = blockElement, $[12] = editor, $[13] = element, $[14] = t7) : t7 = $[14];\n  const handleDragOver = t7;\n  let t8;\n  $[15] === Symbol.for(\"react.memo_cache_sentinel\") ? (t8 = () => {\n    setIsDragOver(!1);\n  }, $[15] = t8) : t8 = $[15];\n  const handleDragLeave = t8;\n  let t9;\n  $[16] !== editor || $[17] !== element ? (t9 = (event_0) => {\n    const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);\n    if (targetBlock) {\n      IS_DRAGGING.set(editor, !1), event_0.preventDefault(), event_0.stopPropagation(), IS_DRAGGING_ELEMENT_TARGET.delete(editor), dragGhostRef.current && (debug$l(\"Removing drag ghost\"), document.body.removeChild(dragGhostRef.current));\n      const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);\n      IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);\n      let targetPath = slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.findPath(editor, targetBlock);\n      const myPath = slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.findPath(editor, element), isBefore = slate__WEBPACK_IMPORTED_MODULE_17__.Path.isBefore(myPath, targetPath);\n      if (dragPosition === \"bottom\" && !isBefore) {\n        if (targetPath[0] >= editor.children.length - 1) {\n          debug$l(\"target is already at the bottom, not moving\");\n          return;\n        }\n        const originalPath = targetPath;\n        targetPath = slate__WEBPACK_IMPORTED_MODULE_17__.Path.next(targetPath), debug$l(`Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(targetPath)}`);\n      }\n      if (dragPosition === \"top\" && isBefore && targetPath[0] !== editor.children.length - 1) {\n        const originalPath_0 = targetPath;\n        targetPath = slate__WEBPACK_IMPORTED_MODULE_17__.Path.previous(targetPath), debug$l(`Adjusting targetPath from ${JSON.stringify(originalPath_0)} to ${JSON.stringify(targetPath)}`);\n      }\n      if (slate__WEBPACK_IMPORTED_MODULE_17__.Path.equals(targetPath, myPath)) {\n        event_0.preventDefault(), debug$l(\"targetPath and myPath is the same, not moving\");\n        return;\n      }\n      debug$l(`Moving element ${element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(targetPath)} (${dragPosition})`), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.moveNodes(editor, {\n        at: myPath,\n        to: targetPath\n      }), editor.onChange();\n      return;\n    }\n    debug$l(\"No target element, not doing anything\");\n  }, $[16] = editor, $[17] = element, $[18] = t9) : t9 = $[18];\n  const handleDragEnd = t9;\n  let t10;\n  $[19] !== editor || $[20] !== element ? (t10 = (event_1) => {\n    IS_DRAGGING_BLOCK_ELEMENT.get(editor) && (debug$l(\"On drop (prevented)\", element), event_1.preventDefault(), event_1.stopPropagation(), setIsDragOver(!1));\n  }, $[19] = editor, $[20] = element, $[21] = t10) : t10 = $[21];\n  const handleDrop = t10;\n  let t11;\n  $[22] !== editor || $[23] !== element || $[24] !== isVoid ? (t11 = (event_2) => {\n    if (!isVoid) {\n      IS_DRAGGING_BLOCK_ELEMENT.delete(editor);\n      return;\n    }\n    IS_DRAGGING.set(editor, !0), IS_DRAGGING_BLOCK_ELEMENT.set(editor, element), event_2.stopPropagation();\n    const target = event_2.target;\n    target instanceof HTMLElement && (target.style.opacity = \"1\");\n  }, $[22] = editor, $[23] = element, $[24] = isVoid, $[25] = t11) : t11 = $[25];\n  const handleDrag = t11;\n  let t12;\n  $[26] !== blockElement || $[27] !== editor || $[28] !== handleDrag || $[29] !== isInline || $[30] !== isVoid ? (t12 = (event_3) => {\n    if (!isVoid || isInline) {\n      debug$l(\"Not dragging block\"), IS_DRAGGING_BLOCK_ELEMENT.delete(editor), IS_DRAGGING.set(editor, !1);\n      return;\n    }\n    if (debug$l(\"Drag start\"), IS_DRAGGING.set(editor, !0), event_3.dataTransfer && (event_3.dataTransfer.setData(\"application/portable-text\", \"something\"), event_3.dataTransfer.effectAllowed = \"move\"), blockElement && blockElement instanceof HTMLElement) {\n      let dragGhost = blockElement.cloneNode(!0);\n      const customGhost = dragGhost.querySelector(\"[data-pt-drag-ghost-element]\");\n      if (customGhost && (dragGhost = customGhost), dragGhost.setAttribute(\"data-dragged\", \"\"), document.body) {\n        dragGhostRef.current = dragGhost, dragGhost.style.position = \"absolute\", dragGhost.style.left = \"-99999px\", dragGhost.style.boxSizing = \"border-box\", document.body.appendChild(dragGhost);\n        const rect = blockElement.getBoundingClientRect(), x = event_3.clientX - rect.left, y = event_3.clientY - rect.top;\n        dragGhost.style.width = `${rect.width}px`, dragGhost.style.height = `${rect.height}px`, event_3.dataTransfer.setDragImage(dragGhost, x, y);\n      }\n    }\n    handleDrag(event_3);\n  }, $[26] = blockElement, $[27] = editor, $[28] = handleDrag, $[29] = isInline, $[30] = isVoid, $[31] = t12) : t12 = $[31];\n  const handleDragStart = t12;\n  let t13;\n  $[32] !== editor || $[33] !== isDragOver ? (t13 = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor), $[32] = editor, $[33] = isDragOver, $[34] = t13) : t13 = $[34];\n  const isDraggingOverFirstBlock = t13;\n  let t14;\n  $[35] !== editor || $[36] !== isDragOver ? (t14 = isDragOver && editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor), $[35] = editor, $[36] = isDragOver, $[37] = t14) : t14 = $[37];\n  const isDraggingOverLastBlock = t14, dragPosition_0 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor), isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition_0 === \"top\", isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition_0 === \"bottom\";\n  let t15, t16;\n  $[38] === Symbol.for(\"react.memo_cache_sentinel\") ? (t16 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { className: \"pt-drop-indicator\", style: {\n    position: \"absolute\",\n    width: \"100%\",\n    height: 1,\n    borderBottom: \"1px solid currentColor\",\n    zIndex: 5\n  } }), $[38] = t16) : t16 = $[38], t15 = t16;\n  const dropIndicator = t15;\n  if (readOnly) {\n    let t172;\n    return $[39] !== children ? (t172 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children }), $[39] = children, $[40] = t172) : t172 = $[40], t172;\n  }\n  const t17 = isDraggingOverTop && dropIndicator, t18 = isDraggingOverBottom && dropIndicator;\n  let t19;\n  return $[41] !== children || $[42] !== handleDrag || $[43] !== handleDragEnd || $[44] !== handleDragOver || $[45] !== handleDragStart || $[46] !== handleDrop || $[47] !== isVoid || $[48] !== t17 || $[49] !== t18 ? (t19 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", { draggable: isVoid, onDragStart: handleDragStart, onDrag: handleDrag, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDragEnd: handleDragEnd, onDrop: handleDrop, children: [\n    t17,\n    children,\n    t18\n  ] }), $[41] = children, $[42] = handleDrag, $[43] = handleDragEnd, $[44] = handleDragOver, $[45] = handleDragStart, $[46] = handleDrop, $[47] = isVoid, $[48] = t17, $[49] = t18, $[50] = t19) : t19 = $[50], t19;\n};\nDraggableBlock.displayName = \"DraggableBlock\";\ndebugWithName(\"components:Element\");\nconst EMPTY_ANNOTATIONS = [], inlineBlockStyle = {\n  display: \"inline-block\"\n}, Element = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck\n}) => {\n  const editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_19__.useSlateStatic)(), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_19__.useSelected)(), blockRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), inlineBlockObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), focused = selected && editor.selection && slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed(editor.selection) || !1, value = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0], [editor, element, schemaTypes.block.name]);\n  let renderedBlock = children, className;\n  const blockPath = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => [{\n    _key: element._key\n  }], [element]);\n  if (typeof element._type != \"string\")\n    throw new Error(\"Expected element to have a _type property\");\n  if (typeof element._key != \"string\")\n    throw new Error(\"Expected element to have a _key property\");\n  if (editor.isInline(element)) {\n    const path = slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.findPath(editor, element), [block] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, path, {\n      depth: 1\n    }), schemaType = schemaTypes.inlineObjects.find((_type) => _type.name === element._type);\n    if (!schemaType)\n      throw new Error(\"Could not find type for inline block element\");\n    if (slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(block)) {\n      const elmPath = [{\n        _key: block._key\n      }, \"children\", {\n        _key: element._key\n      }];\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", { ...attributes, children: [\n        children,\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", { draggable: !readOnly, className: \"pt-inline-object\", \"data-testid\": \"pt-inline-object\", ref: inlineBlockObjectRef, style: inlineBlockStyle, contentEditable: !1, children: [\n          renderChild && renderChild({\n            annotations: EMPTY_ANNOTATIONS,\n            // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, { value }),\n            editorElementRef: inlineBlockObjectRef,\n            focused,\n            path: elmPath,\n            schemaType,\n            selected,\n            type: schemaType,\n            value\n          }),\n          !renderChild && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, { value })\n        ] }, element._key)\n      ] });\n    }\n    throw new Error(\"Block not found!\");\n  }\n  if (element._type === schemaTypes.block.name) {\n    className = \"pt-block pt-text-block\";\n    const isListItem = \"listItem\" in element, style = \"style\" in element && element.style || \"normal\";\n    className = `pt-block pt-text-block pt-text-block-style-${style}`;\n    const blockStyleType = schemaTypes.styles.find((item) => item.value === style);\n    renderStyle && blockStyleType && (renderedBlock = renderStyle({\n      block: element,\n      children,\n      focused,\n      selected,\n      value: style,\n      path: blockPath,\n      schemaType: blockStyleType,\n      editorElementRef: blockRef\n    }));\n    let level;\n    if (isListItem && (typeof element.level == \"number\" && (level = element.level), className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`), editor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find((item_0) => item_0.value === element.listItem);\n      renderListItem && listType ? renderedBlock = renderListItem({\n        block: value,\n        children: renderedBlock,\n        focused,\n        selected,\n        value: element.listItem,\n        path: blockPath,\n        schemaType: listType,\n        level: value.level || 1,\n        editorElementRef: blockRef\n      }) : renderedBlock = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultListItem, { listStyle: value.listItem || schemaTypes.lists[0].value, listLevel: value.level || 1, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultListItemInner, { children: renderedBlock }) });\n    }\n    const renderProps = Object.defineProperty({\n      children: renderedBlock,\n      editorElementRef: blockRef,\n      focused,\n      level,\n      listItem: isListItem ? element.listItem : void 0,\n      path: blockPath,\n      selected,\n      style,\n      schemaType: schemaTypes.block,\n      value\n    }, \"type\", {\n      enumerable: !1,\n      get() {\n        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.block;\n      }\n    }), propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ...attributes, className, spellCheck, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DraggableBlock, { element, readOnly, blockRef, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: blockRef, children: propsOrDefaultRendered }) }) }, element._key);\n  }\n  const schemaType_0 = schemaTypes.blockObjects.find((_type_0) => _type_0.name === element._type);\n  if (!schemaType_0)\n    throw new Error(`Could not find schema type for block element of _type ${element._type}`);\n  className = \"pt-block pt-object-block\";\n  const block_0 = fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n  let renderedBlockFromProps;\n  if (renderBlock) {\n    const _props = Object.defineProperty({\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, { value }),\n      editorElementRef: blockRef,\n      focused,\n      path: blockPath,\n      schemaType: schemaType_0,\n      selected,\n      value: block_0\n    }, \"type\", {\n      enumerable: !1,\n      get() {\n        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType_0;\n      }\n    });\n    renderedBlockFromProps = renderBlock(_props);\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", { ...attributes, className, children: [\n    children,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(DraggableBlock, { element, readOnly, blockRef, children: [\n      renderedBlockFromProps && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: blockRef, contentEditable: !1, children: renderedBlockFromProps }),\n      !renderedBlockFromProps && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultBlockObject, { selected, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, { value }) })\n    ] })\n  ] }, element._key);\n};\nElement.displayName = \"Element\";\nconst PortableTextEditorContext = (0,react__WEBPACK_IMPORTED_MODULE_4__.createContext)(null), usePortableTextEditor = () => {\n  const editor = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(PortableTextEditorContext);\n  if (!editor)\n    throw new Error(\"The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.\");\n  return editor;\n};\nfunction DefaultAnnotation(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6);\n  let t0;\n  $[0] !== props.annotation ? (t0 = () => alert(JSON.stringify(props.annotation)), $[0] = props.annotation, $[1] = t0) : t0 = $[1];\n  const handleClick = t0;\n  let t1;\n  $[2] === Symbol.for(\"react.memo_cache_sentinel\") ? (t1 = {\n    color: \"blue\"\n  }, $[2] = t1) : t1 = $[2];\n  let t2;\n  return $[3] !== handleClick || $[4] !== props.children ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { style: t1, onClick: handleClick, children: props.children }), $[3] = handleClick, $[4] = props.children, $[5] = t2) : t2 = $[5], t2;\n}\nDefaultAnnotation.displayName = \"DefaultAnnotation\";\nfunction compileType(rawType) {\n  return _sanity_schema__WEBPACK_IMPORTED_MODULE_16__.Schema.compile({\n    name: \"blockTypeSchema\",\n    types: [rawType]\n  }).get(rawType.name);\n}\nfunction validateValue(value, types, keyGenerator) {\n  let resolution = null, valid = !0;\n  const validChildTypes = [types.span.name, ...types.inlineObjects.map((t) => t.name)], validBlockTypes = [types.block.name, ...types.blockObjects.map((t) => t.name)];\n  return value === void 0 ? {\n    valid: !0,\n    resolution: null,\n    value\n  } : !Array.isArray(value) || value.length === 0 ? {\n    valid: !1,\n    resolution: {\n      patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([])],\n      description: \"Editor value must be an array of Portable Text blocks, or undefined.\",\n      action: \"Unset the value\",\n      item: value,\n      i18n: {\n        description: \"inputs.portable-text.invalid-value.not-an-array.description\",\n        action: \"inputs.portable-text.invalid-value.not-an-array.action\"\n      }\n    },\n    value\n  } : (value.some((blk, index) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_11__(blk))\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([index])],\n        description: `Block must be an object, got ${String(blk)}`,\n        action: \"Unset invalid item\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.not-an-object.description\",\n          action: \"inputs.portable-text.invalid-value.not-an-object.action\",\n          values: {\n            index\n          }\n        }\n      }, !0;\n    if (!blk._key || typeof blk._key != \"string\")\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n          ...blk,\n          _key: keyGenerator()\n        }, [index])],\n        description: `Block at index ${index} is missing required _key.`,\n        action: \"Set the block with a random _key value\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-key.description\",\n          action: \"inputs.portable-text.invalid-value.missing-key.action\",\n          values: {\n            index\n          }\n        }\n      }, !0;\n    if (!blk._type || !validBlockTypes.includes(blk._type)) {\n      if (blk._type === \"block\") {\n        const currentBlockTypeName = types.block.name;\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n            ...blk,\n            _type: currentBlockTypeName\n          }, [{\n            _key: blk._key\n          }])],\n          description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,\n          action: `Use type '${currentBlockTypeName}'`,\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.incorrect-block-type.description\",\n            action: \"inputs.portable-text.invalid-value.incorrect-block-type.action\",\n            values: {\n              key: blk._key,\n              expectedTypeName: currentBlockTypeName\n            }\n          }\n        }, !0;\n      }\n      return !blk._type && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)({\n        ...blk,\n        _type: types.block.name\n      }) ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n          ...blk,\n          _type: types.block.name\n        }, [{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,\n        action: `Use type '${types.block.name}'`,\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-block-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-block-type.action\",\n          values: {\n            key: blk._key,\n            expectedTypeName: types.block.name\n          }\n        }\n      }, !0) : blk._type ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.disallowed-type.description\",\n          action: \"inputs.portable-text.invalid-value.disallowed-type.action\",\n          values: {\n            key: blk._key,\n            typeName: blk._type\n          }\n        }\n      }, !0) : (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n          _key: blk._key\n        }])],\n        description: `Block with _key '${blk._key}' is missing an _type property`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-type.action\",\n          values: {\n            key: blk._key\n          }\n        }\n      }, !0);\n    }\n    if (blk._type === types.block.name) {\n      const textBlock = blk;\n      if (textBlock.children && !Array.isArray(textBlock.children))\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n            children: []\n          }, [{\n            _key: textBlock._key\n          }])],\n          description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,\n          action: \"Reset the children property\",\n          item: textBlock,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-or-invalid-children.description\",\n            action: \"inputs.portable-text.invalid-value.missing-or-invalid-children.action\",\n            values: {\n              key: textBlock._key\n            }\n          }\n        }, !0;\n      if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {\n        const newSpan = {\n          _type: types.span.name,\n          _key: keyGenerator(),\n          text: \"\",\n          marks: []\n        };\n        return resolution = {\n          autoResolve: !0,\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.setIfMissing)([], [{\n            _key: blk._key\n          }, \"children\"]), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([newSpan], \"after\", [{\n            _key: blk._key\n          }, \"children\", 0])],\n          description: `Children for text block with _key '${blk._key}' is empty.`,\n          action: \"Insert an empty text\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.empty-children.description\",\n            action: \"inputs.portable-text.invalid-value.empty-children.action\",\n            values: {\n              key: blk._key\n            }\n          }\n        }, !0;\n      }\n      const allUsedMarks = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__(textBlock.children.filter((cld) => cld._type === types.span.name).map((cld) => cld.marks || [])));\n      if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {\n        const unusedMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__(blk.markDefs.map((def) => def._key).filter((key) => !allUsedMarks.includes(key)));\n        if (unusedMarkDefs.length > 0)\n          return resolution = {\n            autoResolve: !0,\n            patches: unusedMarkDefs.map((markDefKey) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n              _key: blk._key\n            }, \"markDefs\", {\n              _key: markDefKey\n            }])),\n            description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(\", \")}.`,\n            action: \"Remove unused mark definition item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-mark-defs.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-mark-defs.action\",\n              values: {\n                key: blk._key,\n                unusedMarkDefs: unusedMarkDefs.map((m) => m.toString())\n              }\n            }\n          }, !0;\n      }\n      const orphanedMarks = allUsedMarks.filter((mark) => !types.decorators.map((dec) => dec.value).includes(mark)).filter((mark) => textBlock.markDefs === void 0 || !textBlock.markDefs.find((def) => def._key === mark));\n      if (orphanedMarks.length > 0) {\n        const spanChildren = textBlock.children.filter((cld) => cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark)));\n        if (spanChildren) {\n          const orphaned = orphanedMarks.join(\", \");\n          return resolution = {\n            autoResolve: !0,\n            patches: spanChildren.map((child) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)((child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)), [{\n              _key: blk._key\n            }, \"children\", {\n              _key: child._key\n            }, \"marks\"])),\n            description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,\n            action: \"Remove invalid marks\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-marks.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-marks.action\",\n              values: {\n                key: blk._key,\n                orphanedMarks: orphanedMarks.map((m) => m.toString())\n              }\n            }\n          }, !0;\n        }\n      }\n      textBlock.children.some((child, cIndex) => {\n        if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_11__(child))\n          return resolution = {\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,\n            action: \"Remove the item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.non-object-child.description\",\n              action: \"inputs.portable-text.invalid-value.non-object-child.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        if (!child._key || typeof child._key != \"string\") {\n          const newChild = {\n            ...child,\n            _key: keyGenerator()\n          };\n          return resolution = {\n            autoResolve: !0,\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(newChild, [{\n              _key: blk._key\n            }, \"children\", cIndex])],\n            description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,\n            action: \"Set a new random _key on the object\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.missing-child-key.description\",\n              action: \"inputs.portable-text.invalid-value.missing-child-key.action\",\n              values: {\n                key: blk._key,\n                index: cIndex\n              }\n            }\n          }, !0;\n        }\n        return child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != \"string\" ? (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n            ...child,\n            text: \"\"\n          }, [{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,\n          action: \"Write an empty text property to the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.invalid-span-text.description\",\n            action: \"inputs.portable-text.invalid-value.invalid-span-text.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0) : !1 : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.disallowed-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.disallowed-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key,\n              childType: child._type\n            }\n          }\n        }, !0) : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n            _key: blk._key\n          }, \"children\", {\n            _key: child._key\n          }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.missing-child-type.action\",\n            values: {\n              key: blk._key,\n              childKey: child._key\n            }\n          }\n        }, !0);\n      }) && (valid = !1);\n    }\n    return !1;\n  }) && (valid = !1), {\n    valid,\n    resolution,\n    value\n  });\n}\nfunction withRemoteChanges(editor, fn) {\n  const prev = isChangingRemotely(editor) || !1;\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);\n}\nfunction isChangingRemotely(editor) {\n  return IS_PROCESSING_REMOTE_CHANGES.get(editor);\n}\nfunction isChangingLocally(editor) {\n  return IS_PROCESSING_LOCAL_CHANGES.get(editor);\n}\nconst PATCHING = /* @__PURE__ */ new WeakMap();\nfunction withoutPatching(editor, fn) {\n  const prev = isPatching(editor);\n  PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);\n}\nfunction isPatching(editor) {\n  return PATCHING.get(editor);\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0)\n    return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2)\n    return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1)\n      return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two)\n      return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; )\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_EQUAL:\n        countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation\");\n    }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; )\n    diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)\n    args[_key] = arguments[_key];\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs) {\n  let editCost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++)\n    v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); )\n        x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length)\n        k1end += 2;\n      else if (y1 > text2Length)\n        k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); )\n        x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length)\n        k2end += 2;\n      else if (y2 > text2Length)\n        k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {\n    checkLines: !1,\n    deadline\n  }), diffsb = doDiff(text1b, text2b, {\n    checkLines: !1,\n    deadline\n  });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2) {\n  if ((arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1) <= 0)\n    return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length)\n    return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2)\n    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2)\n      return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch)\n    throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [bestLongTextA || \"\", bestLongTextB || \"\", bestShortTextA || \"\", bestShortTextB || \"\", bestCommon || \"\"] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++)\n      text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return {\n    chars1,\n    chars2,\n    lineArray\n  };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--)\n            diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1)\n    return [[DIFF_INSERT, text2]];\n  if (!text2)\n    return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1)\n    return diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1)\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null)\n    throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2)\n    return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return {\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1),\n    ...opts\n  };\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText2, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText2, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++)\n    diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return {\n    ...DEFAULT_OPTIONS,\n    ...options\n  };\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc) {\n  let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n  if (pattern.length > MAX_BITS$1)\n    throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; )\n      getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold)\n          if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc)\n            start = Math.max(1, 2 * loc - bestLoc);\n          else\n            break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold)\n      break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation) {\n  if (text === null || pattern === null || searchLocation === null)\n    throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern)\n    return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern)\n      return loc;\n  } else return -1;\n  return bitap(text, pattern, loc);\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\")\n      throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base) {\n  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\")\n        return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target)\n      throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches)\n    adjusted.push({\n      diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n      start1: advanceTo(patch.start1),\n      start2: advanceTo(patch.start2),\n      utf8Start1: patch.utf8Start1,\n      utf8Start2: patch.utf8Start2,\n      length1: patch.length1,\n      length2: patch.length2,\n      utf8Length1: patch.utf8Length1,\n      utf8Length2: patch.utf8Length2\n    });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, loc) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > loc)); x++)\n    lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (loc - lastChars1);\n}\nfunction addPadding(patches) {\n  const paddingLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++)\n    nullPadding += String.fromCharCode(x);\n  for (const p of patches)\n    p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL)\n    diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL)\n    diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction splitMax(patches) {\n  let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize)\n      continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText) {\n  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  if (typeof patches == \"string\")\n    throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0)\n    return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1)\n      results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2)\n        text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, {\n          checkLines: !1\n        });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold)\n          results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline)\n    return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m)\n      throw new Error(\"Invalid patch string: \".concat(lines[textPointer]));\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\")\n        break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch {\n        throw new Error(\"Illegal escape in parse: \".concat(currentLine));\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\")\n        patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\")\n        patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \")\n        patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else\n        throw new Error('Invalid patch mode \"'.concat(sign, '\" in: ').concat(line));\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nconst IS_UDOING = /* @__PURE__ */ new WeakMap(), IS_REDOING = /* @__PURE__ */ new WeakMap();\nfunction withUndoing(editor, fn) {\n  const prev = isUndoing(editor);\n  IS_UDOING.set(editor, !0), fn(), IS_UDOING.set(editor, prev);\n}\nfunction isUndoing(editor) {\n  return IS_UDOING.get(editor) ?? !1;\n}\nfunction setIsUndoing(editor, isUndoing2) {\n  IS_UDOING.set(editor, isUndoing2);\n}\nfunction withRedoing(editor, fn) {\n  const prev = isRedoing(editor);\n  IS_REDOING.set(editor, !0), fn(), IS_REDOING.set(editor, prev);\n}\nfunction isRedoing(editor) {\n  return IS_REDOING.get(editor) ?? !1;\n}\nfunction setIsRedoing(editor, isRedoing2) {\n  IS_REDOING.set(editor, isRedoing2);\n}\nconst debug$k = debugWithName(\"plugin:withUndoRedo\"), debugVerbose$4 = debug$k.enabled && !1, SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor) => {\n  const state = SAVING.get(editor);\n  return state === void 0 ? !0 : state;\n}, getRemotePatches = (editor) => (REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);\nfunction createWithUndoRedo(options) {\n  const {\n    editorActor,\n    blockSchemaType\n  } = options;\n  return (editor) => {\n    let previousSnapshot = fromSlateValue(editor.children, blockSchemaType.name);\n    const remotePatches = getRemotePatches(editor);\n    options.subscriptions.push(() => {\n      debug$k(\"Subscribing to patches\");\n      const sub = editorActor.on(\"patches\", ({\n        patches,\n        snapshot\n      }) => {\n        let reset = !1;\n        patches.forEach((patch) => {\n          if (!reset && patch.origin !== \"local\" && remotePatches) {\n            if (patch.type === \"unset\" && patch.path.length === 0) {\n              debug$k(\"Someone else cleared the content, resetting undo/redo history\"), editor.history = {\n                undos: [],\n                redos: []\n              }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;\n              return;\n            }\n            remotePatches.push({\n              patch,\n              time: /* @__PURE__ */ new Date(),\n              snapshot,\n              previousSnapshot\n            });\n          }\n        }), previousSnapshot = snapshot;\n      });\n      return () => {\n        debug$k(\"Unsubscribing to patches\"), sub.unsubscribe();\n      };\n    }), editor.history = {\n      undos: [],\n      redos: []\n    };\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (editorActor.getSnapshot().context.readOnly) {\n        apply2(op);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      const {\n        operations,\n        history\n      } = editor, {\n        undos\n      } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor);\n      let merge = !0;\n      if (save) {\n        if (step ? operations.length === 0 && (merge = shouldMerge(op, lastOp) || overwrite) : merge = !1, step && merge)\n          step.operations.push(op);\n        else {\n          const newStep = {\n            operations: [...editor.selection === null ? [] : [createSelectOperation(editor)], op],\n            timestamp: /* @__PURE__ */ new Date()\n          };\n          undos.push(newStep), debug$k(\"Created new undo step\", step);\n        }\n        for (; undos.length > UNDO_STEP_LIMIT; )\n          undos.shift();\n        shouldClear(op) && (history.redos = []);\n      }\n      apply2(op);\n    }, editor.undo = () => {\n      if (editorActor.getSnapshot().context.readOnly)\n        return;\n      const {\n        undos\n      } = editor.history;\n      if (undos.length > 0) {\n        const step = undos[undos.length - 1];\n        if (debug$k(\"Undoing\", step), step.operations.length > 0) {\n          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n          let transformedOperations = step.operations;\n          otherPatches.forEach((item) => {\n            transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n          });\n          const reversedOperations = transformedOperations.map(slate__WEBPACK_IMPORTED_MODULE_17__.Operation.inverse).reverse();\n          try {\n            slate__WEBPACK_IMPORTED_MODULE_17__.Editor.withoutNormalizing(editor, () => {\n              withUndoing(editor, () => {\n                withoutSaving(editor, () => {\n                  reversedOperations.forEach((op) => {\n                    editor.apply(op);\n                  });\n                });\n              });\n            }), editor.normalize(), editor.onChange();\n          } catch (err) {\n            debug$k(\"Could not perform undo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.deselect(editor), editor.history = {\n              undos: [],\n              redos: []\n            }, SAVING.set(editor, !0), setIsUndoing(editor, !1), editor.onChange();\n            return;\n          }\n          editor.history.redos.push(step), editor.history.undos.pop();\n        }\n      }\n    }, editor.redo = () => {\n      if (editorActor.getSnapshot().context.readOnly)\n        return;\n      const {\n        redos\n      } = editor.history;\n      if (redos.length > 0) {\n        const step = redos[redos.length - 1];\n        if (debug$k(\"Redoing\", step), step.operations.length > 0) {\n          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n          let transformedOperations = step.operations;\n          otherPatches.forEach((item) => {\n            transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_10__(transformedOperations.map((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n          });\n          try {\n            slate__WEBPACK_IMPORTED_MODULE_17__.Editor.withoutNormalizing(editor, () => {\n              withRedoing(editor, () => {\n                withoutSaving(editor, () => {\n                  transformedOperations.forEach((op) => {\n                    editor.apply(op);\n                  });\n                });\n              });\n            }), editor.normalize(), editor.onChange();\n          } catch (err) {\n            debug$k(\"Could not perform redo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.deselect(editor), editor.history = {\n              undos: [],\n              redos: []\n            }, SAVING.set(editor, !0), setIsRedoing(editor, !1), editor.onChange();\n            return;\n          }\n          editor.history.undos.push(step), editor.history.redos.pop();\n        }\n      }\n    }, editor;\n  };\n}\nfunction transformOperation(editor, patch, operation, snapshot, previousSnapshot) {\n  debugVerbose$4 && (debug$k(`Adjusting '${operation.type}' operation paths for '${patch.type}' patch`), debug$k(`Operation ${JSON.stringify(operation)}`), debug$k(`Patch ${JSON.stringify(patch)}`));\n  const transformedOperation = {\n    ...operation\n  };\n  if (patch.type === \"insert\" && patch.path.length === 1) {\n    const insertBlockIndex = (snapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n      _key: blk._key\n    }, patch.path[0]));\n    return debug$k(`Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`), [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 1) {\n    const unsetBlockIndex = (previousSnapshot || []).findIndex((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n      _key: blk._key\n    }, patch.path[0]));\n    return \"path\" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$k(\"Skipping transformation that targeted removed block\"), []) : (debugVerbose$4 && (debug$k(`Selection ${JSON.stringify(editor.selection)}`), debug$k(`Adjusting block path (-1) for '${transformedOperation.type}' operation and patch '${patch.type}'`)), [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)]);\n  }\n  if (patch.type === \"unset\" && patch.path.length === 0)\n    return debug$k(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];\n  if (patch.type === \"diffMatchPatch\") {\n    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);\n    return !operationTargetBlock || !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n      _key: operationTargetBlock._key\n    }, patch.path[0]) ? [transformedOperation] : (parse(patch.value).forEach((diffPatch) => {\n      let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;\n      const {\n        diffs\n      } = diffPatch;\n      if (diffs.forEach((diff2, index) => {\n        const [diffType, text] = diff2;\n        diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL) || (changedOffset += text.length));\n      }), transformedOperation.type === \"insert_text\" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"remove_text\" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"set_selection\") {\n        const currentFocus = transformedOperation.properties?.focus ? {\n          ...transformedOperation.properties.focus\n        } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n          ...transformedOperation.properties.anchor\n        } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n          ...transformedOperation.newProperties.focus\n        } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n          ...transformedOperation.newProperties.anchor\n        } : void 0;\n        (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n          point && changedOffset < point.offset && (point.offset += adjustOffsetBy);\n        }), currentFocus && currentAnchor && (transformedOperation.properties = {\n          focus: currentFocus,\n          anchor: currentAnchor\n        }), newFocus && newAnchor && (transformedOperation.newProperties = {\n          focus: newFocus,\n          anchor: newAnchor\n        }));\n      }\n    }), [transformedOperation]);\n  }\n  return [transformedOperation];\n}\nfunction adjustBlockPath(operation, level, blockIndex) {\n  const transformedOperation = {\n    ...operation\n  };\n  if (blockIndex >= 0 && transformedOperation.type !== \"set_selection\" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {\n    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];\n    transformedOperation.path = newPath;\n  }\n  if (transformedOperation.type === \"set_selection\") {\n    const currentFocus = transformedOperation.properties?.focus ? {\n      ...transformedOperation.properties.focus\n    } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n      ...transformedOperation.properties.anchor\n    } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n      ...transformedOperation.newProperties.focus\n    } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n      ...transformedOperation.newProperties.anchor\n    } : void 0;\n    (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n      point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [point.path[0] + level, ...point.path.slice(1)]);\n    }), currentFocus && currentAnchor && (transformedOperation.properties = {\n      focus: currentFocus,\n      anchor: currentAnchor\n    }), newFocus && newAnchor && (transformedOperation.newProperties = {\n      focus: newFocus,\n      anchor: newAnchor\n    }));\n  }\n  return transformedOperation;\n}\nconst shouldMerge = (op, prev) => !!(op.type === \"set_selection\" || prev && op.type === \"insert_text\" && prev.type === \"insert_text\" && op.offset === prev.offset + prev.text.length && slate__WEBPACK_IMPORTED_MODULE_17__.Path.equals(op.path, prev.path) && op.text !== \" \" || prev && op.type === \"remove_text\" && prev.type === \"remove_text\" && op.offset + op.text.length === prev.offset && slate__WEBPACK_IMPORTED_MODULE_17__.Path.equals(op.path, prev.path)), shouldOverwrite = (op, prev) => !!(prev && op.type === \"set_selection\" && prev.type === \"set_selection\"), shouldClear = (op) => op.type !== \"set_selection\";\nfunction withoutSaving(editor, fn) {\n  const prev = isSaving(editor);\n  SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);\n}\nfunction createSelectOperation(editor) {\n  return {\n    type: \"set_selection\",\n    properties: {\n      ...editor.selection\n    },\n    newProperties: {\n      ...editor.selection\n    }\n  };\n}\nfunction findOperationTargetBlock(editor, operation) {\n  let block;\n  return operation.type === \"set_selection\" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : \"path\" in operation && (block = editor.children[operation.path[0]]), block;\n}\nconst debug$j = debugWithName(\"hook:useSyncValue\"), CURRENT_VALUE = /* @__PURE__ */ new WeakMap();\nfunction useSyncValue(props) {\n  const {\n    editorActor,\n    portableTextEditor,\n    readOnly,\n    slateEditor\n  } = props, schemaTypes = editorActor.getSnapshot().context.schema, previousValue = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(), updateValueFunctionRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(), updateFromCurrentValue = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(() => {\n    const currentValue = CURRENT_VALUE.get(portableTextEditor);\n    if (previousValue.current === currentValue) {\n      debug$j(\"Value is the same object as previous, not need to sync\");\n      return;\n    }\n    updateValueFunctionRef.current && currentValue && (debug$j(\"Updating the value debounced\"), updateValueFunctionRef.current(currentValue));\n  }, [portableTextEditor]), updateValueDebounced = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => lodash_debounce_js__WEBPACK_IMPORTED_MODULE_9__(updateFromCurrentValue, 1e3, {\n    trailing: !0,\n    leading: !1\n  }), [updateFromCurrentValue]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => {\n    const updateFunction = (value) => {\n      CURRENT_VALUE.set(portableTextEditor, value);\n      const isProcessingLocalChanges = isChangingLocally(slateEditor), isProcessingRemoteChanges = isChangingRemotely(slateEditor);\n      if (!readOnly) {\n        if (isProcessingLocalChanges) {\n          debug$j(\"Has local changes, not syncing value right now\"), updateValueDebounced();\n          return;\n        }\n        if (isProcessingRemoteChanges) {\n          debug$j(\"Has remote changes, not syncing value right now\"), updateValueDebounced();\n          return;\n        }\n      }\n      let isChanged = !1, isValid = !0;\n      const hadSelection = !!slateEditor.selection;\n      if ((!value || value.length === 0) && (debug$j(\"Value is empty\"), slate__WEBPACK_IMPORTED_MODULE_17__.Editor.withoutNormalizing(slateEditor, () => {\n        withoutSaving(slateEditor, () => {\n          withoutPatching(slateEditor, () => {\n            hadSelection && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.deselect(slateEditor);\n            const childrenLength = slateEditor.children.length;\n            slateEditor.children.forEach((_, index) => {\n              slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(slateEditor, {\n                at: [childrenLength - 1 - index]\n              });\n            }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n              decorators: []\n            }), {\n              at: [0]\n            }), hadSelection && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(slateEditor, [0, 0]);\n          });\n        });\n      }), isChanged = !0), value && value.length > 0) {\n        const slateValueFromProps = toSlateValue(value, {\n          schemaTypes\n        });\n        slate__WEBPACK_IMPORTED_MODULE_17__.Editor.withoutNormalizing(slateEditor, () => {\n          withRemoteChanges(slateEditor, () => {\n            withoutSaving(slateEditor, () => {\n              withoutPatching(slateEditor, () => {\n                const childrenLength_0 = slateEditor.children.length;\n                if (slateValueFromProps.length < childrenLength_0) {\n                  for (let i = childrenLength_0 - 1; i > slateValueFromProps.length - 1; i--)\n                    slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(slateEditor, {\n                      at: [i]\n                    });\n                  isChanged = !0;\n                }\n                slateValueFromProps.forEach((currentBlock, currentBlockIndex) => {\n                  const oldBlock = slateEditor.children[currentBlockIndex];\n                  if (oldBlock && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(currentBlock, oldBlock) && isValid) {\n                    const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n                    !validation.valid && validation.resolution?.autoResolve && validation.resolution?.patches.length > 0 && !readOnly && previousValue.current && previousValue.current !== value && (console.warn(`${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`), validation.resolution.patches.forEach((patch) => {\n                      editorActor.send({\n                        type: \"patch\",\n                        patch\n                      });\n                    })), validation.valid || validation.resolution?.autoResolve ? (oldBlock._key === currentBlock._key ? (debug$j.enabled && debug$j(\"Updating block\", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$j.enabled && debug$j(\"Replacing block\", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), isChanged = !0) : (editorActor.send({\n                      type: \"invalid value\",\n                      resolution: validation.resolution,\n                      value\n                    }), isValid = !1);\n                  }\n                  if (!oldBlock && isValid) {\n                    const validationValue_0 = [value[currentBlockIndex]], validation_0 = validateValue(validationValue_0, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n                    debug$j.enabled && debug$j(\"Validating and inserting new block in the end of the value\", currentBlock), validation_0.valid || validation_0.resolution?.autoResolve ? slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(slateEditor, currentBlock, {\n                      at: [currentBlockIndex]\n                    }) : (debug$j(\"Invalid\", validation_0), editorActor.send({\n                      type: \"invalid value\",\n                      resolution: validation_0.resolution,\n                      value\n                    }), isValid = !1);\n                  }\n                });\n              });\n            });\n          });\n        });\n      }\n      if (!isValid) {\n        debug$j(\"Invalid value, returning\");\n        return;\n      }\n      if (isChanged) {\n        debug$j(\"Server value changed, syncing editor\");\n        try {\n          slateEditor.onChange();\n        } catch (err) {\n          console.error(err), editorActor.send({\n            type: \"invalid value\",\n            resolution: null,\n            value\n          });\n          return;\n        }\n        hadSelection && !slateEditor.selection && (slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(slateEditor, {\n          anchor: {\n            path: [0, 0],\n            offset: 0\n          },\n          focus: {\n            path: [0, 0],\n            offset: 0\n          }\n        }), slateEditor.onChange()), editorActor.send({\n          type: \"value changed\",\n          value\n        });\n      } else\n        debug$j(\"Server value and editor value is equal, no need to sync.\");\n      previousValue.current = value;\n    };\n    return updateValueFunctionRef.current = updateFunction, updateFunction;\n  }, [editorActor, portableTextEditor, readOnly, schemaTypes, slateEditor, updateValueDebounced]);\n}\nfunction _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {\n  const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;\n  selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.deselect(slateEditor), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(slateEditor, {\n    at: [currentBlockIndex]\n  }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.onChange(), selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(slateEditor, currentSelection);\n}\nfunction _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {\n  if (slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {\n    const oldBlockChildrenLength = oldBlock.children.length;\n    currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index) => {\n      const childIndex = oldBlockChildrenLength - 1 - index;\n      childIndex > 0 && (debug$j(\"Removing child\"), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(slateEditor, {\n        at: [currentBlockIndex, childIndex]\n      }));\n    }), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {\n      const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(currentBlockChild, oldBlockChild), isTextChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(currentBlockChild.text, oldBlockChild?.text), path = [currentBlockIndex, currentBlockChildIndex];\n      if (isChildChanged)\n        if (currentBlockChild._key === oldBlockChild?._key) {\n          debug$j(\"Updating changed child\", currentBlockChild, oldBlockChild), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(slateEditor, currentBlockChild, {\n            at: path\n          });\n          const isSpanNode = slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(currentBlockChild) && currentBlockChild._type === \"span\" && slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(oldBlockChild) && oldBlockChild._type === \"span\";\n          isSpanNode && isTextChanged ? (slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.delete(slateEditor, {\n            at: {\n              focus: {\n                path,\n                offset: 0\n              },\n              anchor: {\n                path,\n                offset: oldBlockChild.text.length\n              }\n            }\n          }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertText(slateEditor, currentBlockChild.text, {\n            at: path\n          }), slateEditor.onChange()) : isSpanNode || (debug$j(\"Updating changed inline object child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(slateEditor, {\n            _key: VOID_CHILD_KEY\n          }, {\n            at: [...path, 0],\n            voids: !0\n          }));\n        } else oldBlockChild ? (debug$j(\"Replacing child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(slateEditor, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange()) : oldBlockChild || (debug$j(\"Inserting new child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), slateEditor.onChange());\n    });\n  }\n}\nconst debug$i = debugWithName(\"component:PortableTextEditor:Synchronizer\"), debugVerbose$3 = debug$i.enabled && !1, FLUSH_PATCHES_THROTTLED_MS =  false ? 0 : 1e3;\nfunction Synchronizer(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(26), readOnly = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useSelector)(props.editorActor, _temp), value = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useSelector)(props.editorActor, _temp2), {\n    editorActor,\n    getValue,\n    portableTextEditor,\n    slateEditor\n  } = props;\n  let t0;\n  $[0] === Symbol.for(\"react.memo_cache_sentinel\") ? (t0 = [], $[0] = t0) : t0 = $[0];\n  const pendingPatches = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(t0);\n  let t1;\n  $[1] !== editorActor || $[2] !== portableTextEditor || $[3] !== readOnly || $[4] !== slateEditor ? (t1 = {\n    editorActor,\n    portableTextEditor,\n    readOnly,\n    slateEditor\n  }, $[1] = editorActor, $[2] = portableTextEditor, $[3] = readOnly, $[4] = slateEditor, $[5] = t1) : t1 = $[5];\n  const syncValue = useSyncValue(t1);\n  let t2, t3;\n  $[6] !== slateEditor ? (t2 = () => {\n    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !1);\n  }, t3 = [slateEditor], $[6] = slateEditor, $[7] = t2, $[8] = t3) : (t2 = $[7], t3 = $[8]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t2, t3);\n  let t4;\n  $[9] !== editorActor || $[10] !== getValue || $[11] !== slateEditor ? (t4 = () => {\n    if (pendingPatches.current.length > 0) {\n      debug$i(\"Flushing pending patches\"), debugVerbose$3 && debug$i(`Patches:\n${JSON.stringify(pendingPatches.current, null, 2)}`);\n      const snapshot = getValue();\n      editorActor.send({\n        type: \"mutation\",\n        patches: pendingPatches.current,\n        snapshot\n      }), pendingPatches.current = [];\n    }\n    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !1);\n  }, $[9] = editorActor, $[10] = getValue, $[11] = slateEditor, $[12] = t4) : t4 = $[12];\n  const onFlushPendingPatches = t4;\n  let t5, t6;\n  $[13] !== onFlushPendingPatches ? (t5 = () => () => {\n    onFlushPendingPatches();\n  }, t6 = [onFlushPendingPatches], $[13] = onFlushPendingPatches, $[14] = t5, $[15] = t6) : (t5 = $[14], t6 = $[15]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t5, t6);\n  let t7, t8;\n  $[16] !== editorActor || $[17] !== onFlushPendingPatches || $[18] !== slateEditor ? (t7 = () => {\n    const onFlushPendingPatchesThrottled = lodash_throttle_js__WEBPACK_IMPORTED_MODULE_8__(() => {\n      if (slate__WEBPACK_IMPORTED_MODULE_17__.Editor.isNormalizing(slateEditor)) {\n        onFlushPendingPatches();\n        return;\n      }\n      onFlushPendingPatchesThrottled();\n    }, FLUSH_PATCHES_THROTTLED_MS, {\n      leading: !1,\n      trailing: !0\n    });\n    debug$i(\"Subscribing to patch events\");\n    const sub = editorActor.on(\"patch\", (event) => {\n      IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !0), pendingPatches.current.push(event.patch), onFlushPendingPatchesThrottled();\n    });\n    return () => {\n      debug$i(\"Unsubscribing to patch events\"), sub.unsubscribe();\n    };\n  }, t8 = [editorActor, onFlushPendingPatches, slateEditor], $[16] = editorActor, $[17] = onFlushPendingPatches, $[18] = slateEditor, $[19] = t7, $[20] = t8) : (t7 = $[19], t8 = $[20]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t7, t8);\n  const isInitialValueFromProps = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(!0);\n  let t10, t9;\n  return $[21] !== editorActor || $[22] !== syncValue || $[23] !== value ? (t9 = () => {\n    debug$i(\"Value from props changed, syncing new value\"), syncValue(value), isInitialValueFromProps.current && (editorActor.send({\n      type: \"ready\"\n    }), isInitialValueFromProps.current = !1);\n  }, t10 = [editorActor, syncValue, value], $[21] = editorActor, $[22] = syncValue, $[23] = value, $[24] = t10, $[25] = t9) : (t10 = $[24], t9 = $[25]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t9, t10), null;\n}\nfunction _temp2(s_0) {\n  return s_0.context.value;\n}\nfunction _temp(s) {\n  return s.context.readOnly;\n}\nSynchronizer.displayName = \"Synchronizer\";\nconst EditorActorContext = (0,react__WEBPACK_IMPORTED_MODULE_4__.createContext)({}), PortableTextEditorSelectionContext = (0,react__WEBPACK_IMPORTED_MODULE_4__.createContext)(null), usePortableTextEditorSelection = () => {\n  const selection = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(PortableTextEditorSelectionContext);\n  if (selection === void 0)\n    throw new Error(\"The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.\");\n  return selection;\n}, debug$h = debugWithName(\"component:PortableTextEditor:SelectionProvider\"), debugVerbose$2 = debug$h.enabled && !1;\nfunction PortableTextEditorSelectionProvider(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6), [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(null);\n  let t0, t1;\n  $[0] !== props.editorActor ? (t0 = () => {\n    debug$h(\"Subscribing to selection changes\");\n    const subscription = props.editorActor.on(\"selection\", (event) => {\n      (0,react__WEBPACK_IMPORTED_MODULE_4__.startTransition)(() => {\n        debugVerbose$2 && debug$h(\"Setting selection\"), setSelection(event.selection);\n      });\n    });\n    return () => {\n      debug$h(\"Unsubscribing to selection changes\"), subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor], $[0] = props.editorActor, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t0, t1);\n  let t2;\n  return $[3] !== props.children || $[4] !== selection ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorSelectionContext.Provider, { value: selection, children: props.children }), $[3] = props.children, $[4] = selection, $[5] = t2) : t2 = $[5], t2;\n}\nconst defaultKeyGenerator = () => randomKey(12), getByteHexTable = /* @__PURE__ */ (() => {\n  let table;\n  return () => {\n    if (table)\n      return table;\n    table = [];\n    for (let i = 0; i < 256; ++i)\n      table[i] = (i + 256).toString(16).slice(1);\n    return table;\n  };\n})();\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_22__[\"default\"])(rnds8), rnds8;\n}\nfunction randomKey(length) {\n  const table = getByteHexTable();\n  return whatwgRNG(length).reduce((str, n) => str + table[n], \"\").slice(0, length);\n}\nconst debug$g = debugWithName(\"operationToPatches\");\nfunction createOperationToPatches(types) {\n  const textBlockName = types.block.name;\n  function insertTextPatch(editor, operation, beforeValue) {\n    debug$g.enabled && debug$g(\"Operation\", JSON.stringify(operation, null, 2));\n    const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{\n      _key: block._key\n    }, \"children\", {\n      _key: textChild._key\n    }, \"text\"], prevBlock = beforeValue[operation.path[0]], prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevChild) ? prevChild.text : \"\", patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.diffMatchPatch)(prevText, textChild.text, path);\n    return patch.value.length ? [patch] : [];\n  }\n  function removeTextPatch(editor, operation, beforeValue) {\n    const block = editor && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, textChild = editor.isTextSpan(child) ? child : void 0;\n    if (child && !textChild)\n      throw new Error(\"Expected span\");\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{\n      _key: block._key\n    }, \"children\", {\n      _key: textChild._key\n    }, \"text\"], beforeBlock = beforeValue[operation.path[0]], prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text, patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.diffMatchPatch)(prevText || \"\", textChild.text, path);\n    return patch.value ? [patch] : [];\n  }\n  function setNodePatch(editor, operation) {\n    if (operation.path.length === 1) {\n      const block = editor.children[operation.path[0]];\n      if (typeof block._key != \"string\")\n        throw new Error(\"Expected block to have a _key\");\n      const setNode = lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_14__({\n        ...editor.children[operation.path[0]],\n        ...operation.newProperties\n      }, lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_13__);\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(fromSlateValue([setNode], textBlockName)[0], [{\n        _key: block._key\n      }])];\n    } else if (operation.path.length === 2) {\n      const block = editor.children[operation.path[0]];\n      if (editor.isTextBlock(block)) {\n        const child = block.children[operation.path[1]];\n        if (child) {\n          const blockKey = block._key, childKey = child._key, patches = [], keys = Object.keys(operation.newProperties);\n          return keys.forEach((keyName) => {\n            if (keys.length === 1 && keyName === \"_key\") {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_12__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(val, [{\n                _key: blockKey\n              }, \"children\", block.children.indexOf(child), keyName]));\n            } else {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_12__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(val, [{\n                _key: blockKey\n              }, \"children\", {\n                _key: childKey\n              }, keyName]));\n            }\n          }), patches;\n        }\n        throw new Error(\"Could not find a valid child\");\n      }\n      throw new Error(\"Could not find a valid block\");\n    } else\n      throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);\n  }\n  function insertNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]], isTextBlock = editor.isTextBlock(block);\n    if (operation.path.length === 1) {\n      const position = operation.path[0] === 0 ? \"before\" : \"after\", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key;\n      return targetKey ? [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([fromSlateValue([operation.node], textBlockName)[0]], position, [{\n        _key: targetKey\n      }])] : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.setIfMissing)(beforeValue, []), (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([fromSlateValue([operation.node], textBlockName)[0]], \"before\", [operation.path[0]])];\n    } else if (isTextBlock && operation.path.length === 2 && editor.children[operation.path[0]]) {\n      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? \"before\" : \"after\", node = {\n        ...operation.node\n      };\n      !node._type && slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(node) && (node._type = \"span\", node.marks = []);\n      const child = fromSlateValue([{\n        _key: \"bogus\",\n        _type: textBlockName,\n        children: [node]\n      }], textBlockName)[0].children[0];\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([child], position, [{\n        _key: block._key\n      }, \"children\", block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {\n        _key: block.children[operation.path[1] - 1]._key\n      }])];\n    }\n    return debug$g(\"Something was inserted into a void block. Not producing editor patches.\"), [];\n  }\n  function splitNodePatch(editor, operation, beforeValue) {\n    const patches = [], splitBlock = editor.children[operation.path[0]];\n    if (!editor.isTextBlock(splitBlock))\n      throw new Error(`Block with path ${JSON.stringify(operation.path[0])} is not a text block and can't be split`);\n    if (operation.path.length === 1) {\n      const oldBlock = beforeValue[operation.path[0]];\n      if (editor.isTextBlock(oldBlock)) {\n        const targetValue = fromSlateValue([editor.children[operation.path[0] + 1]], textBlockName)[0];\n        targetValue && (patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([targetValue], \"after\", [{\n          _key: splitBlock._key\n        }])), oldBlock.children.slice(operation.position).forEach((span) => {\n          const path = [{\n            _key: oldBlock._key\n          }, \"children\", {\n            _key: span._key\n          }];\n          patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)(path));\n        }));\n      }\n      return patches;\n    }\n    if (operation.path.length === 2) {\n      const splitSpan = splitBlock.children[operation.path[1]];\n      if (editor.isTextSpan(splitSpan)) {\n        const targetSpans = fromSlateValue([{\n          ...splitBlock,\n          children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)\n        }], textBlockName)[0].children;\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)(targetSpans, \"after\", [{\n          _key: splitBlock._key\n        }, \"children\", {\n          _key: splitSpan._key\n        }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(splitSpan.text, [{\n          _key: splitBlock._key\n        }, \"children\", {\n          _key: splitSpan._key\n        }, \"text\"]));\n      }\n      return patches;\n    }\n    return patches;\n  }\n  function removeNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]];\n    if (operation.path.length === 1) {\n      if (block && block._key)\n        return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n          _key: block._key\n        }])];\n      throw new Error(\"Block not found\");\n    } else if (editor.isTextBlock(block) && operation.path.length === 2) {\n      const spanToRemove = block.children[operation.path[1]];\n      return spanToRemove ? block.children.filter((span) => span._key === operation.node._key).length > 1 ? (console.warn(`Multiple spans have \\`_key\\` ${operation.node._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)), []) : [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: spanToRemove._key\n      }])] : (debug$g(\"Span not found in editor trying to remove node\"), []);\n    } else\n      return debug$g(\"Not creating patch inside object block\"), [];\n  }\n  function mergeNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], updatedBlock = editor.children[operation.path[0]];\n    if (operation.path.length === 1)\n      if (block?._key) {\n        const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(newBlock, [{\n          _key: newBlock._key\n        }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n          _key: block._key\n        }]));\n      } else\n        throw new Error(\"Target key not found!\");\n    else if (editor.isTextBlock(block) && editor.isTextBlock(updatedBlock) && operation.path.length === 2) {\n      const updatedSpan = updatedBlock.children[operation.path[1] - 1] && editor.isTextSpan(updatedBlock.children[operation.path[1] - 1]) ? updatedBlock.children[operation.path[1] - 1] : void 0, removedSpan = block.children[operation.path[1]] && editor.isTextSpan(block.children[operation.path[1]]) ? block.children[operation.path[1]] : void 0;\n      updatedSpan && (block.children.filter((span) => span._key === updatedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(updatedSpan.text, [{\n        _key: block._key\n      }, \"children\", {\n        _key: updatedSpan._key\n      }, \"text\"])) : console.warn(`Multiple spans have \\`_key\\` ${updatedSpan._key}. It's ambiguous which one to update.`, JSON.stringify(block, null, 2))), removedSpan && (block.children.filter((span) => span._key === removedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: removedSpan._key\n      }])) : console.warn(`Multiple spans have \\`_key\\` ${removedSpan._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)));\n    } else\n      debug$g(\"Void nodes can't be merged, not creating any patches\");\n    return patches;\n  }\n  function moveNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];\n    if (operation.path.length === 1) {\n      const position = operation.path[0] > operation.newPath[0] ? \"before\" : \"after\";\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n        _key: block._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([fromSlateValue([block], textBlockName)[0]], position, [{\n        _key: targetBlock._key\n      }]));\n    } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {\n      const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? \"after\" : \"before\", childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([{\n        _key: block._key\n      }, \"children\", {\n        _key: child._key\n      }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([childToInsert], position, [{\n        _key: targetBlock._key\n      }, \"children\", {\n        _key: targetChild._key\n      }]));\n    }\n    return patches;\n  }\n  return {\n    insertNodePatch,\n    insertTextPatch,\n    mergeNodePatch,\n    moveNodePatch,\n    removeNodePatch,\n    removeTextPatch,\n    setNodePatch,\n    splitNodePatch\n  };\n}\nfunction createWithEventListeners(editorActor, subscriptions) {\n  return function(editor) {\n    return editorActor.getSnapshot().context.maxBlocks !== void 0 || (subscriptions.push(() => {\n      const subscription = editorActor.on(\"*\", (event) => {\n        switch (event.type) {\n          case \"annotation.add\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"annotation.add\",\n                annotation: event.annotation\n              },\n              editor\n            });\n            break;\n          }\n          case \"annotation.remove\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"annotation.remove\",\n                annotation: event.annotation\n              },\n              editor\n            });\n            break;\n          }\n          case \"annotation.toggle\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"annotation.toggle\",\n                annotation: event.annotation\n              },\n              editor\n            });\n            break;\n          }\n          case \"focus\": {\n            editorActor.send({\n              type: \"behavior event\",\n              behaviorEvent: {\n                type: \"focus\"\n              },\n              editor\n            });\n            break;\n          }\n        }\n      });\n      return () => {\n        subscription.unsubscribe();\n      };\n    }), editor.addMark = (mark) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"decorator.add\",\n          decorator: mark\n        },\n        editor\n      });\n    }, editor.removeMark = (mark) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"decorator.remove\",\n          decorator: mark\n        },\n        editor\n      });\n    }, editor.deleteBackward = (unit) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete backward\",\n          unit\n        },\n        editor\n      });\n    }, editor.deleteForward = (unit) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"delete forward\",\n          unit\n        },\n        editor\n      });\n    }, editor.insertBreak = () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert break\"\n        },\n        editor\n      });\n    }, editor.insertSoftBreak = () => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert soft break\"\n        },\n        editor\n      });\n    }, editor.insertText = (text, options) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"insert text\",\n          text,\n          options\n        },\n        editor\n      });\n    }), editor;\n  };\n}\nfunction createWithMaxBlocks(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (operation) => {\n      if (editorActor.getSnapshot().context.readOnly) {\n        apply2(operation);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      const rows = editorActor.getSnapshot().context.maxBlocks ?? -1;\n      rows > 0 && editor.children.length >= rows && (operation.type === \"insert_node\" || operation.type === \"split_node\") && operation.path.length === 1 || apply2(operation);\n    }, editor;\n  };\n}\nfunction createWithObjectKeys(editorActor, schemaTypes) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor;\n    return editor.apply = (operation) => {\n      if (isChangingRemotely(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(operation);\n        return;\n      }\n      if (operation.type === \"split_node\") {\n        apply2({\n          ...operation,\n          properties: {\n            ...operation.properties,\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }\n        });\n        return;\n      }\n      if (operation.type === \"insert_node\" && !slate__WEBPACK_IMPORTED_MODULE_17__.Editor.isEditor(operation.node)) {\n        apply2({\n          ...operation,\n          node: {\n            ...operation.node,\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }\n        });\n        return;\n      }\n      apply2(operation);\n    }, editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(node) && node._type === schemaTypes.block.name) {\n        if (!node._key) {\n          editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n            _key: editorActor.getSnapshot().context.keyGenerator()\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, path))\n          if (!child._key) {\n            editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n              _key: editorActor.getSnapshot().context.keyGenerator()\n            }, {\n              at: childPath\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nconst debug$f = debugWithName(\"applyPatches\"), debugVerbose$1 = debug$f.enabled && !0;\nfunction createApplyPatch(schemaTypes) {\n  return (editor, patch) => {\n    let changed = !1;\n    debugVerbose$1 && (debug$f(`\n\nNEW PATCH =============================================================`), debug$f(JSON.stringify(patch, null, 2)));\n    try {\n      switch (patch.type) {\n        case \"insert\":\n          changed = insertPatch(editor, patch, schemaTypes);\n          break;\n        case \"unset\":\n          changed = unsetPatch(editor, patch);\n          break;\n        case \"set\":\n          changed = setPatch(editor, patch);\n          break;\n        case \"diffMatchPatch\":\n          changed = diffMatchPatch(editor, patch);\n          break;\n        default:\n          debug$f(\"Unhandled patch\", patch.type);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return changed;\n  };\n}\nfunction diffMatchPatch(editor, patch) {\n  const {\n    block,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$f(\"Block not found\"), !1;\n  if (!child || !childPath)\n    return debug$f(\"Child not found\"), !1;\n  if (!(block && editor.isTextBlock(block) && patch.path.length === 4 && patch.path[1] === \"children\" && patch.path[3] === \"text\") || !slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(child))\n    return !1;\n  const patches = parse(patch.value), [newValue] = apply(patches, child.text, {\n    allowExceedingIndices: !0\n  }), diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);\n  debugState(editor, \"before\");\n  let offset = 0;\n  for (const [op, text] of diff$1)\n    op === DIFF_INSERT ? (editor.apply({\n      type: \"insert_text\",\n      path: childPath,\n      offset,\n      text\n    }), offset += text.length) : op === DIFF_DELETE ? editor.apply({\n      type: \"remove_text\",\n      path: childPath,\n      offset,\n      text\n    }) : op === DIFF_EQUAL && (offset += text.length);\n  return debugState(editor, \"after\"), !0;\n}\nfunction insertPatch(editor, patch, schemaTypes) {\n  const {\n    block: targetBlock,\n    child: targetChild,\n    blockPath: targetBlockPath,\n    childPath: targetChildPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!targetBlock || !targetBlockPath)\n    return debug$f(\"Block not found\"), !1;\n  if (patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$f(\"Ignoring patch targeting void value\"), !1;\n  if (patch.path.length === 1) {\n    const {\n      items: items2,\n      position: position2\n    } = patch, blocksToInsert = toSlateValue(items2, {\n      schemaTypes\n    }, KEY_TO_SLATE_ELEMENT.get(editor)), targetBlockIndex = targetBlockPath[0], normalizedIdx2 = position2 === \"after\" ? targetBlockIndex + 1 : targetBlockIndex;\n    return debug$f(`Inserting blocks at path [${normalizedIdx2}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, blocksToInsert, {\n      at: [normalizedIdx2]\n    }), debugState(editor, \"after\"), !0;\n  }\n  const {\n    items,\n    position\n  } = patch;\n  if (!targetChild || !targetChildPath)\n    return debug$f(\"Child not found\"), !1;\n  const childrenToInsert = targetBlock && toSlateValue([{\n    ...targetBlock,\n    children: items\n  }], {\n    schemaTypes\n  }, KEY_TO_SLATE_ELEMENT.get(editor)), targetChildIndex = targetChildPath[1], normalizedIdx = position === \"after\" ? targetChildIndex + 1 : targetChildIndex, childInsertPath = [targetChildPath[0], normalizedIdx];\n  return debug$f(`Inserting children at path ${childInsertPath}`), debugState(editor, \"before\"), childrenToInsert && slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(childrenToInsert[0]) && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, childrenToInsert[0].children, {\n    at: childInsertPath\n  }), debugState(editor, \"after\"), !0;\n}\nfunction setPatch(editor, patch) {\n  let value = patch.value;\n  typeof patch.path[3] == \"string\" && (value = {}, value[patch.path[3]] = patch.value);\n  const {\n    block,\n    blockPath,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$f(\"Block not found\"), !1;\n  const isTextBlock = editor.isTextBlock(block);\n  if (isTextBlock && patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$f(\"Ignoring setting void value\"), !1;\n  if (debugState(editor, \"before\"), isTextBlock && child && childPath) {\n    if (slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(value) && slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(child)) {\n      const newText = child.text;\n      value.text !== newText && (debug$f(\"Setting text property\"), editor.apply({\n        type: \"remove_text\",\n        path: childPath,\n        offset: 0,\n        text: newText\n      }), editor.apply({\n        type: \"insert_text\",\n        path: childPath,\n        offset: 0,\n        text: value.text\n      }), editor.onChange());\n    } else\n      debug$f(\"Setting non-text property\"), editor.apply({\n        type: \"set_node\",\n        path: childPath,\n        properties: {},\n        newProperties: value\n      });\n    return !0;\n  } else if (slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(block) && patch.path.length === 1 && blockPath) {\n    debug$f(\"Setting block property\");\n    const {\n      children,\n      ...nextRest\n    } = value, {\n      children: prevChildren,\n      ...prevRest\n    } = block || {\n      children: void 0\n    };\n    editor.apply({\n      type: \"set_node\",\n      path: blockPath,\n      properties: {\n        ...prevRest\n      },\n      newProperties: nextRest\n    }), debug$f(\"Setting children\"), block.children.forEach((c2, cIndex) => {\n      editor.apply({\n        type: \"remove_node\",\n        path: blockPath.concat(block.children.length - 1 - cIndex),\n        node: c2\n      });\n    }), Array.isArray(children) && children.forEach((c2, cIndex) => {\n      editor.apply({\n        type: \"insert_node\",\n        path: blockPath.concat(cIndex),\n        node: c2\n      });\n    });\n  } else if (block && \"value\" in block) {\n    const newVal = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.applyAll)([block.value], [patch])[0];\n    return slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n      ...block,\n      value: newVal\n    }, {\n      at: blockPath\n    }), !0;\n  }\n  return debugState(editor, \"after\"), !0;\n}\nfunction unsetPatch(editor, patch) {\n  if (patch.path.length === 0) {\n    debug$f(\"Removing everything\"), debugState(editor, \"before\");\n    const previousSelection = editor.selection;\n    return slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.deselect(editor), editor.children.forEach((_child, i) => {\n      slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(editor, {\n        at: [i]\n      });\n    }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n      decorators: []\n    })), previousSelection && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(editor, {\n      anchor: {\n        path: [0, 0],\n        offset: 0\n      },\n      focus: {\n        path: [0, 0],\n        offset: 0\n      }\n    }), editor.onChange(), debugState(editor, \"after\"), !0;\n  }\n  const {\n    block,\n    blockPath,\n    child,\n    childPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (patch.path.length === 1) {\n    if (!block || !blockPath)\n      return debug$f(\"Block not found\"), !1;\n    const blockIndex = blockPath[0];\n    return debug$f(`Removing block at path [${blockIndex}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(editor, {\n      at: [blockIndex]\n    }), debugState(editor, \"after\"), !0;\n  }\n  return editor.isTextBlock(block) && patch.path[1] === \"children\" && patch.path.length === 3 ? !child || !childPath ? (debug$f(\"Child not found\"), !1) : (debug$f(`Unsetting child at path ${JSON.stringify(childPath)}`), debugState(editor, \"before\"), debugVerbose$1 && debug$f(`Removing child at path ${JSON.stringify(childPath)}`), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(editor, {\n    at: childPath\n  }), debugState(editor, \"after\"), !0) : !1;\n}\nfunction isKeyedSegment(segment) {\n  return typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction debugState(editor, stateName) {\n  debugVerbose$1 && (debug$f(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2)), debug$f(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2)));\n}\nfunction findBlockFromPath(editor, path) {\n  let blockIndex = -1;\n  const block = editor.children.find((node, index) => {\n    const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index === path[0];\n    return isMatch && (blockIndex = index), isMatch;\n  });\n  return block ? {\n    block,\n    path: [blockIndex]\n  } : {};\n}\nfunction findBlockAndChildFromPath(editor, path) {\n  const {\n    block,\n    path: blockPath\n  } = findBlockFromPath(editor, path);\n  if (!(slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(block) && path[1] === \"children\"))\n    return {\n      block,\n      blockPath,\n      child: void 0,\n      childPath: void 0\n    };\n  let childIndex = -1;\n  const child = block.children.find((node, index) => {\n    const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index === path[2];\n    return isMatch && (childIndex = index), isMatch;\n  });\n  return child ? {\n    block,\n    child,\n    blockPath,\n    childPath: blockPath?.concat(childIndex)\n  } : {\n    block,\n    blockPath,\n    child: void 0,\n    childPath: void 0\n  };\n}\nconst debug$e = debugWithName(\"plugin:withPatches\");\nfunction createWithPatches({\n  editorActor,\n  patchFunctions,\n  schemaTypes,\n  subscriptions\n}) {\n  let previousChildren;\n  const applyPatch = createApplyPatch(schemaTypes);\n  return function(editor) {\n    IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [...editor.children];\n    const {\n      apply: apply2\n    } = editor;\n    let bufferedPatches = [];\n    const handleBufferedRemotePatches = () => {\n      if (bufferedPatches.length === 0)\n        return;\n      const patches = bufferedPatches;\n      bufferedPatches = [];\n      let changed = !1;\n      withRemoteChanges(editor, () => {\n        slate__WEBPACK_IMPORTED_MODULE_17__.Editor.withoutNormalizing(editor, () => {\n          withoutPatching(editor, () => {\n            withoutSaving(editor, () => {\n              patches.forEach((patch) => {\n                debug$e.enabled && debug$e(`Handling remote patch ${JSON.stringify(patch)}`), changed = applyPatch(editor, patch);\n              });\n            });\n          });\n        }), changed && (editor.normalize(), editor.onChange());\n      });\n    }, handlePatches = ({\n      patches\n    }) => {\n      const remotePatches = patches.filter((p) => p.origin !== \"local\");\n      remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());\n    };\n    return subscriptions.push(() => {\n      debug$e(\"Subscribing to remote patches\");\n      const sub = editorActor.on(\"patches\", handlePatches);\n      return () => {\n        debug$e(\"Unsubscribing to remote patches\"), sub.unsubscribe();\n      };\n    }), editor.apply = (operation) => {\n      if (editorActor.getSnapshot().context.readOnly)\n        return apply2(operation), editor;\n      let patches = [];\n      previousChildren = editor.children;\n      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes);\n      apply2(operation);\n      const editorIsEmpty = isEqualToEmptyEditor(editor.children, schemaTypes);\n      if (!isPatching(editor))\n        return editor;\n      switch (editorWasEmpty && !editorIsEmpty && operation.type !== \"set_selection\" && patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)(previousChildren, \"before\", [0])), operation.type) {\n        case \"insert_text\":\n          patches = [...patches, ...patchFunctions.insertTextPatch(editor, operation, previousChildren)];\n          break;\n        case \"remove_text\":\n          patches = [...patches, ...patchFunctions.removeTextPatch(editor, operation, previousChildren)];\n          break;\n        case \"remove_node\":\n          patches = [...patches, ...patchFunctions.removeNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"split_node\":\n          patches = [...patches, ...patchFunctions.splitNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"insert_node\":\n          patches = [...patches, ...patchFunctions.insertNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"set_node\":\n          patches = [...patches, ...patchFunctions.setNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"merge_node\":\n          patches = [...patches, ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)];\n          break;\n        case \"move_node\":\n          patches = [...patches, ...patchFunctions.moveNodePatch(editor, operation, previousChildren)];\n          break;\n      }\n      return !editorWasEmpty && editorIsEmpty && [\"merge_node\", \"set_node\", \"remove_text\", \"remove_node\"].includes(operation.type) && (patches = [...patches, (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([])], editorActor.send({\n        type: \"unset\",\n        previousValue: fromSlateValue(previousChildren, schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))\n      })), editorWasEmpty && patches.length > 0 && (patches = [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.setIfMissing)([], []), ...patches]), patches.length > 0 && patches.forEach((patch) => {\n        editorActor.send({\n          type: \"patch\",\n          patch: {\n            ...patch,\n            origin: \"local\"\n          }\n        });\n      }), editor;\n    }, editor;\n  };\n}\nconst debug$d = debugWithName(\"plugin:withPlaceholderBlock\");\nfunction createWithPlaceholderBlock(editorActor) {\n  return function(editor) {\n    const {\n      apply: apply2\n    } = editor;\n    return editor.apply = (op) => {\n      if (editorActor.getSnapshot().context.readOnly) {\n        apply2(op);\n        return;\n      }\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"remove_node\") {\n        const node = op.node;\n        if (op.path[0] === 0 && slate__WEBPACK_IMPORTED_MODULE_17__.Editor.isVoid(editor, node)) {\n          const nextPath = slate__WEBPACK_IMPORTED_MODULE_17__.Path.next(op.path);\n          editor.children[nextPath[0]] || (debug$d(\"Adding placeholder block\"), slate__WEBPACK_IMPORTED_MODULE_17__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n            decorators: []\n          })));\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst debug$c = debugWithName(\"plugin:withPortableTextBlockStyle\");\nfunction createWithPortableTextBlockStyle(editorActor, types) {\n  const defaultStyle = types.styles[0].value;\n  return function(editor) {\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (nodeEntry) => {\n      const [, path] = nodeEntry;\n      for (const op of editor.operations)\n        if (op.type === \"split_node\" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !slate__WEBPACK_IMPORTED_MODULE_17__.Path.equals(path, op.path)) {\n          const [child] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, [op.path[0] + 1, 0]);\n          if (slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(child) && child.text === \"\") {\n            debug$c(`Normalizing split node to ${defaultStyle} style`, op), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n              style: defaultStyle\n            }, {\n              at: [op.path[0] + 1],\n              voids: !1\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      normalizeNode(nodeEntry);\n    }, editor.pteHasBlockStyle = (style) => editor.selection ? [...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => editor.isTextBlock(node) && node.style === style\n    })].length > 0 : !1, editor.pteToggleBlockStyle = (blockStyle) => {\n      editor.selection && ([...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      })].forEach(([node, path]) => {\n        editor.isTextBlock(node) && node.style === blockStyle ? (debug$c(`Unsetting block style '${blockStyle}'`), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          ...node,\n          style: defaultStyle\n        }, {\n          at: path\n        })) : (blockStyle ? debug$c(`Setting style '${blockStyle}'`) : debug$c(\"Setting default style\", defaultStyle), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          ...node,\n          style: blockStyle || defaultStyle\n        }, {\n          at: path\n        }));\n      }), editor.onChange());\n    }, editor;\n  };\n}\nconst debug$b = debugWithName(\"plugin:withPortableTextLists\"), MAX_LIST_LEVEL = 10;\nfunction createWithPortableTextLists(types) {\n  return function(editor) {\n    return editor.pteToggleListItem = (listItemStyle) => {\n      editor.pteHasListStyle(listItemStyle) ? (debug$b(`Remove list item '${listItemStyle}'`), editor.pteUnsetListItem(listItemStyle)) : (debug$b(`Add list item '${listItemStyle}'`), editor.pteSetListItem(listItemStyle));\n    }, editor.pteUnsetListItem = (listItemStyle) => {\n      editor.selection && [...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(node) && node._type === types.block.name\n      })].forEach(([node, path]) => {\n        if (editor.isListBlock(node)) {\n          const {\n            listItem,\n            level,\n            ...rest\n          } = node, newNode = {\n            ...rest,\n            listItem: void 0,\n            level: void 0\n          };\n          debug$b(`Unsetting list '${listItemStyle}'`), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, newNode, {\n            at: path\n          });\n        }\n      });\n    }, editor.pteSetListItem = (listItemStyle) => {\n      editor.selection && [...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      })].forEach(([node, path]) => {\n        debug$b(`Setting list '${listItemStyle}'`), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          ...node,\n          level: 1,\n          listItem: listItemStyle || types.lists[0] && types.lists[0].value\n        }, {\n          at: path\n        });\n      });\n    }, editor.pteEndList = () => {\n      if (!editor.selection)\n        return !1;\n      const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(node) && editor.isListBlock(node) && node.children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(node.children[0]) && node.children[0].text === \"\"\n      })];\n      return selectedBlocks.length === 0 ? !1 : (selectedBlocks.forEach(([node, path]) => {\n        slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(node) && (debug$b(\"Unset list\"), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          ...node,\n          level: void 0,\n          listItem: void 0\n        }, {\n          at: path\n        }));\n      }), !0);\n    }, editor.pteIncrementBlockLevels = (reverse) => {\n      if (!editor.selection)\n        return !1;\n      const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => !!editor.isListBlock(node)\n      })];\n      return selectedBlocks.length === 0 ? !1 : (selectedBlocks.forEach(([node, path]) => {\n        if (editor.isListBlock(node)) {\n          let level = node.level || 1;\n          reverse ? (level--, debug$b(\"Decrementing list level\", Math.min(MAX_LIST_LEVEL, Math.max(1, level)))) : (level++, debug$b(\"Incrementing list level\", Math.min(MAX_LIST_LEVEL, Math.max(1, level)))), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n            level: Math.min(MAX_LIST_LEVEL, Math.max(1, level))\n          }, {\n            at: path\n          });\n        }\n      }), !0);\n    }, editor.pteHasListStyle = (listStyle) => {\n      if (!editor.selection)\n        return !1;\n      const selectedBlocks = [...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      })];\n      return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => editor.isListBlock(node) && node.listItem === listStyle) : !1;\n    }, editor;\n  };\n}\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" && // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every((def) => typeof def._key == \"string\")) && // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction getPreviousSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let previousSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, blockPath, {\n    reverse: !0\n  }))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_17__.Path.isBefore(childPath, spanPath)) {\n      previousSpan = child;\n      break;\n    }\n  return previousSpan;\n}\nfunction getNextSpan({\n  editor,\n  blockPath,\n  spanPath\n}) {\n  let nextSpan;\n  for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, blockPath))\n    if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_17__.Path.isAfter(childPath, spanPath)) {\n      nextSpan = child;\n      break;\n    }\n  return nextSpan;\n}\nconst debug$a = debugWithName(\"plugin:withPortableTextMarkModel\");\nfunction createWithPortableTextMarkModel(editorActor, types) {\n  return function(editor) {\n    const {\n      apply: apply2,\n      normalizeNode\n    } = editor, decorators = types.decorators.map((t) => t.value);\n    return editor.normalizeNode = (nodeEntry) => {\n      const [node, path] = nodeEntry;\n      if (editor.isTextBlock(node)) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, path);\n        for (const [child, childPath] of children) {\n          const nextNode = node.children[childPath[1] + 1];\n          if (editor.isTextSpan(child) && editor.isTextSpan(nextNode) && child.marks?.every((mark) => nextNode.marks?.includes(mark)) && nextNode.marks?.every((mark) => child.marks?.includes(mark))) {\n            debug$a(\"Merging spans\", JSON.stringify(child, null, 2), JSON.stringify(nextNode, null, 2)), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.mergeNodes(editor, {\n              at: [childPath[0], childPath[1] + 1],\n              voids: !0\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {\n        debug$a(\"Adding .markDefs to block node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          markDefs: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {\n        debug$a(\"Adding .marks to span node\"), editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          marks: []\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_17__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, blockPath), decorators2 = types.decorators.map((decorator) => decorator.value), annotations = node.marks?.filter((mark) => !decorators2.includes(mark));\n        if (editor.isTextBlock(block) && node.text === \"\" && annotations && annotations.length > 0) {\n          debug$a(\"Removing annotations from empty span node\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n            marks: node.marks?.filter((mark) => decorators2.includes(mark))\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const decorators2 = types.decorators.map((decorator) => decorator.value);\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, path))\n          if (editor.isTextSpan(child)) {\n            const marks = child.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !node.markDefs?.find((def) => def._key === mark));\n            if (orphanedAnnotations.length > 0) {\n              debug$a(\"Removing orphaned annotations from span node\"), editorActor.send({\n                type: \"normalizing\"\n              }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n                marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n              }, {\n                at: childPath\n              }), editorActor.send({\n                type: \"done normalizing\"\n              });\n              return;\n            }\n          }\n      }\n      if (editor.isTextSpan(node)) {\n        const blockPath = slate__WEBPACK_IMPORTED_MODULE_17__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, blockPath);\n        if (editor.isTextBlock(block)) {\n          const decorators2 = types.decorators.map((decorator) => decorator.value), marks = node.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators2.includes(mark) && !block.markDefs?.find((def) => def._key === mark));\n          if (orphanedAnnotations.length > 0) {\n            debug$a(\"Removing orphaned annotations from span node\"), editorActor.send({\n              type: \"normalizing\"\n            }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n              marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))\n            }, {\n              at: path\n            }), editorActor.send({\n              type: \"done normalizing\"\n            });\n            return;\n          }\n        }\n      }\n      if (editor.isTextBlock(node)) {\n        const markDefs = node.markDefs ?? [], markDefKeys = /* @__PURE__ */ new Set(), newMarkDefs = [];\n        for (const markDef of markDefs)\n          markDefKeys.has(markDef._key) || (markDefKeys.add(markDef._key), newMarkDefs.push(markDef));\n        if (markDefs.length !== newMarkDefs.length) {\n          debug$a(\"Removing duplicate markDefs\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      if (editor.isTextBlock(node) && !editor.operations.some((op) => op.type === \"merge_node\" && \"markDefs\" in op.properties && op.path.length === 1)) {\n        const newMarkDefs = (node.markDefs || []).filter((def) => node.children.find((child) => slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));\n        if (node.markDefs && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(newMarkDefs, node.markDefs)) {\n          debug$a(\"Removing markDef not in use\"), editorActor.send({\n            type: \"normalizing\"\n          }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: path\n          }), editorActor.send({\n            type: \"done normalizing\"\n          });\n          return;\n        }\n      }\n      normalizeNode(nodeEntry);\n    }, editor.apply = (op) => {\n      if (isChangingRemotely(editor)) {\n        apply2(op);\n        return;\n      }\n      if (isUndoing(editor) || isRedoing(editor)) {\n        apply2(op);\n        return;\n      }\n      if (op.type === \"set_selection\" && slate__WEBPACK_IMPORTED_MODULE_17__.Editor.marks(editor) && op.properties && op.newProperties && op.properties.anchor && op.properties.focus && op.newProperties.anchor && op.newProperties.focus) {\n        const previousSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed({\n          anchor: op.properties.anchor,\n          focus: op.properties.focus\n        }), newSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed({\n          anchor: op.newProperties.anchor,\n          focus: op.newProperties.focus\n        });\n        if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {\n          const focusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.properties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], newFocusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: op.newProperties.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0]?.[0], movedToNextSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] + 1 && focusSpan.text.length === op.properties.focus.offset && op.newProperties.focus.offset === 0, movedToPreviousSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] - 1 && op.properties.focus.offset === 0 && newFocusSpan.text.length === op.newProperties.focus.offset;\n          if (movedToNextSpan || movedToPreviousSpan)\n            return;\n        }\n      }\n      if (op.type === \"insert_node\") {\n        const {\n          selection\n        } = editor;\n        if (selection) {\n          const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, selection, {\n            depth: 1\n          }), previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath: op.path\n          }), previousSpanAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath: [op.path[0], op.path[1] - 1]\n          }), nextSpanAnnotations = nextSpan ? nextSpan.marks?.filter((mark) => !decorators.includes(mark)) : [], annotationsEnding = previousSpanAnnotations?.filter((annotation) => !nextSpanAnnotations?.includes(annotation)) ?? [], atTheEndOfAnnotation = annotationsEnding.length > 0;\n          if (atTheEndOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsEnding.includes(mark))) {\n            slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, {\n              ...op.node,\n              marks: op.node.marks?.filter((mark) => !annotationsEnding.includes(mark)) ?? []\n            });\n            return;\n          }\n          const annotationsStarting = nextSpanAnnotations?.filter((annotation) => !previousSpanAnnotations?.includes(annotation)) ?? [], atTheStartOfAnnotation = annotationsStarting.length > 0;\n          if (atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark) => annotationsStarting.includes(mark))) {\n            slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, {\n              ...op.node,\n              marks: op.node.marks?.filter((mark) => !annotationsStarting.includes(mark)) ?? []\n            });\n            return;\n          }\n          const nextSpanDecorators = nextSpan?.marks?.filter((mark) => decorators.includes(mark)) ?? [];\n          if (nextSpanDecorators.length > 0 && atTheEndOfAnnotation && !atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.length === 0) {\n            slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, {\n              ...op.node,\n              marks: nextSpanDecorators\n            });\n            return;\n          }\n        }\n      }\n      if (op.type === \"insert_text\") {\n        const {\n          selection\n        } = editor, collapsedSelection = selection ? slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed(selection) : !1;\n        if (selection && collapsedSelection) {\n          const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: selection.focus,\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0], marks = span.marks ?? [], marksWithoutAnnotations = marks.filter((mark) => decorators.includes(mark)), spanHasAnnotations = marks.length > marksWithoutAnnotations.length, spanIsEmpty = span.text.length === 0, atTheBeginningOfSpan = selection.anchor.offset === 0, atTheEndOfSpan = selection.anchor.offset === span.text.length, previousSpan = getPreviousSpan({\n            editor,\n            blockPath,\n            spanPath\n          }), nextSpan = getNextSpan({\n            editor,\n            blockPath,\n            spanPath\n          }), nextSpanAnnotations = nextSpan?.marks?.filter((mark) => !decorators.includes(mark)) ?? [], spanAnnotations = marks.filter((mark) => !decorators.includes(mark)), previousSpanHasAnnotations = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark)) : !1, previousSpanHasSameAnnotations = previousSpan ? previousSpan.marks?.filter((mark) => !decorators.includes(mark)).every((mark) => marks.includes(mark)) : !1, previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, previousSpanHasSameMarks = previousSpan ? previousSpan.marks?.every((mark) => marks.includes(mark)) : !1, nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) => nextSpanAnnotations?.includes(mark));\n          if (spanHasAnnotations && !spanIsEmpty) {\n            if (atTheBeginningOfSpan) {\n              if (previousSpanHasSameMarks) {\n                slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? []\n                });\n                return;\n              } else if (previousSpanHasSameAnnotations) {\n                slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: previousSpan?.marks ?? []\n                });\n                return;\n              } else if (previousSpanHasSameAnnotation) {\n                apply2(op);\n                return;\n              } else if (!previousSpan) {\n                slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: []\n                });\n                return;\n              }\n            }\n            if (atTheEndOfSpan) {\n              if (nextSpan && nextSpanSharesSomeAnnotations && nextSpanAnnotations.length < spanAnnotations.length || !nextSpanSharesSomeAnnotations) {\n                slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: nextSpan?.marks ?? []\n                });\n                return;\n              }\n              if (!nextSpan) {\n                slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, {\n                  _type: \"span\",\n                  _key: editorActor.getSnapshot().context.keyGenerator(),\n                  text: op.text,\n                  marks: []\n                });\n                return;\n              }\n            }\n          }\n          if (atTheBeginningOfSpan && !spanIsEmpty && previousSpan) {\n            slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, {\n              _type: \"span\",\n              _key: editorActor.getSnapshot().context.keyGenerator(),\n              text: op.text,\n              marks: previousSpanHasAnnotations ? [] : (previousSpan.marks ?? []).filter((mark) => decorators.includes(mark))\n            });\n            return;\n          }\n        }\n      }\n      if (op.type === \"remove_text\") {\n        const {\n          selection\n        } = editor;\n        if (selection && slate__WEBPACK_IMPORTED_MODULE_17__.Range.isExpanded(selection)) {\n          const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, selection, {\n            depth: 1\n          }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n            mode: \"lowest\",\n            at: {\n              path: op.path,\n              offset: op.offset\n            },\n            match: (n) => editor.isTextSpan(n),\n            voids: !1\n          }))[0] ?? [void 0, void 0];\n          if (span && block && isPortableTextBlock(block)) {\n            const markDefs = block.markDefs ?? [], marks = span.marks ?? [], spanHasAnnotations = marks.some((mark) => markDefs.find((markDef) => markDef._key === mark)), deletingFromTheEnd = op.offset + op.text.length === span.text.length, deletingAllText = op.offset === 0 && deletingFromTheEnd, previousSpan = getPreviousSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), nextSpan = getNextSpan({\n              editor,\n              blockPath,\n              spanPath\n            }), previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, nextSpanHasSameAnnotation = nextSpan ? nextSpan.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1;\n            if (spanHasAnnotations && deletingAllText && !previousSpanHasSameAnnotation && !nextSpanHasSameAnnotation) {\n              const marksWithoutAnnotationMarks = ({\n                ...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.marks(editor) || {}\n              }.marks || []).filter((mark) => decorators.includes(mark));\n              slate__WEBPACK_IMPORTED_MODULE_17__.Editor.withoutNormalizing(editor, () => {\n                apply2(op), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n                  marks: marksWithoutAnnotationMarks\n                }, {\n                  at: op.path\n                });\n              }), editor.onChange();\n              return;\n            }\n          }\n        }\n      }\n      if (op.type === \"merge_node\" && op.path.length === 1 && \"markDefs\" in op.properties && op.properties._type === types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {\n        const [targetBlock, targetPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, [op.path[0] - 1]);\n        if (editor.isTextBlock(targetBlock)) {\n          const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__([...oldDefs, ...op.properties.markDefs]);\n          debug$a(\"Copying markDefs over to merged block\", op), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: targetPath,\n            voids: !1\n          }), apply2(op);\n          return;\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst addDecoratorActionImplementation = ({\n  action\n}) => {\n  const editor = action.editor, mark = action.decorator;\n  if (editor.selection) {\n    if (slate__WEBPACK_IMPORTED_MODULE_17__.Range.isExpanded(editor.selection)) {\n      slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {}, {\n        match: slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText,\n        split: !0,\n        hanging: !0\n      });\n      const splitTextNodes = slate__WEBPACK_IMPORTED_MODULE_17__.Range.isRange(editor.selection) ? [...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText\n      })] : [];\n      splitTextNodes.length > 1 && splitTextNodes.every((node) => node[0].marks?.includes(mark)) ? editor.removeMark(mark) : splitTextNodes.forEach(([node, path]) => {\n        const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark), mark];\n        slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          marks\n        }, {\n          at: path,\n          match: slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText,\n          split: !0,\n          hanging: !0\n        });\n      });\n    } else {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, editor.selection, {\n        depth: 1\n      }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n      if (lonelyEmptySpan) {\n        const existingMarks = lonelyEmptySpan.marks ?? [], existingMarksWithoutDecorator = existingMarks.filter((existingMark) => existingMark !== mark);\n        slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          marks: existingMarks.length === existingMarksWithoutDecorator.length ? [...existingMarks, mark] : existingMarksWithoutDecorator\n        }, {\n          at: blockPath,\n          match: (node) => editor.isTextSpan(node)\n        });\n      } else {\n        const existingMarks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.marks(editor) || {}\n        }.marks || [], marks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.marks(editor) || {},\n          marks: [...existingMarks, mark]\n        };\n        editor.marks = marks;\n      }\n    }\n    editor.onChange();\n  }\n}, removeDecoratorActionImplementation = ({\n  action\n}) => {\n  const editor = action.editor, mark = action.decorator, {\n    selection\n  } = editor;\n  if (selection)\n    if (slate__WEBPACK_IMPORTED_MODULE_17__.Range.isExpanded(selection))\n      slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {}, {\n        match: slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText,\n        split: !0,\n        hanging: !0\n      }), editor.selection && [...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText\n      })].forEach(([node, path]) => {\n        const block = editor.children[path[0]];\n        slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(block) && block.children.includes(node) && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),\n          _type: \"span\"\n        }, {\n          at: path\n        });\n      });\n    else {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, selection, {\n        depth: 1\n      }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n      if (lonelyEmptySpan) {\n        const existingMarksWithoutDecorator = (lonelyEmptySpan.marks ?? []).filter((existingMark) => existingMark !== mark);\n        slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          marks: existingMarksWithoutDecorator\n        }, {\n          at: blockPath,\n          match: (node) => editor.isTextSpan(node)\n        });\n      } else {\n        const existingMarks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.marks(editor) || {}\n        }.marks || [], marks = {\n          ...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.marks(editor) || {},\n          marks: existingMarks.filter((eMark) => eMark !== mark)\n        };\n        editor.marks = {\n          marks: marks.marks,\n          _type: \"span\"\n        };\n      }\n    }\n};\nfunction isDecoratorActive({\n  editor,\n  decorator\n}) {\n  if (!editor.selection)\n    return !1;\n  const selectedTextNodes = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n    match: slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText,\n    at: editor.selection\n  }));\n  return selectedTextNodes.length === 0 ? !1 : slate__WEBPACK_IMPORTED_MODULE_17__.Range.isExpanded(editor.selection) ? selectedTextNodes.every((n) => {\n    const [node] = n;\n    return node.marks?.includes(decorator);\n  }) : ({\n    ...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.marks(editor) || {}\n  }.marks || []).includes(decorator);\n}\nconst toggleDecoratorActionImplementation = ({\n  context,\n  action\n}) => {\n  isDecoratorActive({\n    editor: action.editor,\n    decorator: action.decorator\n  }) ? removeDecoratorActionImplementation({\n    context,\n    action: {\n      type: \"decorator.remove\",\n      editor: action.editor,\n      decorator: action.decorator\n    }\n  }) : addDecoratorActionImplementation({\n    context,\n    action: {\n      type: \"decorator.add\",\n      editor: action.editor,\n      decorator: action.decorator\n    }\n  });\n}, debug$9 = debugWithName(\"plugin:withPortableTextSelections\"), debugVerbose = debug$9.enabled && !1;\nfunction createWithPortableTextSelections(editorActor, types) {\n  let prevSelection = null;\n  return function(editor) {\n    const emitPortableTextSelection = () => {\n      if (prevSelection !== editor.selection) {\n        let ptRange = null;\n        if (editor.selection) {\n          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n          if (existing)\n            ptRange = existing;\n          else {\n            const value = editor.children;\n            ptRange = toPortableTextRange(value, editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n          }\n        }\n        debugVerbose && debug$9(`Emitting selection ${JSON.stringify(ptRange || null)} (${JSON.stringify(editor.selection)})`), ptRange ? editorActor.send({\n          type: \"selection\",\n          selection: ptRange\n        }) : editorActor.send({\n          type: \"selection\",\n          selection: null\n        });\n      }\n      prevSelection = editor.selection;\n    }, {\n      onChange\n    } = editor;\n    return editor.onChange = () => {\n      const hasChanges = editor.operations.length > 0;\n      onChange(), hasChanges && emitPortableTextSelection();\n    }, editor;\n  };\n}\nconst debug$8 = debugWithName(\"plugin:withSchemaTypes\");\nfunction createWithSchemaTypes({\n  editorActor,\n  schemaTypes\n}) {\n  return function(editor) {\n    editor.isTextBlock = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(value) && value._type === schemaTypes.block.name, editor.isTextSpan = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan)(value) && value._type === schemaTypes.span.name, editor.isListBlock = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextListBlock)(value) && value._type === schemaTypes.block.name, editor.isVoid = (element) => schemaTypes.block.name !== element._type && (schemaTypes.blockObjects.map((obj) => obj.name).includes(element._type) || schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type)), editor.isInline = (element) => schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type) && \"__inline\" in element && element.__inline === !0;\n    const {\n      normalizeNode\n    } = editor;\n    return editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (node._type === void 0 && path.length === 2) {\n        debug$8(\"Setting span type on text node without a type\");\n        const span = node, key = span._key || editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          ...span,\n          _type: schemaTypes.span.name,\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      if (node._key === void 0 && (path.length === 1 || path.length === 2)) {\n        debug$8(\"Setting missing key on child node without a key\");\n        const key = editorActor.getSnapshot().context.keyGenerator();\n        editorActor.send({\n          type: \"normalizing\"\n        }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          _key: key\n        }, {\n          at: path\n        }), editorActor.send({\n          type: \"done normalizing\"\n        });\n        return;\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nconst debug$7 = debugWithName(\"plugin:withUtils\");\nfunction createWithUtils({\n  editorActor,\n  schemaTypes\n}) {\n  return function(editor) {\n    return editor.pteExpandToWord = () => {\n      const {\n        selection\n      } = editor;\n      if (selection && !slate__WEBPACK_IMPORTED_MODULE_17__.Range.isExpanded(selection)) {\n        const [textNode] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, selection.focus, {\n          depth: 2\n        });\n        if (!textNode || !slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(textNode) || textNode.text.length === 0) {\n          debug$7(\"pteExpandToWord: Can't expand to word here\");\n          return;\n        }\n        const {\n          focus\n        } = selection, focusOffset = focus.offset, charsBefore = textNode.text.slice(0, focusOffset), charsAfter = textNode.text.slice(focusOffset, -1), isEmpty = (str) => str.match(/\\s/g), whiteSpaceBeforeIndex = charsBefore.split(\"\").reverse().findIndex((str) => isEmpty(str)), newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0, whiteSpaceAfterIndex = charsAfter.split(\"\").findIndex((obj) => isEmpty(obj)), newEndOffset = charsBefore.length + (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);\n        if (!(newStartOffset === newEndOffset || Number.isNaN(newStartOffset) || Number.isNaN(newEndOffset))) {\n          debug$7(\"pteExpandToWord: Expanding to focused word\"), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setSelection(editor, {\n            anchor: {\n              ...selection.anchor,\n              offset: newStartOffset\n            },\n            focus: {\n              ...selection.focus,\n              offset: newEndOffset\n            }\n          });\n          return;\n        }\n        debug$7(\"pteExpandToWord: Can't expand to word here\");\n      }\n    }, editor.pteCreateTextBlock = (options) => toSlateValue([{\n      _type: schemaTypes.block.name,\n      _key: editorActor.getSnapshot().context.keyGenerator(),\n      style: schemaTypes.styles[0].value || \"normal\",\n      ...options.listItem ? {\n        listItem: options.listItem\n      } : {},\n      ...options.level ? {\n        level: options.level\n      } : {},\n      markDefs: [],\n      children: [{\n        _type: \"span\",\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        text: \"\",\n        marks: options.decorators.filter((decorator) => schemaTypes.decorators.find(({\n          value\n        }) => value === decorator))\n      }]\n    }], {\n      schemaTypes\n    })[0], editor;\n  };\n}\nconst withPlugins = (editor, options) => {\n  const e = editor, {\n    editorActor\n  } = options, schemaTypes = editorActor.getSnapshot().context.schema, operationToPatches = createOperationToPatches(schemaTypes), withObjectKeys = createWithObjectKeys(editorActor, schemaTypes), withSchemaTypes = createWithSchemaTypes({\n    editorActor,\n    schemaTypes\n  }), withPatches = createWithPatches({\n    editorActor,\n    patchFunctions: operationToPatches,\n    schemaTypes,\n    subscriptions: options.subscriptions\n  }), withMaxBlocks = createWithMaxBlocks(editorActor), withPortableTextLists = createWithPortableTextLists(schemaTypes), withUndoRedo = createWithUndoRedo({\n    editorActor,\n    blockSchemaType: schemaTypes.block,\n    subscriptions: options.subscriptions\n  }), withPortableTextMarkModel = createWithPortableTextMarkModel(editorActor, schemaTypes), withPortableTextBlockStyle = createWithPortableTextBlockStyle(editorActor, schemaTypes), withPlaceholderBlock = createWithPlaceholderBlock(editorActor), withUtils = createWithUtils({\n    editorActor,\n    schemaTypes\n  }), withPortableTextSelections = createWithPortableTextSelections(editorActor, schemaTypes);\n  return createWithEventListeners(editorActor, options.subscriptions)(withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPortableTextLists(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(e))))))))))));\n}, debug$6 = debugWithName(\"component:PortableTextEditor:SlateContainer\"), slateEditors = /* @__PURE__ */ new WeakMap();\nfunction createSlateEditor(config) {\n  const existingSlateEditor = slateEditors.get(config.editorActor);\n  if (existingSlateEditor)\n    return debug$6(\"Reusing existing Slate editor instance\", config.editorActor.id), existingSlateEditor;\n  debug$6(\"Creating new Slate editor instance\", config.editorActor.id);\n  const unsubscriptions = [], subscriptions = [], instance = withPlugins((0,slate_react__WEBPACK_IMPORTED_MODULE_19__.withReact)((0,slate__WEBPACK_IMPORTED_MODULE_17__.createEditor)()), {\n    editorActor: config.editorActor,\n    subscriptions\n  });\n  KEY_TO_VALUE_ELEMENT.set(instance, {}), KEY_TO_SLATE_ELEMENT.set(instance, {});\n  for (const subscription of subscriptions)\n    unsubscriptions.push(subscription());\n  const initialValue = [instance.pteCreateTextBlock({\n    decorators: []\n  })], slateEditor = {\n    instance,\n    initialValue\n  };\n  return slateEditors.set(config.editorActor, slateEditor), slateEditor;\n}\nfunction insertBlock({\n  block,\n  placement,\n  editor,\n  schema\n}) {\n  if (editor.selection) {\n    const [focusBlock, focusBlockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n      at: editor.selection.focus.path.slice(0, 1),\n      match: (n) => !slate__WEBPACK_IMPORTED_MODULE_17__.Editor.isEditor(n)\n    }))[0] ?? [void 0, void 0];\n    if (placement === \"after\") {\n      const nextPath = [focusBlockPath[0] + 1];\n      slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, block, {\n        at: nextPath\n      }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(editor, {\n        anchor: {\n          path: [nextPath[0], 0],\n          offset: 0\n        },\n        focus: {\n          path: [nextPath[0], 0],\n          offset: 0\n        }\n      });\n    } else placement === \"before\" ? slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, block, {\n      at: focusBlockPath\n    }) : slate__WEBPACK_IMPORTED_MODULE_17__.Editor.insertNode(editor, block);\n    focusBlock && isEqualToEmptyEditor([focusBlock], schema) && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(editor, {\n      at: focusBlockPath\n    });\n  } else {\n    const lastBlock = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n      match: (n) => !slate__WEBPACK_IMPORTED_MODULE_17__.Editor.isEditor(n),\n      at: [],\n      reverse: !0\n    }))[0];\n    slate__WEBPACK_IMPORTED_MODULE_17__.Editor.insertNode(editor, block), lastBlock && isEqualToEmptyEditor([lastBlock[0]], schema) && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(editor, {\n      at: lastBlock[1]\n    });\n  }\n}\nconst insertBlockObjectActionImplementation = ({\n  context,\n  action\n}) => {\n  const block = toSlateValue([{\n    _key: context.keyGenerator(),\n    _type: action.blockObject.name,\n    ...action.blockObject.value ? action.blockObject.value : {}\n  }], {\n    schemaTypes: context.schema\n  })[0];\n  insertBlock({\n    block,\n    placement: action.placement,\n    editor: action.editor,\n    schema: context.schema\n  });\n}, debug$5 = debugWithName(\"API:editable\");\nfunction createEditableAPI(editor, editorActor) {\n  const types = editorActor.getSnapshot().context.schema;\n  return {\n    focus: () => {\n      slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.focus(editor);\n    },\n    blur: () => {\n      slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.blur(editor);\n    },\n    toggleMark: (mark) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"decorator.toggle\",\n          decorator: mark\n        },\n        editor\n      });\n    },\n    toggleList: (listStyle) => {\n      editor.pteToggleListItem(listStyle);\n    },\n    toggleBlockStyle: (blockStyle) => {\n      editor.pteToggleBlockStyle(blockStyle);\n    },\n    isMarkActive: (mark) => {\n      try {\n        return isDecoratorActive({\n          editor,\n          decorator: mark\n        });\n      } catch (err) {\n        return console.warn(err), !1;\n      }\n    },\n    marks: () => ({\n      ...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.marks(editor) || {}\n    }).marks || [],\n    undo: () => editor.undo(),\n    redo: () => editor.redo(),\n    select: (selection) => {\n      const slateSelection = toSlateRange(selection, editor);\n      slateSelection ? slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(editor, slateSelection) : slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.deselect(editor), editor.onChange();\n    },\n    focusBlock: () => {\n      if (editor.selection) {\n        const block = slate__WEBPACK_IMPORTED_MODULE_17__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (block)\n          return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n      }\n    },\n    focusChild: () => {\n      if (editor.selection) {\n        const block = slate__WEBPACK_IMPORTED_MODULE_17__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (block && editor.isTextBlock(block))\n          return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[editor.selection.focus.path[1]];\n      }\n    },\n    insertChild: (type, value) => {\n      if (!editor.selection)\n        throw new Error(\"The editor has no selection\");\n      const [focusBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n        at: editor.selection.focus.path.slice(0, 1),\n        match: (n) => n._type === types.block.name\n      }))[0] || [void 0];\n      if (!focusBlock)\n        throw new Error(\"No focused text block\");\n      if (type.name !== types.span.name && !types.inlineObjects.some((t) => t.name === type.name))\n        throw new Error(\"This type cannot be inserted as a child to a text block\");\n      const child = toSlateValue([{\n        _key: editorActor.getSnapshot().context.keyGenerator(),\n        _type: types.block.name,\n        children: [{\n          _key: editorActor.getSnapshot().context.keyGenerator(),\n          _type: type.name,\n          ...value || {}\n        }]\n      }], {\n        schemaTypes: editorActor.getSnapshot().context.schema\n      })[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode = child._type === types.span.name, focusNode = slate__WEBPACK_IMPORTED_MODULE_17__.Node.get(editor, focusChildPath);\n      return isSpanNode && focusNode._type !== types.span.name && (debug$5(\"Inserting span child next to inline object child, moving selection + 1\"), editor.move({\n        distance: 1,\n        unit: \"character\"\n      })), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, child, {\n        select: !0,\n        at: editor.selection\n      }), editor.onChange(), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path || [];\n    },\n    insertBlock: (type, value) => (insertBlockObjectActionImplementation({\n      context: {\n        keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n        schema: types\n      },\n      action: {\n        type: \"insert block object\",\n        blockObject: {\n          name: type.name,\n          value\n        },\n        placement: \"auto\",\n        editor\n      }\n    }), editor.onChange(), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path ?? []),\n    hasBlockStyle: (style) => {\n      try {\n        return editor.pteHasBlockStyle(style);\n      } catch {\n        return !1;\n      }\n    },\n    hasListStyle: (listStyle) => {\n      try {\n        return editor.pteHasListStyle(listStyle);\n      } catch {\n        return !1;\n      }\n    },\n    isVoid: (element) => ![types.block.name, types.span.name].includes(element._type),\n    findByPath: (path) => {\n      const slatePath = toSlateRange({\n        focus: {\n          path,\n          offset: 0\n        },\n        anchor: {\n          path,\n          offset: 0\n        }\n      }, editor);\n      if (slatePath) {\n        const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, slatePath.focus.path.slice(0, 1));\n        if (block && blockPath && typeof block._key == \"string\") {\n          if (path.length === 1 && slatePath.focus.path.length === 1)\n            return [fromSlateValue([block], types.block.name)[0], [{\n              _key: block._key\n            }]];\n          const ptBlock = fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n          if (editor.isTextBlock(ptBlock)) {\n            const ptChild = ptBlock.children[slatePath.focus.path[1]];\n            if (ptChild)\n              return [ptChild, [{\n                _key: block._key\n              }, \"children\", {\n                _key: ptChild._key\n              }]];\n          }\n        }\n      }\n      return [void 0, void 0];\n    },\n    findDOMNode: (element) => {\n      let node;\n      try {\n        const [item] = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n          at: [],\n          match: (n) => n._key === element._key\n        }) || [])[0] || [void 0];\n        node = slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.toDOMNode(editor, item);\n      } catch {\n      }\n      return node;\n    },\n    activeAnnotations: () => {\n      if (!editor.selection || editor.selection.focus.path.length < 2)\n        return [];\n      try {\n        const activeAnnotations = [], spans = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0\n        });\n        for (const [span, path] of spans) {\n          const [block] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, path, {\n            depth: 1\n          });\n          editor.isTextBlock(block) && block.markDefs?.forEach((def) => {\n            slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);\n          });\n        }\n        return activeAnnotations;\n      } catch {\n        return [];\n      }\n    },\n    isAnnotationActive: (annotationType) => isAnnotationActive({\n      editor,\n      annotation: {\n        name: annotationType\n      }\n    }),\n    addAnnotation: (type, value) => {\n      let paths;\n      return slate__WEBPACK_IMPORTED_MODULE_17__.Editor.withoutNormalizing(editor, () => {\n        paths = addAnnotationActionImplementation({\n          context: {\n            keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n            schema: types\n          },\n          action: {\n            type: \"annotation.add\",\n            annotation: {\n              name: type.name,\n              value: value ?? {}\n            },\n            editor\n          }\n        });\n      }), editor.onChange(), paths;\n    },\n    delete: (selection, options) => {\n      if (selection) {\n        const range = toSlateRange(selection, editor);\n        if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0))\n          throw new Error(\"Invalid range\");\n        if (range) {\n          if (!options?.mode || options?.mode === \"selected\") {\n            debug$5(\"Deleting content in selection\"), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.delete(editor, {\n              at: range,\n              hanging: !0,\n              voids: !0\n            }), editor.onChange();\n            return;\n          }\n          options?.mode === \"blocks\" && (debug$5(\"Deleting blocks touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(editor, {\n            at: range,\n            voids: !0,\n            match: (node) => editor.isTextBlock(node) || !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(node)\n          })), options?.mode === \"children\" && (debug$5(\"Deleting children touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(editor, {\n            at: range,\n            voids: !0,\n            match: (node) => node._type === types.span.name || // Text children\n            !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_17__.Element.isElement(node)\n          })), editor.children.length === 0 && (editor.children = [editor.pteCreateTextBlock({\n            decorators: []\n          })]), editor.onChange();\n        }\n      }\n    },\n    removeAnnotation: (type) => {\n      editorActor.send({\n        type: \"behavior event\",\n        behaviorEvent: {\n          type: \"annotation.remove\",\n          annotation: {\n            name: type.name\n          }\n        },\n        editor\n      });\n    },\n    getSelection: () => {\n      let ptRange = null;\n      if (editor.selection) {\n        const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n        if (existing)\n          return existing;\n        ptRange = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n      }\n      return ptRange;\n    },\n    getValue: () => fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n    isCollapsedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed(editor.selection),\n    isExpandedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_17__.Range.isExpanded(editor.selection),\n    insertBreak: () => {\n      editor.insertBreak(), editor.onChange();\n    },\n    getFragment: () => fromSlateValue(editor.getFragment(), types.block.name),\n    isSelectionsOverlapping: (selectionA, selectionB) => {\n      const rangeA = toSlateRange(selectionA, editor), rangeB = toSlateRange(selectionB, editor);\n      return slate__WEBPACK_IMPORTED_MODULE_17__.Range.isRange(rangeA) && slate__WEBPACK_IMPORTED_MODULE_17__.Range.isRange(rangeB) && slate__WEBPACK_IMPORTED_MODULE_17__.Range.includes(rangeA, rangeB);\n    }\n  };\n}\nfunction isAnnotationActive({\n  editor,\n  annotation\n}) {\n  if (!editor.selection || editor.selection.focus.path.length < 2)\n    return !1;\n  try {\n    const spans = [...slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(node)\n    })];\n    if (spans.length === 0 || spans.some(([span]) => !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan)(span) || !span.marks || span.marks?.length === 0)) return !1;\n    const selectionMarkDefs = spans.reduce((accMarkDefs, [, path]) => {\n      const [block] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, path, {\n        depth: 1\n      });\n      return editor.isTextBlock(block) && block.markDefs ? [...accMarkDefs, ...block.markDefs] : accMarkDefs;\n    }, []);\n    return spans.every(([span]) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan)(span) ? span.marks?.map((markKey) => selectionMarkDefs.find((def) => def?._key === markKey)?._type)?.includes(annotation.name) : !1);\n  } catch {\n    return !1;\n  }\n}\nconst addAnnotationActionImplementation = ({\n  context,\n  action\n}) => {\n  const editor = action.editor, {\n    selection: originalSelection\n  } = editor;\n  let paths;\n  if (originalSelection && (slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed(originalSelection) && (editor.pteExpandToWord(), editor.onChange()), editor.selection)) {\n    let spanPath, markDefPath;\n    const markDefPaths = [];\n    if (!editor.selection)\n      return;\n    const selectedBlocks = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n      at: editor.selection,\n      match: (node) => editor.isTextBlock(node),\n      reverse: slate__WEBPACK_IMPORTED_MODULE_17__.Range.isBackward(editor.selection)\n    });\n    for (const [block, blockPath] of selectedBlocks) {\n      if (block.children.length === 0 || block.children.length === 1 && block.children[0].text === \"\")\n        continue;\n      const annotationKey = context.keyGenerator(), markDefs = block.markDefs ?? [];\n      markDefs.find((markDef) => markDef._type === action.annotation.name && markDef._key === annotationKey) === void 0 && (slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n        markDefs: [...markDefs, {\n          _type: action.annotation.name,\n          _key: annotationKey,\n          ...action.annotation.value\n        }]\n      }, {\n        at: blockPath\n      }), markDefPath = [{\n        _key: block._key\n      }, \"markDefs\", {\n        _key: annotationKey\n      }], slate__WEBPACK_IMPORTED_MODULE_17__.Range.isBackward(editor.selection) ? markDefPaths.unshift(markDefPath) : markDefPaths.push(markDefPath)), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {}, {\n        match: slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText,\n        split: !0\n      });\n      const children = slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, blockPath);\n      for (const [span, path] of children) {\n        if (!editor.isTextSpan(span) || !slate__WEBPACK_IMPORTED_MODULE_17__.Range.includes(editor.selection, path))\n          continue;\n        const marks = span.marks ?? [], existingSameTypeAnnotations = marks.filter((mark) => markDefs.some((markDef) => markDef._key === mark && markDef._type === action.annotation.name));\n        slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          marks: [...marks.filter((mark) => !existingSameTypeAnnotations.includes(mark)), annotationKey]\n        }, {\n          at: path\n        }), spanPath = [{\n          _key: block._key\n        }, \"children\", {\n          _key: span._key\n        }];\n      }\n    }\n    markDefPath && spanPath && (paths = {\n      markDefPath,\n      markDefPaths,\n      spanPath\n    });\n  }\n  return paths;\n}, removeAnnotationActionImplementation = ({\n  action\n}) => {\n  const editor = action.editor;\n  if (debug$5(\"Removing annotation\", action.annotation.name), !!editor.selection)\n    if (slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed(editor.selection)) {\n      const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, editor.selection, {\n        depth: 1\n      });\n      if (!editor.isTextBlock(block))\n        return;\n      const potentialAnnotations = (block.markDefs ?? []).filter((markDef) => markDef._type === action.annotation.name), [selectedChild, selectedChildPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, editor.selection, {\n        depth: 2\n      });\n      if (!editor.isTextSpan(selectedChild))\n        return;\n      const annotationToRemove = selectedChild.marks?.find((mark) => potentialAnnotations.some((markDef) => markDef._key === mark));\n      if (!annotationToRemove)\n        return;\n      const previousSpansWithSameAnnotation = [];\n      for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, blockPath, {\n        reverse: !0\n      }))\n        if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_17__.Path.isBefore(childPath, selectedChildPath))\n          if (child.marks?.includes(annotationToRemove))\n            previousSpansWithSameAnnotation.push([child, childPath]);\n          else\n            break;\n      const nextSpansWithSameAnnotation = [];\n      for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, blockPath))\n        if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_17__.Path.isAfter(childPath, selectedChildPath))\n          if (child.marks?.includes(annotationToRemove))\n            nextSpansWithSameAnnotation.push([child, childPath]);\n          else\n            break;\n      for (const [child, childPath] of [...previousSpansWithSameAnnotation, [selectedChild, selectedChildPath], ...nextSpansWithSameAnnotation])\n        slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n          marks: child.marks?.filter((mark) => mark !== annotationToRemove)\n        }, {\n          at: childPath\n        });\n    } else {\n      slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {}, {\n        match: (node) => editor.isTextSpan(node),\n        split: !0,\n        hanging: !0\n      });\n      const blocks = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node)\n      });\n      for (const [block, blockPath] of blocks) {\n        const children = slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, blockPath);\n        for (const [child, childPath] of children) {\n          if (!editor.isTextSpan(child) || !slate__WEBPACK_IMPORTED_MODULE_17__.Range.includes(editor.selection, childPath))\n            continue;\n          const markDefs = block.markDefs ?? [], marks = child.marks ?? [], marksWithoutAnnotation = marks.filter((mark) => markDefs.find((markDef2) => markDef2._key === mark)?._type !== action.annotation.name);\n          marksWithoutAnnotation.length !== marks.length && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n            marks: marksWithoutAnnotation\n          }, {\n            at: childPath\n          });\n        }\n      }\n    }\n}, toggleAnnotationActionImplementation = ({\n  context,\n  action\n}) => {\n  if (isAnnotationActive({\n    editor: action.editor,\n    annotation: {\n      name: action.annotation.name\n    }\n  }))\n    removeAnnotationActionImplementation({\n      context,\n      action: {\n        type: \"annotation.remove\",\n        annotation: action.annotation,\n        editor: action.editor\n      }\n    });\n  else\n    return addAnnotationActionImplementation({\n      context,\n      action: {\n        type: \"annotation.add\",\n        annotation: action.annotation,\n        editor: action.editor\n      }\n    });\n}, insertBreakActionImplementation = ({\n  context,\n  action\n}) => {\n  const keyGenerator = context.keyGenerator, schema = context.schema, editor = action.editor;\n  if (!editor.selection)\n    return;\n  const [focusSpan] = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(editor, {\n    mode: \"lowest\",\n    at: editor.selection.focus,\n    match: (n) => editor.isTextSpan(n),\n    voids: !1\n  }))[0] ?? [void 0], focusDecorators = focusSpan.marks?.filter((mark) => schema.decorators.some((decorator) => decorator.value === mark)) ?? [], focusAnnotations = focusSpan.marks?.filter((mark) => !schema.decorators.some((decorator) => decorator.value === mark)) ?? [], focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = slate__WEBPACK_IMPORTED_MODULE_17__.Node.descendant(editor, focusBlockPath);\n  if (editor.isTextBlock(focusBlock)) {\n    const [start, end] = slate__WEBPACK_IMPORTED_MODULE_17__.Range.edges(editor.selection), atTheStartOfBlock = lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(end, {\n      path: [...focusBlockPath, 0],\n      offset: 0\n    });\n    if (atTheStartOfBlock && slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed(editor.selection)) {\n      slate__WEBPACK_IMPORTED_MODULE_17__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n        decorators: focusAnnotations.length === 0 ? focusDecorators : [],\n        listItem: focusBlock.listItem,\n        level: focusBlock.level\n      }));\n      const [nextBlockPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Path.next(focusBlockPath);\n      slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(editor, {\n        anchor: {\n          path: [nextBlockPath, 0],\n          offset: 0\n        },\n        focus: {\n          path: [nextBlockPath, 0],\n          offset: 0\n        }\n      });\n      return;\n    }\n    const lastFocusBlockChild = focusBlock.children[focusBlock.children.length - 1], atTheEndOfBlock = lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(start, {\n      path: [...focusBlockPath, focusBlock.children.length - 1],\n      offset: editor.isTextSpan(lastFocusBlockChild) ? lastFocusBlockChild.text.length : 0\n    });\n    if (atTheEndOfBlock && slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed(editor.selection)) {\n      slate__WEBPACK_IMPORTED_MODULE_17__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n        decorators: [],\n        listItem: focusBlock.listItem,\n        level: focusBlock.level\n      }));\n      const [nextBlockPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Path.next(focusBlockPath);\n      slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setSelection(editor, {\n        anchor: {\n          path: [nextBlockPath, 0],\n          offset: 0\n        },\n        focus: {\n          path: [nextBlockPath, 0],\n          offset: 0\n        }\n      });\n      return;\n    }\n    if (!atTheStartOfBlock && !atTheEndOfBlock) {\n      slate__WEBPACK_IMPORTED_MODULE_17__.Editor.withoutNormalizing(editor, () => {\n        if (!editor.selection)\n          return;\n        slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.splitNodes(editor, {\n          at: editor.selection\n        });\n        const [nextNode, nextNodePath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, slate__WEBPACK_IMPORTED_MODULE_17__.Path.next(focusBlockPath), {\n          depth: 1\n        });\n        if (slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setSelection(editor, {\n          anchor: {\n            path: [...nextNodePath, 0],\n            offset: 0\n          },\n          focus: {\n            path: [...nextNodePath, 0],\n            offset: 0\n          }\n        }), editor.isTextBlock(nextNode) && nextNode.markDefs && nextNode.markDefs.length > 0) {\n          const newMarkDefKeys = /* @__PURE__ */ new Map(), prevNodeSpans = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, focusBlockPath)).map((entry) => entry[0]).filter((node) => editor.isTextSpan(node)), children = slate__WEBPACK_IMPORTED_MODULE_17__.Node.children(editor, nextNodePath);\n          for (const [child, childPath] of children) {\n            if (!editor.isTextSpan(child))\n              continue;\n            const marks = child.marks ?? [];\n            for (const mark of marks)\n              schema.decorators.some((decorator) => decorator.value === mark) || prevNodeSpans.some((prevNodeSpan) => prevNodeSpan.marks?.includes(mark)) && !newMarkDefKeys.has(mark) && newMarkDefKeys.set(mark, keyGenerator());\n            const newMarks = marks.map((mark) => newMarkDefKeys.get(mark) ?? mark);\n            lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(marks, newMarks) || slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n              marks: newMarks\n            }, {\n              at: childPath\n            });\n          }\n          const newMarkDefs = nextNode.markDefs.map((markDef) => ({\n            ...markDef,\n            _key: newMarkDefKeys.get(markDef._key) ?? markDef._key\n          }));\n          lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(nextNode.markDefs, newMarkDefs) || slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n            markDefs: newMarkDefs\n          }, {\n            at: nextNodePath,\n            match: (node) => editor.isTextBlock(node)\n          });\n        }\n      }), editor.onChange();\n      return;\n    }\n  }\n}, insertSoftBreakActionImplementation = ({\n  context,\n  action\n}) => {\n  insertBreakActionImplementation({\n    context,\n    action: {\n      ...action,\n      type: \"insert break\"\n    }\n  });\n}, insertSpanActionImplementation = ({\n  context,\n  action\n}) => {\n  if (!action.editor.selection) {\n    console.error(\"Unable to perform action without selection\", action);\n    return;\n  }\n  const [focusBlock, focusBlockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_17__.Editor.nodes(action.editor, {\n    at: action.editor.selection.focus.path,\n    match: (node) => action.editor.isTextBlock(node)\n  }))[0] ?? [void 0, void 0];\n  if (!focusBlock || !focusBlockPath) {\n    console.error(\"Unable to perform action without focus block\", action);\n    return;\n  }\n  const markDefs = focusBlock.markDefs ?? [], annotations = action.annotations ? action.annotations.map((annotation) => ({\n    _type: annotation.name,\n    _key: context.keyGenerator(),\n    ...annotation.value\n  })) : void 0;\n  annotations && annotations.length > 0 && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(action.editor, {\n    markDefs: [...markDefs, ...annotations]\n  }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(action.editor, {\n    _type: \"span\",\n    _key: context.keyGenerator(),\n    text: action.text,\n    marks: [...annotations?.map((annotation) => annotation._key) ?? [], ...action.decorators ?? []]\n  });\n}, behaviorActionImplementations = {\n  \"annotation.add\": addAnnotationActionImplementation,\n  \"annotation.remove\": removeAnnotationActionImplementation,\n  \"annotation.toggle\": toggleAnnotationActionImplementation,\n  \"decorator.add\": addDecoratorActionImplementation,\n  \"decorator.remove\": removeDecoratorActionImplementation,\n  \"decorator.toggle\": toggleDecoratorActionImplementation,\n  focus: ({\n    action\n  }) => {\n    slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.focus(action.editor);\n  },\n  \"set block\": ({\n    action\n  }) => {\n    for (const path of action.paths) {\n      const at = toSlateRange({\n        anchor: {\n          path,\n          offset: 0\n        },\n        focus: {\n          path,\n          offset: 0\n        }\n      }, action.editor);\n      slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(action.editor, {\n        ...action.style ? {\n          style: action.style\n        } : {},\n        ...action.listItem ? {\n          listItem: action.listItem\n        } : {},\n        ...action.level ? {\n          level: action.level\n        } : {}\n      }, {\n        at\n      });\n    }\n  },\n  \"unset block\": ({\n    action\n  }) => {\n    for (const path of action.paths) {\n      const at = toSlateRange({\n        anchor: {\n          path,\n          offset: 0\n        },\n        focus: {\n          path,\n          offset: 0\n        }\n      }, action.editor);\n      slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.unsetNodes(action.editor, action.props, {\n        at\n      });\n    }\n  },\n  \"delete backward\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_17__.deleteBackward)(action.editor, action.unit);\n  },\n  \"delete forward\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_17__.deleteForward)(action.editor, action.unit);\n  },\n  \"delete block\": ({\n    action\n  }) => {\n    const range = toSlateRange({\n      anchor: {\n        path: action.blockPath,\n        offset: 0\n      },\n      focus: {\n        path: action.blockPath,\n        offset: 0\n      }\n    }, action.editor);\n    if (!range) {\n      console.error(\"Unable to find Slate range from selection points\");\n      return;\n    }\n    slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(action.editor, {\n      at: range\n    });\n  },\n  \"delete text\": ({\n    context,\n    action\n  }) => {\n    const value = fromSlateValue(action.editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(action.editor)), anchor = blockOffsetToSpanSelectionPoint({\n      value,\n      blockOffset: action.anchor\n    }), focus = blockOffsetToSpanSelectionPoint({\n      value,\n      blockOffset: action.focus\n    });\n    if (!anchor || !focus) {\n      console.error(\"Unable to find anchor or focus selection point\");\n      return;\n    }\n    const range = toSlateRange({\n      anchor,\n      focus\n    }, action.editor);\n    if (!range) {\n      console.error(\"Unable to find Slate range from selection points\");\n      return;\n    }\n    slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.delete(action.editor, {\n      at: range\n    });\n  },\n  \"insert block object\": insertBlockObjectActionImplementation,\n  \"insert break\": insertBreakActionImplementation,\n  \"insert soft break\": insertSoftBreakActionImplementation,\n  \"insert span\": insertSpanActionImplementation,\n  \"insert text\": ({\n    action\n  }) => {\n    (0,slate__WEBPACK_IMPORTED_MODULE_17__.insertText)(action.editor, action.text);\n  },\n  \"insert text block\": ({\n    context,\n    action\n  }) => {\n    const block = toSlateValue([{\n      _key: context.keyGenerator(),\n      _type: context.schema.block.name,\n      style: context.schema.styles[0].value ?? \"normal\",\n      markDefs: [],\n      children: action.textBlock?.children?.map((child) => ({\n        ...child,\n        _key: context.keyGenerator()\n      })) ?? [{\n        _type: context.schema.span.name,\n        _key: context.keyGenerator(),\n        text: \"\"\n      }]\n    }], {\n      schemaTypes: context.schema\n    })[0];\n    insertBlock({\n      block,\n      editor: action.editor,\n      schema: context.schema,\n      placement: action.placement\n    });\n  },\n  effect: ({\n    action\n  }) => {\n    action.effect();\n  },\n  paste: ({\n    action\n  }) => {\n    action.editor.insertData(action.clipboardData);\n  },\n  select: ({\n    action\n  }) => {\n    const newSelection = toSlateRange(action.selection, action.editor);\n    newSelection ? slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(action.editor, newSelection) : slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.deselect(action.editor);\n  },\n  reselect: ({\n    action\n  }) => {\n    const selection = action.editor.selection;\n    selection && (slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(action.editor, {\n      ...selection\n    }), action.editor.selection = {\n      ...selection\n    });\n  }\n};\nfunction performAction({\n  context,\n  action\n}) {\n  switch (action.type) {\n    case \"delete block\": {\n      behaviorActionImplementations[\"delete block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete text\": {\n      behaviorActionImplementations[\"delete text\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert block object\": {\n      behaviorActionImplementations[\"insert block object\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert span\": {\n      behaviorActionImplementations[\"insert span\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert text block\": {\n      behaviorActionImplementations[\"insert text block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"set block\": {\n      behaviorActionImplementations[\"set block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"unset block\": {\n      behaviorActionImplementations[\"unset block\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"effect\": {\n      behaviorActionImplementations.effect({\n        context,\n        action\n      });\n      break;\n    }\n    case \"select\": {\n      behaviorActionImplementations.select({\n        context,\n        action\n      });\n      break;\n    }\n    case \"reselect\": {\n      behaviorActionImplementations.reselect({\n        context,\n        action\n      });\n      break;\n    }\n    default:\n      performDefaultAction({\n        context,\n        action\n      });\n  }\n}\nfunction performDefaultAction({\n  context,\n  action\n}) {\n  switch (action.type) {\n    case \"annotation.add\": {\n      behaviorActionImplementations[\"annotation.add\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"annotation.remove\": {\n      behaviorActionImplementations[\"annotation.remove\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"annotation.toggle\": {\n      behaviorActionImplementations[\"annotation.toggle\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"decorator.add\": {\n      behaviorActionImplementations[\"decorator.add\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"decorator.remove\": {\n      behaviorActionImplementations[\"decorator.remove\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"decorator.toggle\": {\n      behaviorActionImplementations[\"decorator.toggle\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete backward\": {\n      behaviorActionImplementations[\"delete backward\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"delete forward\": {\n      behaviorActionImplementations[\"delete forward\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"focus\": {\n      behaviorActionImplementations.focus({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert break\": {\n      behaviorActionImplementations[\"insert break\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert soft break\": {\n      behaviorActionImplementations[\"insert soft break\"]({\n        context,\n        action\n      });\n      break;\n    }\n    case \"insert text\": {\n      behaviorActionImplementations[\"insert text\"]({\n        context,\n        action\n      });\n      break;\n    }\n    default:\n      behaviorActionImplementations.paste({\n        context,\n        action\n      });\n  }\n}\nconst editorMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_23__.setup)({\n  types: {\n    context: {},\n    events: {},\n    emitted: {},\n    input: {}\n  },\n  actions: {\n    \"assign behaviors\": (0,xstate__WEBPACK_IMPORTED_MODULE_24__.a)({\n      behaviors: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_23__.assertEvent)(event, \"update behaviors\"), event.behaviors)\n    }),\n    \"assign schema\": (0,xstate__WEBPACK_IMPORTED_MODULE_24__.a)({\n      schema: ({\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_23__.assertEvent)(event, \"update schema\"), event.schema)\n    }),\n    \"emit patch event\": (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_23__.assertEvent)(event, \"patch\"), event)),\n    \"emit mutation event\": (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n      event\n    }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_23__.assertEvent)(event, \"mutation\"), event)),\n    \"defer event\": (0,xstate__WEBPACK_IMPORTED_MODULE_24__.a)({\n      pendingEvents: ({\n        context,\n        event\n      }) => ((0,xstate__WEBPACK_IMPORTED_MODULE_23__.assertEvent)(event, [\"patch\", \"mutation\"]), [...context.pendingEvents, event])\n    }),\n    \"emit pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_24__.b)(({\n      context,\n      enqueue\n    }) => {\n      for (const event of context.pendingEvents)\n        enqueue((0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(event));\n    }),\n    \"clear pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_24__.a)({\n      pendingEvents: []\n    }),\n    \"handle behavior event\": (0,xstate__WEBPACK_IMPORTED_MODULE_24__.b)(({\n      context,\n      event,\n      enqueue\n    }) => {\n      (0,xstate__WEBPACK_IMPORTED_MODULE_23__.assertEvent)(event, [\"behavior event\"]);\n      const defaultAction = {\n        ...event.behaviorEvent,\n        editor: event.editor\n      }, eventBehaviors = context.behaviors.filter((behavior) => behavior.on === event.behaviorEvent.type);\n      if (eventBehaviors.length === 0) {\n        enqueue.raise({\n          type: \"behavior action intends\",\n          editor: event.editor,\n          actionIntends: [defaultAction]\n        });\n        return;\n      }\n      const value = fromSlateValue(event.editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(event.editor)), selection = toPortableTextRange(value, event.editor.selection, context.schema);\n      if (!selection) {\n        console.warn(`Unable to handle event ${event.type} due to missing selection`), enqueue.raise({\n          type: \"behavior action intends\",\n          editor: event.editor,\n          actionIntends: [defaultAction]\n        });\n        return;\n      }\n      const behaviorContext = {\n        schema: context.schema,\n        value,\n        selection\n      };\n      let behaviorOverwritten = !1;\n      for (const eventBehavior of eventBehaviors) {\n        const shouldRun = eventBehavior.guard?.({\n          context: behaviorContext,\n          event: event.behaviorEvent\n        }) ?? !0;\n        if (!shouldRun)\n          continue;\n        const actionIntendSets = eventBehavior.actions.map((actionSet) => actionSet({\n          context: behaviorContext,\n          event: event.behaviorEvent\n        }, shouldRun));\n        for (const actionIntends of actionIntendSets)\n          behaviorOverwritten = behaviorOverwritten || actionIntends.length > 0 && actionIntends.some((actionIntend) => actionIntend.type !== \"effect\"), enqueue.raise({\n            type: \"behavior action intends\",\n            editor: event.editor,\n            actionIntends\n          });\n        if (behaviorOverwritten)\n          break;\n      }\n      behaviorOverwritten || enqueue.raise({\n        type: \"behavior action intends\",\n        editor: event.editor,\n        actionIntends: [defaultAction]\n      });\n    })\n  }\n}).createMachine({\n  id: \"editor\",\n  context: ({\n    input\n  }) => ({\n    behaviors: input.behaviors ?? coreBehaviors,\n    keyGenerator: input.keyGenerator,\n    pendingEvents: [],\n    schema: input.schema,\n    readOnly: input.readOnly ?? !1,\n    maxBlocks: input.maxBlocks,\n    value: input.value\n  }),\n  on: {\n    \"annotation.add\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event),\n      guard: ({\n        context\n      }) => !context.readOnly\n    },\n    \"annotation.remove\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event),\n      guard: ({\n        context\n      }) => !context.readOnly\n    },\n    \"annotation.toggle\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event),\n      guard: ({\n        context\n      }) => !context.readOnly\n    },\n    focus: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event),\n      guard: ({\n        context\n      }) => !context.readOnly\n    },\n    ready: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event)\n    },\n    unset: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event)\n    },\n    \"value changed\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event)\n    },\n    \"invalid value\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event)\n    },\n    error: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event)\n    },\n    selection: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event)\n    },\n    blur: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event)\n    },\n    focused: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event)\n    },\n    loading: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)({\n        type: \"loading\"\n      })\n    },\n    patches: {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        event\n      }) => event)\n    },\n    \"done loading\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)({\n        type: \"done loading\"\n      })\n    },\n    \"update behaviors\": {\n      actions: \"assign behaviors\"\n    },\n    \"update schema\": {\n      actions: \"assign schema\"\n    },\n    \"update value\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.a)({\n        value: ({\n          event\n        }) => event.value\n      })\n    },\n    \"toggle readOnly\": {\n      actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_24__.a)({\n        readOnly: ({\n          context\n        }) => !context.readOnly\n      }), (0,xstate__WEBPACK_IMPORTED_MODULE_24__.e)(({\n        context\n      }) => ({\n        type: \"readOnly toggled\",\n        readOnly: context.readOnly\n      }))]\n    },\n    \"update maxBlocks\": {\n      actions: (0,xstate__WEBPACK_IMPORTED_MODULE_24__.a)({\n        maxBlocks: ({\n          event\n        }) => event.maxBlocks\n      })\n    },\n    \"behavior event\": {\n      actions: \"handle behavior event\",\n      guard: ({\n        context\n      }) => !context.readOnly\n    },\n    \"behavior action intends\": {\n      actions: [({\n        context,\n        event\n      }) => {\n        slate__WEBPACK_IMPORTED_MODULE_17__.Editor.withoutNormalizing(event.editor, () => {\n          for (const actionIntend of event.actionIntends) {\n            const action = {\n              ...actionIntend,\n              editor: event.editor\n            };\n            performAction({\n              context,\n              action\n            });\n          }\n        }), event.editor.onChange();\n      }, (0,xstate__WEBPACK_IMPORTED_MODULE_24__.b)(({\n        context,\n        event,\n        enqueue\n      }) => {\n        event.actionIntends.some((actionIntend) => actionIntend.type === \"reselect\") && enqueue.raise({\n          type: \"selection\",\n          selection: toPortableTextRange(event.editor.children, event.editor.selection, context.schema)\n        });\n      })]\n    }\n  },\n  initial: \"pristine\",\n  states: {\n    pristine: {\n      initial: \"idle\",\n      states: {\n        idle: {\n          on: {\n            normalizing: {\n              target: \"normalizing\"\n            },\n            patch: {\n              actions: \"defer event\",\n              target: \"#editor.dirty\"\n            },\n            mutation: {\n              actions: \"defer event\",\n              target: \"#editor.dirty\"\n            }\n          }\n        },\n        normalizing: {\n          on: {\n            \"done normalizing\": {\n              target: \"idle\"\n            },\n            patch: {\n              actions: \"defer event\"\n            },\n            mutation: {\n              actions: \"defer event\"\n            }\n          }\n        }\n      }\n    },\n    dirty: {\n      entry: [\"emit pending events\", \"clear pending events\"],\n      on: {\n        patch: {\n          actions: \"emit patch event\"\n        },\n        mutation: {\n          actions: \"emit mutation event\"\n        }\n      }\n    }\n  }\n});\nfunction createEditor(config) {\n  const editorActor = (0,xstate__WEBPACK_IMPORTED_MODULE_25__.A)(editorMachine, {\n    input: editorConfigToMachineInput(config)\n  });\n  editorActor.start();\n  const slateEditor = createSlateEditor({\n    editorActor\n  }), editable = createEditableAPI(slateEditor.instance, editorActor);\n  return {\n    send: (event) => {\n      editorActor.send(event);\n    },\n    on: (event, listener) => editorActor.on(\n      event,\n      // @ts-ignore\n      listener\n    ),\n    editable,\n    _internal: {\n      editorActor,\n      slateEditor\n    }\n  };\n}\nfunction useEditor(config) {\n  const editorActor = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useActorRef)(editorMachine, {\n    input: editorConfigToMachineInput(config)\n  }), slateEditor = createSlateEditor({\n    editorActor\n  }), editable = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => createEditableAPI(slateEditor.instance, editorActor), [slateEditor.instance, editorActor]), send = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event) => {\n    editorActor.send(event);\n  }, [editorActor]), on = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_0, listener) => editorActor.on(\n    event_0,\n    // @ts-ignore\n    listener\n  ), [editorActor]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => ({\n    send,\n    on,\n    editable,\n    _internal: {\n      editorActor,\n      slateEditor\n    }\n  }), [send, on, editable, editorActor, slateEditor]);\n}\nfunction editorConfigToMachineInput(config) {\n  return {\n    behaviors: config.behaviors,\n    keyGenerator: config.keyGenerator ?? defaultKeyGenerator,\n    maxBlocks: config.maxBlocks,\n    readOnly: config.readOnly,\n    schema: config.schemaDefinition ? compileSchemaDefinition(config.schemaDefinition) : getPortableTextMemberSchemaTypes(config.schema.hasOwnProperty(\"jsonType\") ? config.schema : compileType(config.schema)),\n    value: config.initialValue\n  };\n}\nconst debug$4 = debugWithName(\"component:PortableTextEditor\");\nclass PortableTextEditor extends react__WEBPACK_IMPORTED_MODULE_4__.Component {\n  static displayName = \"PortableTextEditor\";\n  /**\n   * An observable of all the editor changes.\n   */\n  change$ = new rxjs__WEBPACK_IMPORTED_MODULE_26__.Subject();\n  /**\n   * A lookup table for all the relevant schema types for this portable text type.\n   */\n  /**\n   * The editor instance\n   */\n  /*\n   * The editor API (currently implemented with Slate).\n   */\n  constructor(props) {\n    super(props), props.editor ? this.editor = props.editor : this.editor = createEditor({\n      keyGenerator: props.keyGenerator ?? defaultKeyGenerator,\n      schema: props.schemaType,\n      initialValue: props.value,\n      maxBlocks: props.maxBlocks === void 0 ? void 0 : Number.parseInt(props.maxBlocks.toString(), 10),\n      readOnly: props.readOnly\n    }), this.schemaTypes = this.editor._internal.editorActor.getSnapshot().context.schema, this.editable = this.editor.editable;\n  }\n  componentDidUpdate(prevProps) {\n    !this.props.editor && !prevProps.editor && this.props.schemaType !== prevProps.schemaType && (this.schemaTypes = getPortableTextMemberSchemaTypes(this.props.schemaType.hasOwnProperty(\"jsonType\") ? this.props.schemaType : compileType(this.props.schemaType)), this.editor._internal.editorActor.send({\n      type: \"update schema\",\n      schema: this.schemaTypes\n    })), !this.props.editor && !prevProps.editor && (this.props.readOnly !== prevProps.readOnly && this.editor._internal.editorActor.send({\n      type: \"toggle readOnly\"\n    }), this.props.maxBlocks !== prevProps.maxBlocks && this.editor._internal.editorActor.send({\n      type: \"update maxBlocks\",\n      maxBlocks: this.props.maxBlocks === void 0 ? void 0 : Number.parseInt(this.props.maxBlocks.toString(), 10)\n    }), this.props.value !== prevProps.value && this.editor._internal.editorActor.send({\n      type: \"update value\",\n      value: this.props.value\n    }), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this));\n  }\n  setEditable = (editable) => {\n    this.editor.editable = {\n      ...this.editor.editable,\n      ...editable\n    };\n  };\n  render() {\n    const legacyPatches = this.props.editor ? void 0 : this.props.incomingPatches$ ?? this.props.patches$;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n      legacyPatches ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RoutePatchesObservableToEditorActor, { editorActor: this.editor._internal.editorActor, patches$: legacyPatches }) : null,\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RouteEventsToChanges, { editorActor: this.editor._internal.editorActor, onChange: (change) => {\n        this.props.editor || this.props.onChange(change), this.change$.next(change);\n      } }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Synchronizer, { editorActor: this.editor._internal.editorActor, getValue: this.editor.editable.getValue, portableTextEditor: this, slateEditor: this.editor._internal.slateEditor.instance }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorActorContext.Provider, { value: this.editor._internal.editorActor, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_19__.Slate, { editor: this.editor._internal.slateEditor.instance, initialValue: this.editor._internal.slateEditor.initialValue, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorContext.Provider, { value: this, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorSelectionProvider, { editorActor: this.editor._internal.editorActor, children: this.props.children }) }) }) })\n    ] });\n  }\n  // Static API methods\n  static activeAnnotations = (editor) => editor && editor.editable ? editor.editable.activeAnnotations() : [];\n  static isAnnotationActive = (editor, annotationType) => editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1;\n  static addAnnotation = (editor, type, value) => editor.editable?.addAnnotation(type, value);\n  static blur = (editor) => {\n    debug$4(\"Host blurred\"), editor.editable?.blur();\n  };\n  static delete = (editor, selection, options) => editor.editable?.delete(selection, options);\n  static findDOMNode = (editor, element) => editor.editable?.findDOMNode(element);\n  static findByPath = (editor, path) => editor.editable?.findByPath(path) || [];\n  static focus = (editor) => {\n    debug$4(\"Host requesting focus\"), editor.editable?.focus();\n  };\n  static focusBlock = (editor) => editor.editable?.focusBlock();\n  static focusChild = (editor) => editor.editable?.focusChild();\n  static getSelection = (editor) => editor.editable ? editor.editable.getSelection() : null;\n  static getValue = (editor) => editor.editable?.getValue();\n  static hasBlockStyle = (editor, blockStyle) => editor.editable?.hasBlockStyle(blockStyle);\n  static hasListStyle = (editor, listStyle) => editor.editable?.hasListStyle(listStyle);\n  static isCollapsedSelection = (editor) => editor.editable?.isCollapsedSelection();\n  static isExpandedSelection = (editor) => editor.editable?.isExpandedSelection();\n  static isMarkActive = (editor, mark) => editor.editable?.isMarkActive(mark);\n  static insertChild = (editor, type, value) => (debug$4(\"Host inserting child\"), editor.editable?.insertChild(type, value));\n  static insertBlock = (editor, type, value) => editor.editable?.insertBlock(type, value);\n  static insertBreak = (editor) => editor.editable?.insertBreak();\n  static isVoid = (editor, element) => editor.editable?.isVoid(element);\n  static isObjectPath = (_editor, path) => {\n    if (!path || !Array.isArray(path)) return !1;\n    const isChildObjectEditPath = path.length > 3 && path[1] === \"children\";\n    return path.length > 1 && path[1] !== \"children\" || isChildObjectEditPath;\n  };\n  static marks = (editor) => editor.editable?.marks();\n  static select = (editor, selection) => {\n    debug$4(\"Host setting selection\", selection), editor.editable?.select(selection);\n  };\n  static removeAnnotation = (editor, type) => editor.editable?.removeAnnotation(type);\n  static toggleBlockStyle = (editor, blockStyle) => (debug$4(\"Host is toggling block style\"), editor.editable?.toggleBlockStyle(blockStyle));\n  static toggleList = (editor, listStyle) => editor.editable?.toggleList(listStyle);\n  static toggleMark = (editor, mark) => {\n    debug$4(\"Host toggling mark\", mark), editor.editable?.toggleMark(mark);\n  };\n  static getFragment = (editor) => (debug$4(\"Host getting fragment\"), editor.editable?.getFragment());\n  static undo = (editor) => {\n    debug$4(\"Host undoing\"), editor.editable?.undo();\n  };\n  static redo = (editor) => {\n    debug$4(\"Host redoing\"), editor.editable?.redo();\n  };\n  static isSelectionsOverlapping = (editor, selectionA, selectionB) => editor.editable?.isSelectionsOverlapping(selectionA, selectionB);\n}\nfunction RoutePatchesObservableToEditorActor(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(4);\n  let t0, t1;\n  return $[0] !== props.editorActor || $[1] !== props.patches$ ? (t0 = () => {\n    const subscription = props.patches$.subscribe((payload) => {\n      props.editorActor.send({\n        type: \"patches\",\n        ...payload\n      });\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [props.editorActor, props.patches$], $[0] = props.editorActor, $[1] = props.patches$, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t0, t1), null;\n}\nfunction RouteEventsToChanges(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6);\n  let t0;\n  $[0] !== props ? (t0 = (change) => props.onChange(change), $[0] = props, $[1] = t0) : t0 = $[1];\n  const handleChange = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_27__.useEffectEvent)(t0);\n  let t1, t2;\n  return $[2] !== handleChange || $[3] !== props.editorActor ? (t1 = () => {\n    debug$4(\"Subscribing to editor changes\");\n    const sub = props.editorActor.on(\"*\", (event) => {\n      bb5: switch (event.type) {\n        case \"patch\": {\n          handleChange(event);\n          break bb5;\n        }\n        case \"loading\": {\n          handleChange({\n            type: \"loading\",\n            isLoading: !0\n          });\n          break bb5;\n        }\n        case \"done loading\": {\n          handleChange({\n            type: \"loading\",\n            isLoading: !1\n          });\n          break bb5;\n        }\n        case \"focused\": {\n          handleChange({\n            type: \"focus\",\n            event: event.event\n          });\n          break bb5;\n        }\n        case \"value changed\": {\n          handleChange({\n            type: \"value\",\n            value: event.value\n          });\n          break bb5;\n        }\n        case \"invalid value\": {\n          handleChange({\n            type: \"invalidValue\",\n            resolution: event.resolution,\n            value: event.value\n          });\n          break bb5;\n        }\n        case \"error\": {\n          handleChange({\n            ...event,\n            level: \"warning\"\n          });\n          break bb5;\n        }\n        case \"annotation.add\":\n        case \"annotation.remove\":\n        case \"annotation.toggle\":\n        case \"focus\":\n        case \"patches\":\n        case \"readOnly toggled\":\n          break bb5;\n        default:\n          handleChange(event);\n      }\n    });\n    return () => {\n      debug$4(\"Unsubscribing to changes\"), sub.unsubscribe();\n    };\n  }, t2 = [props.editorActor, handleChange], $[2] = handleChange, $[3] = props.editorActor, $[4] = t1, $[5] = t2) : (t1 = $[4], t2 = $[5]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t1, t2), null;\n}\nconst debug$3 = debugWithName(\"components:Leaf\"), EMPTY_MARKS = [], Leaf = (props) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation\n  } = props, spanRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), portableTextEditor = usePortableTextEditor(), blockSelected = (0,slate_react__WEBPACK_IMPORTED_MODULE_19__.useSelected)(), [focused, setFocused] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1), [selected, setSelected] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1), block = children.props.parent, path = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => block ? [{\n    _key: block?._key\n  }, \"children\", {\n    _key: leaf._key\n  }] : [], [block, leaf._key]), decoratorValues = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => schemaTypes.decorators.map((dec) => dec.value), [schemaTypes.decorators]), marks = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__((leaf.marks || EMPTY_MARKS).filter((mark) => decoratorValues.includes(mark))), [decoratorValues, leaf.marks]), annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS, annotations = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => annotationMarks.map((mark_0) => !decoratorValues.includes(mark_0) && block?.markDefs?.find((def) => def._key === mark_0)).filter(Boolean), [annotationMarks, block, decoratorValues]), shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(!1);\n      return;\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor);\n    sel && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && (0,react__WEBPACK_IMPORTED_MODULE_4__.startTransition)(() => {\n      setFocused(!0);\n    });\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);\n  const setSelectedFromRange = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    debug$3(\"Setting selection and focus from range\");\n    const winSelection = window.getSelection();\n    if (!winSelection) {\n      setSelected(!1);\n      return;\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0);\n      spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);\n    } else\n      setSelected(!1);\n  }, [shouldTrackSelectionAndFocus]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    const onBlur = editorActor.on(\"blur\", () => {\n      setFocused(!1), setSelected(!1);\n    }), onFocus = editorActor.on(\"focus\", () => {\n      const sel_0 = PortableTextEditor.getSelection(portableTextEditor);\n      sel_0 && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(sel_0.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();\n    }), onSelection = editorActor.on(\"selection\", (event) => {\n      event.selection && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(event.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange();\n    });\n    return () => {\n      onBlur.unsubscribe(), onFocus.unsubscribe(), onSelection.unsubscribe();\n    };\n  }, [editorActor, path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => setSelectedFromRange(), [setSelectedFromRange]);\n  const content = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => {\n    let returnedChildren = children;\n    if (slate__WEBPACK_IMPORTED_MODULE_17__.Text.isText(leaf) && leaf._type === schemaTypes.span.name && (marks.forEach((mark_1) => {\n      const schemaType = schemaTypes.decorators.find((dec_0) => dec_0.value === mark_1);\n      if (schemaType && renderDecorator) {\n        const _props = Object.defineProperty({\n          children: returnedChildren,\n          editorElementRef: spanRef,\n          focused,\n          path,\n          selected,\n          schemaType,\n          value: mark_1\n        }, \"type\", {\n          enumerable: !1,\n          get() {\n            return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType;\n          }\n        });\n        returnedChildren = renderDecorator(_props);\n      }\n    }), block && annotations.length > 0 && annotations.forEach((annotation) => {\n      const schemaType_0 = schemaTypes.annotations.find((t) => t.name === annotation._type);\n      if (schemaType_0)\n        if (renderAnnotation) {\n          const _props_0 = Object.defineProperty({\n            block,\n            children: returnedChildren,\n            editorElementRef: spanRef,\n            focused,\n            path,\n            selected,\n            schemaType: schemaType_0,\n            value: annotation\n          }, \"type\", {\n            enumerable: !1,\n            get() {\n              return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType_0;\n            }\n          });\n          returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { ref: spanRef, children: renderAnnotation(_props_0) });\n        } else\n          returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultAnnotation, { annotation, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { ref: spanRef, children: returnedChildren }) });\n    }), block && renderChild)) {\n      const child = block.children.find((_child) => _child._key === leaf._key);\n      if (child) {\n        const _props_1 = Object.defineProperty({\n          annotations,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: returnedChildren }),\n          editorElementRef: spanRef,\n          focused,\n          path,\n          schemaType: schemaTypes.span,\n          selected,\n          value: child\n        }, \"type\", {\n          enumerable: !1,\n          get() {\n            return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.span;\n          }\n        });\n        returnedChildren = renderChild(_props_1);\n      }\n    }\n    return returnedChildren;\n  }, [annotations, block, children, focused, leaf, marks, path, renderAnnotation, renderChild, renderDecorator, schemaTypes.annotations, schemaTypes.decorators, schemaTypes.span, selected]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { ...attributes, ref: spanRef, children: content }, leaf._key), [leaf, attributes, content]);\n};\nLeaf.displayName = \"Leaf\";\nconst IS_MAC = typeof window < \"u\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent), modifiers = {\n  alt: \"altKey\",\n  control: \"ctrlKey\",\n  meta: \"metaKey\",\n  shift: \"shiftKey\"\n}, aliases = {\n  add: \"+\",\n  break: \"pause\",\n  cmd: \"meta\",\n  command: \"meta\",\n  ctl: \"control\",\n  ctrl: \"control\",\n  del: \"delete\",\n  down: \"arrowdown\",\n  esc: \"escape\",\n  ins: \"insert\",\n  left: \"arrowleft\",\n  mod: IS_MAC ? \"meta\" : \"control\",\n  opt: \"alt\",\n  option: \"alt\",\n  return: \"enter\",\n  right: \"arrowright\",\n  space: \" \",\n  spacebar: \" \",\n  up: \"arrowup\",\n  win: \"meta\",\n  windows: \"meta\"\n}, keyCodes = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  \" \": 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  \";\": 186,\n  \"=\": 187,\n  \",\": 188,\n  \"-\": 189,\n  \".\": 190,\n  \"/\": 191,\n  \"`\": 192,\n  \"[\": 219,\n  \"\\\\\": 220,\n  \"]\": 221,\n  \"'\": 222,\n  f1: 112,\n  f2: 113,\n  f3: 114,\n  f4: 115,\n  f5: 116,\n  f6: 117,\n  f7: 118,\n  f8: 119,\n  f9: 120,\n  f10: 121,\n  f11: 122,\n  f12: 123,\n  f13: 124,\n  f14: 125,\n  f15: 126,\n  f16: 127,\n  f17: 128,\n  f18: 129,\n  f19: 130,\n  f20: 131\n};\nfunction isHotkey(hotkey, event) {\n  return compareHotkey(parseHotkey(hotkey), event);\n}\nfunction parseHotkey(hotkey) {\n  const parsedHotkey = {\n    altKey: !1,\n    ctrlKey: !1,\n    metaKey: !1,\n    shiftKey: !1\n  }, hotkeySegments = hotkey.replace(\"++\", \"+add\").split(\"+\");\n  for (const rawHotkeySegment of hotkeySegments) {\n    const optional = rawHotkeySegment.endsWith(\"?\") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code = keyCodes[keyName];\n    if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code === void 0)\n      throw new TypeError(`Unknown modifier: \"${hotkeySegment}\"`);\n    (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);\n  }\n  return parsedHotkey;\n}\nfunction compareHotkey(parsedHotkey, event) {\n  return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;\n}\nfunction toKeyCode(name) {\n  const keyName = toKeyName(name);\n  return keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0);\n}\nfunction toKeyName(name) {\n  const keyName = name.toLowerCase();\n  return aliases[keyName] ?? keyName;\n}\nconst debug$2 = debugWithName(\"plugin:withHotKeys\"), DEFAULT_HOTKEYS = {\n  marks: {\n    \"mod+b\": \"strong\",\n    \"mod+i\": \"em\",\n    \"mod+u\": \"underline\",\n    \"mod+'\": \"code\"\n  },\n  custom: {}\n};\nfunction createWithHotkeys(editorActor, portableTextEditor, hotkeysFromOptions) {\n  const reservedHotkeys = [\"enter\", \"tab\", \"shift\", \"delete\", \"end\"], activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS;\n  return function(editor) {\n    return editor.pteWithHotKeys = (event) => {\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === \"marks\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault();\n              const possibleMark = activeHotkeys[cat];\n              if (possibleMark) {\n                const mark = possibleMark[hotkey];\n                debug$2(`HotKey ${hotkey} to toggle ${mark}`), editorActor.send({\n                  type: \"behavior event\",\n                  behaviorEvent: {\n                    type: \"decorator.toggle\",\n                    decorator: mark\n                  },\n                  editor\n                });\n              }\n            }\n          }\n        if (cat === \"custom\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat];\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey];\n                command(event, portableTextEditor);\n              }\n            }\n          }\n      });\n      const isEnter = isHotkey(\"enter\", event.nativeEvent), isTab = isHotkey(\"tab\", event.nativeEvent), isShiftEnter = isHotkey(\"shift+enter\", event.nativeEvent), isShiftTab = isHotkey(\"shift+tab\", event.nativeEvent), isArrowDown = isHotkey(\"down\", event.nativeEvent), isArrowUp = isHotkey(\"up\", event.nativeEvent);\n      if (isArrowDown && editor.selection) {\n        const focusBlock = slate__WEBPACK_IMPORTED_MODULE_17__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (focusBlock && slate__WEBPACK_IMPORTED_MODULE_17__.Editor.isVoid(editor, focusBlock)) {\n          const nextPath = slate__WEBPACK_IMPORTED_MODULE_17__.Path.next(editor.selection.focus.path.slice(0, 1));\n          if (!slate__WEBPACK_IMPORTED_MODULE_17__.Node.has(editor, nextPath)) {\n            slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n              decorators: []\n            }), {\n              at: nextPath\n            }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(editor, {\n              path: [...nextPath, 0],\n              offset: 0\n            }), editor.onChange();\n            return;\n          }\n        }\n      }\n      if (isArrowUp && editor.selection) {\n        const isFirstBlock = editor.selection.focus.path[0] === 0, focusBlock = slate__WEBPACK_IMPORTED_MODULE_17__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (isFirstBlock && focusBlock && slate__WEBPACK_IMPORTED_MODULE_17__.Editor.isVoid(editor, focusBlock)) {\n          slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n            decorators: []\n          }), {\n            at: [0]\n          }), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(editor, {\n            path: [0, 0],\n            offset: 0\n          }), editor.onChange();\n          return;\n        }\n      }\n      if ((isTab || isShiftTab) && editor.selection) {\n        const [focusChild] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, editor.selection.focus, {\n          depth: 2\n        }), [focusBlock] = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan)(focusChild) ? slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, editor.selection.focus, {\n          depth: 1\n        }) : [], hasAnnotationFocus = focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextTextBlock)(focusBlock) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan)(focusChild) && (focusChild.marks || []).filter((m) => (focusBlock.markDefs || []).map((def) => def._key).includes(m)).length > 0, [start] = slate__WEBPACK_IMPORTED_MODULE_17__.Range.edges(editor.selection), atStartOfNode = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.isStart(editor, start, start.path);\n        focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_15__.isPortableTextSpan)(focusChild) && (!hasAnnotationFocus || atStartOfNode) && editor.pteIncrementBlockLevels(isShiftTab) && event.preventDefault();\n      }\n      if (isEnter && !isShiftEnter && editor.selection) {\n        const focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = slate__WEBPACK_IMPORTED_MODULE_17__.Node.descendant(editor, focusBlockPath);\n        if (editor.isListBlock(focusBlock)) {\n          editor.pteEndList() && event.preventDefault();\n          return;\n        }\n      }\n    }, editor;\n  };\n}\nconst debug$1 = debugWithName(\"plugin:withInsertData\");\nfunction createWithInsertData(editorActor, schemaTypes) {\n  return function(editor) {\n    const blockTypeName = schemaTypes.block.name, spanTypeName = schemaTypes.span.name, whitespaceOnPasteMode = schemaTypes.block.options.unstable_whitespaceOnPasteMode, toPlainText = (blocks) => blocks.map((block) => editor.isTextBlock(block) ? block.children.map((child) => child._type === spanTypeName ? child.text : `[${schemaTypes.inlineObjects.find((t) => t.name === child._type)?.title || \"Object\"}]`).join(\"\") : `[${schemaTypes.blockObjects.find((t) => t.name === block._type)?.title || \"Object\"}]`).join(`\n\n`);\n    return editor.setFragmentData = (data, originEvent) => {\n      const {\n        selection\n      } = editor;\n      if (!selection)\n        return;\n      const [start, end] = slate__WEBPACK_IMPORTED_MODULE_17__.Range.edges(selection), startVoid = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.void(editor, {\n        at: start.path\n      }), endVoid = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.void(editor, {\n        at: end.path\n      });\n      if (slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed(selection) && !startVoid)\n        return;\n      const domRange = slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.toDOMRange(editor, selection);\n      let contents = domRange.cloneContents();\n      if (endVoid) {\n        const [voidNode] = endVoid, r = domRange.cloneRange(), domNode = slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.toDOMNode(editor, voidNode);\n        r.setEndAfter(domNode), contents = r.cloneContents();\n      }\n      Array.from(contents.querySelectorAll(\"[data-slate-zero-width]\")).forEach((zw) => {\n        const isNewline = zw.getAttribute(\"data-slate-zero-width\") === \"n\";\n        zw.textContent = isNewline ? `\n` : \"\";\n      }), Array.from(contents.querySelectorAll(\"*\")).forEach((elm) => {\n        elm.removeAttribute(\"contentEditable\"), elm.removeAttribute(\"data-slate-inline\"), elm.removeAttribute(\"data-slate-leaf\"), elm.removeAttribute(\"data-slate-node\"), elm.removeAttribute(\"data-slate-spacer\"), elm.removeAttribute(\"data-slate-string\"), elm.removeAttribute(\"data-slate-zero-width\"), elm.removeAttribute(\"draggable\");\n        for (const key in elm.attributes)\n          elm.hasAttribute(key) && elm.removeAttribute(key);\n      });\n      const div = contents.ownerDocument.createElement(\"div\");\n      div.appendChild(contents), div.setAttribute(\"hidden\", \"true\"), contents.ownerDocument.body.appendChild(div);\n      const asHTML = div.innerHTML;\n      contents.ownerDocument.body.removeChild(div);\n      const fragment = editor.getFragment(), portableText = fromSlateValue(fragment, blockTypeName), asJSON = JSON.stringify(portableText), asPlainText = toPlainText(portableText);\n      data.clearData(), data.setData(\"text/plain\", asPlainText), data.setData(\"text/html\", asHTML), data.setData(\"application/json\", asJSON), data.setData(\"application/x-portable-text\", asJSON), debug$1(\"text\", asPlainText), data.setData(\"application/x-portable-text-event-origin\", originEvent || \"external\"), debug$1(\"Set fragment data\", asJSON, asHTML);\n    }, editor.insertPortableTextData = (data) => {\n      if (!editor.selection)\n        return !1;\n      const pText = data.getData(\"application/x-portable-text\"), origin = data.getData(\"application/x-portable-text-event-origin\");\n      if (debug$1(`Inserting portable text from ${origin} event`, pText), pText) {\n        const parsed = JSON.parse(pText);\n        if (Array.isArray(parsed) && parsed.length > 0) {\n          const slateValue = _regenerateKeys(editor, toSlateValue(parsed, {\n            schemaTypes\n          }), editorActor.getSnapshot().context.keyGenerator, spanTypeName, schemaTypes), validation = validateValue(parsed, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n          if (!validation.valid && !validation.resolution?.autoResolve) {\n            const errorDescription = `${validation.resolution?.description}`;\n            return editorActor.send({\n              type: \"error\",\n              name: \"pasteError\",\n              description: errorDescription,\n              data: validation\n            }), debug$1(\"Invalid insert result\", validation), !1;\n          }\n          return _insertFragment(editor, slateValue, schemaTypes), !0;\n        }\n      }\n      return !1;\n    }, editor.insertTextOrHTMLData = (data) => {\n      if (!editor.selection)\n        return debug$1(\"No selection, not inserting\"), !1;\n      const html = data.getData(\"text/html\"), text = data.getData(\"text/plain\");\n      if (html || text) {\n        debug$1(\"Inserting data\", data);\n        let portableText, fragment, insertedType;\n        if (html) {\n          if (portableText = (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_28__.htmlToBlocks)(html, schemaTypes.portableText, {\n            unstable_whitespaceOnPasteMode: whitespaceOnPasteMode\n          }).map((block) => (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_28__.normalizeBlock)(block, {\n            blockTypeName\n          })), fragment = toSlateValue(portableText, {\n            schemaTypes\n          }), insertedType = \"HTML\", portableText.length === 0)\n            return !1;\n        } else {\n          const textToHtml = `<html><body>${escapeHtml(text).split(/\\n{2,}/).map((line) => line ? `<p>${line.replace(/(?:\\r\\n|\\r|\\n)/g, \"<br/>\")}</p>` : \"<p></p>\").join(\"\")}</body></html>`;\n          portableText = (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_28__.htmlToBlocks)(textToHtml, schemaTypes.portableText).map((block) => (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_28__.normalizeBlock)(block, {\n            blockTypeName\n          })), fragment = toSlateValue(portableText, {\n            schemaTypes\n          }), insertedType = \"text\";\n        }\n        const validation = validateValue(portableText, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n        if (!validation.valid) {\n          const errorDescription = `Could not validate the resulting portable text to insert.\n${validation.resolution?.description}\nTry to insert as plain text (shift-paste) instead.`;\n          return editorActor.send({\n            type: \"error\",\n            name: \"pasteError\",\n            description: errorDescription,\n            data: validation\n          }), debug$1(\"Invalid insert result\", validation), !1;\n        }\n        return debug$1(`Inserting ${insertedType} fragment at ${JSON.stringify(editor.selection)}`), _insertFragment(editor, fragment, schemaTypes), !0;\n      }\n      return !1;\n    }, editor.insertData = (data) => {\n      editor.insertPortableTextData(data) || editor.insertTextOrHTMLData(data);\n    }, editor.insertFragmentData = (data) => {\n      const fragment = data.getData(\"application/x-portable-text\");\n      if (fragment) {\n        const parsed = JSON.parse(fragment);\n        return editor.insertFragment(parsed), !0;\n      }\n      return !1;\n    }, editor;\n  };\n}\nconst entityMap = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#x60;\",\n  \"=\": \"&#x3D;\"\n};\nfunction escapeHtml(str) {\n  return String(str).replace(/[&<>\"'`=/]/g, (s) => entityMap[s]);\n}\nfunction _regenerateKeys(editor, fragment, keyGenerator, spanTypeName, editorTypes) {\n  return fragment.map((node) => {\n    const newNode = {\n      ...node\n    };\n    if (editor.isTextBlock(newNode)) {\n      const annotations = editorTypes.annotations.map((t) => t.name);\n      if (annotations.length === 0) {\n        const {\n          markDefs,\n          ...NewNodeNoDefs\n        } = newNode;\n        return {\n          ...NewNodeNoDefs,\n          _key: keyGenerator()\n        };\n      }\n      if ((newNode.markDefs || []).some((def) => !annotations.includes(def._type))) {\n        const allowedAnnotations = (newNode.markDefs || []).filter((def) => annotations.includes(def._type));\n        return {\n          ...newNode,\n          markDefs: allowedAnnotations,\n          _key: keyGenerator()\n        };\n      }\n      newNode.markDefs = (newNode.markDefs || []).map((def) => {\n        const oldKey = def._key, newKey = keyGenerator();\n        return newNode.children = newNode.children.map((child) => child._type === spanTypeName && editor.isTextSpan(child) ? {\n          ...child,\n          marks: child.marks && child.marks.includes(oldKey) ? [...child.marks].filter((mark) => mark !== oldKey).concat(newKey) : child.marks\n        } : child), {\n          ...def,\n          _key: newKey\n        };\n      });\n    }\n    const nodeWithNewKeys = {\n      ...newNode,\n      _key: keyGenerator()\n    };\n    return editor.isTextBlock(nodeWithNewKeys) && (nodeWithNewKeys.children = nodeWithNewKeys.children.map((child) => ({\n      ...child,\n      _key: keyGenerator()\n    }))), nodeWithNewKeys;\n  });\n}\nfunction _insertFragment(editor, fragment, schemaTypes) {\n  editor.withoutNormalizing(() => {\n    if (!editor.selection)\n      return;\n    const [focusBlock, focusPath] = slate__WEBPACK_IMPORTED_MODULE_17__.Editor.node(editor, editor.selection, {\n      depth: 1\n    });\n    if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {\n      const {\n        markDefs\n      } = focusBlock;\n      debug$1(\"Mixing markDefs of focusBlock and fragments[0] block\", markDefs, fragment[0].markDefs), lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(markDefs, fragment[0].markDefs) || slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.setNodes(editor, {\n        markDefs: lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__([...fragment[0].markDefs || [], ...markDefs || []])\n      }, {\n        at: focusPath,\n        mode: \"lowest\",\n        voids: !1\n      });\n    }\n    isEqualToEmptyEditor(editor.children, schemaTypes) ? (slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.splitNodes(editor, {\n      at: [0, 0]\n    }), editor.insertFragment(fragment), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.removeNodes(editor, {\n      at: [0]\n    })) : editor.insertFragment(fragment);\n  }), editor.onChange();\n}\nfunction withSyncRangeDecorations(slateEditor, syncRangeDecorations) {\n  const originalApply = slateEditor.apply;\n  return slateEditor.apply = (op) => {\n    originalApply(op), op.type !== \"set_selection\" && syncRangeDecorations(op);\n  }, () => {\n    slateEditor.apply = originalApply;\n  };\n}\nconst debug = debugWithName(\"component:Editable\"), PLACEHOLDER_STYLE = {\n  position: \"absolute\",\n  userSelect: \"none\",\n  pointerEvents: \"none\",\n  left: 0,\n  right: 0\n}, PortableTextEditable = (0,react__WEBPACK_IMPORTED_MODULE_4__.forwardRef)(function(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onClick,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props, portableTextEditor = usePortableTextEditor(), ref = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), [editableElement, setEditableElement] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(null), [hasInvalidValue, setHasInvalidValue] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1), [rangeDecorationState, setRangeDecorationsState] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useImperativeHandle)(forwardedRef, () => ref.current);\n  const rangeDecorationsRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(rangeDecorations), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(EditorActorContext), readOnly = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useSelector)(editorActor, (s) => s.context.readOnly), schemaTypes = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_21__.useSelector)(editorActor, (s_0) => s_0.context.schema), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_19__.useSlate)(), blockTypeName = schemaTypes.block.name;\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => {\n    const withInsertData = createWithInsertData(editorActor, schemaTypes);\n    if (readOnly)\n      return debug(\"Editable is in read only mode\"), withInsertData(slateEditor);\n    const withHotKeys = createWithHotkeys(editorActor, portableTextEditor, hotkeys);\n    return debug(\"Editable is in edit mode\"), withInsertData(withHotKeys(slateEditor));\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, schemaTypes, slateEditor]);\n  const renderElement = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((eProps) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Element, { ...eProps, readOnly, renderBlock, renderChild, renderListItem, renderStyle, schemaTypes, spellCheck }), [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]), renderLeaf = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((lProps) => {\n    if (lProps.leaf._type === \"span\") {\n      let rendered = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Leaf, { ...lProps, editorActor, schemaTypes, renderAnnotation, renderChild, renderDecorator, readOnly });\n      if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === \"\")\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: [\n          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: renderPlaceholder() }),\n          rendered\n        ] });\n      const decoration = lProps.leaf.rangeDecoration;\n      return decoration && (rendered = decoration.component({\n        children: rendered\n      })), rendered;\n    }\n    return lProps.children;\n  }, [editorActor, readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder, schemaTypes]), restoreSelectionFromProps = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`);\n      const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, blockTypeName));\n      if (normalizedSelection !== null) {\n        debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);\n        const slateRange = toSlateRange(normalizedSelection, slateEditor);\n        slateRange && (slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(slateEditor, slateRange), slateEditor.operations.some((o) => o.type === \"set_selection\") || editorActor.send({\n          type: \"selection\",\n          selection: normalizedSelection\n        }), slateEditor.onChange());\n      }\n    }\n  }, [blockTypeName, editorActor, propsSelection, slateEditor]), syncRangeDecorations = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((operation) => {\n    if (rangeDecorations && rangeDecorations.length > 0) {\n      const newSlateRanges = [];\n      if (rangeDecorations.forEach((rangeDecorationItem) => {\n        const slateRange_0 = toSlateRange(rangeDecorationItem.selection, slateEditor);\n        if (!slate__WEBPACK_IMPORTED_MODULE_17__.Range.isRange(slateRange_0)) {\n          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n            newSelection: null,\n            rangeDecoration: rangeDecorationItem,\n            origin: \"local\"\n          });\n          return;\n        }\n        let newRange;\n        if (operation && (newRange = moveRangeByOperation(slateRange_0, operation), newRange && newRange !== slateRange_0 || newRange === null && slateRange_0)) {\n          const value = PortableTextEditor.getValue(portableTextEditor), newRangeSelection = toPortableTextRange(value, newRange, schemaTypes);\n          rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n            newSelection: newRangeSelection,\n            rangeDecoration: rangeDecorationItem,\n            origin: \"local\"\n          });\n        }\n        newRange !== null && newSlateRanges.push({\n          ...newRange || slateRange_0,\n          rangeDecoration: rangeDecorationItem\n        });\n      }), newSlateRanges.length > 0) {\n        setRangeDecorationsState(newSlateRanges);\n        return;\n      }\n    }\n    setRangeDecorationsState((rangeDecorationState_0) => rangeDecorationState_0.length > 0 ? [] : rangeDecorationState_0);\n  }, [portableTextEditor, rangeDecorations, schemaTypes, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    const onReady = editorActor.on(\"ready\", () => {\n      restoreSelectionFromProps();\n    }), onInvalidValue = editorActor.on(\"invalid value\", () => {\n      setHasInvalidValue(!0);\n    }), onValueChanged = editorActor.on(\"value changed\", () => {\n      setHasInvalidValue(!1);\n    });\n    return () => {\n      onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();\n    };\n  }, [editorActor, restoreSelectionFromProps]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    propsSelection && !hasInvalidValue && restoreSelectionFromProps();\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);\n  const [syncedRangeDecorations, setSyncedRangeDecorations] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    syncedRangeDecorations || (setSyncedRangeDecorations(!0), syncRangeDecorations());\n  }, [syncRangeDecorations, syncedRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(rangeDecorations, rangeDecorationsRef.current) || syncRangeDecorations(), rangeDecorationsRef.current = rangeDecorations;\n  }, [rangeDecorations, syncRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    const teardown = withSyncRangeDecorations(slateEditor, syncRangeDecorations);\n    return () => teardown();\n  }, [slateEditor, syncRangeDecorations]);\n  const handleCopy = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event) => {\n    onCopy && onCopy(event) !== void 0 && event.preventDefault();\n  }, [onCopy]), handlePaste = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_0) => {\n    const value_0 = PortableTextEditor.getValue(portableTextEditor), path = toPortableTextRange(value_0, slateEditor.selection, schemaTypes)?.focus.path || [], onPasteResult = onPaste?.({\n      event: event_0,\n      value: value_0,\n      path,\n      schemaTypes\n    });\n    onPasteResult || !slateEditor.selection ? (event_0.preventDefault(), editorActor.send({\n      type: \"loading\"\n    }), Promise.resolve(onPasteResult).then((result_0) => {\n      debug(\"Custom paste function from client resolved\", result_0), !result_0 || !result_0.insert ? (debug(\"No result from custom paste handler, pasting normally\"), slateEditor.insertData(event_0.clipboardData)) : result_0.insert ? slateEditor.insertFragment(toSlateValue(result_0.insert, {\n        schemaTypes\n      })) : console.warn(\"Your onPaste function returned something unexpected:\", result_0);\n    }).catch((error) => (console.error(error), error)).finally(() => {\n      editorActor.send({\n        type: \"done loading\"\n      });\n    })) : event_0.nativeEvent.clipboardData && (event_0.preventDefault(), editorActor.send({\n      type: \"behavior event\",\n      behaviorEvent: {\n        type: \"paste\",\n        clipboardData: event_0.nativeEvent.clipboardData\n      },\n      editor: slateEditor\n    })), debug(\"No result from custom paste handler, pasting normally\");\n  }, [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor]), handleOnFocus = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_1) => {\n    if (onFocus && onFocus(event_1), !event_1.isDefaultPrevented()) {\n      const selection = PortableTextEditor.getSelection(portableTextEditor);\n      selection === null && (slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(slateEditor, slate__WEBPACK_IMPORTED_MODULE_17__.Editor.start(slateEditor, [])), slateEditor.onChange()), editorActor.send({\n        type: \"focused\",\n        event: event_1\n      });\n      const newSelection = PortableTextEditor.getSelection(portableTextEditor);\n      selection === newSelection && editorActor.send({\n        type: \"selection\",\n        selection\n      });\n    }\n  }, [editorActor, onFocus, portableTextEditor, slateEditor]), handleClick = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_2) => {\n    onClick && onClick(event_2);\n    const focusBlockPath = slateEditor.selection ? slateEditor.selection.focus.path.slice(0, 1) : void 0, focusBlock = focusBlockPath ? slate__WEBPACK_IMPORTED_MODULE_17__.Node.descendant(slateEditor, focusBlockPath) : void 0, [_, lastNodePath] = slate__WEBPACK_IMPORTED_MODULE_17__.Node.last(slateEditor, []), lastBlockPath = lastNodePath.slice(0, 1), lastNodeFocused = focusBlockPath ? slate__WEBPACK_IMPORTED_MODULE_17__.Path.equals(lastBlockPath, focusBlockPath) : !1, lastBlockIsVoid = focusBlock ? !slateEditor.isTextBlock(focusBlock) : !1;\n    slateEditor.selection && slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed(slateEditor.selection) && lastNodeFocused && lastBlockIsVoid && (slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n      decorators: []\n    })), slateEditor.onChange());\n  }, [onClick, slateEditor]), handleOnBlur = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_3) => {\n    onBlur && onBlur(event_3), event_3.isPropagationStopped() || editorActor.send({\n      type: \"blur\",\n      event: event_3\n    });\n  }, [editorActor, onBlur]), handleOnBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_4) => {\n    onBeforeInput && onBeforeInput(event_4);\n  }, [onBeforeInput]), validateSelection = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(() => {\n    if (!slateEditor.selection)\n      return;\n    const root = slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.findDocumentOrShadowRoot(slateEditor), {\n      activeElement\n    } = root;\n    if (ref.current !== activeElement)\n      return;\n    const domSelection = slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.getWindow(slateEditor).getSelection();\n    if (!domSelection || domSelection.rangeCount === 0)\n      return;\n    const existingDOMRange = domSelection.getRangeAt(0);\n    try {\n      const newDOMRange = slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.toDOMRange(slateEditor, slateEditor.selection);\n      (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug(\"DOM range out of sync, validating selection\"), domSelection?.removeAllRanges(), domSelection.addRange(newDOMRange));\n    } catch {\n      debug(\"Could not resolve selection, selecting top document\"), slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.deselect(slateEditor), slateEditor.children.length > 0 && slate__WEBPACK_IMPORTED_MODULE_17__.Transforms.select(slateEditor, [0, 0]), slateEditor.onChange();\n    }\n  }, [ref, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection);\n      return mutationObserver.observe(editableElement, {\n        attributeOldValue: !1,\n        attributes: !1,\n        characterData: !1,\n        childList: !0,\n        subtree: !0\n      }), () => {\n        mutationObserver.disconnect();\n      };\n    }\n  }, [validateSelection, editableElement]);\n  const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_5) => {\n    props.onKeyDown && props.onKeyDown(event_5), event_5.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_5);\n  }, [props, slateEditor]), scrollSelectionIntoViewToSlate = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(() => {\n    if (scrollSelectionIntoView !== void 0)\n      return scrollSelectionIntoView === null ? lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ : (_editor, domRange) => {\n        scrollSelectionIntoView(portableTextEditor, domRange);\n      };\n  }, [portableTextEditor, scrollSelectionIntoView]), decorate = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(([, path_0]) => {\n    if (isEqualToEmptyEditor(slateEditor.children, schemaTypes))\n      return [{\n        anchor: {\n          path: [0, 0],\n          offset: 0\n        },\n        focus: {\n          path: [0, 0],\n          offset: 0\n        },\n        placeholder: !0\n      }];\n    if (path_0.length === 0)\n      return [];\n    const result_1 = rangeDecorationState.filter((item) => slate__WEBPACK_IMPORTED_MODULE_17__.Range.isCollapsed(item) ? path_0.length !== 2 ? !1 : slate__WEBPACK_IMPORTED_MODULE_17__.Path.equals(item.focus.path, path_0) && slate__WEBPACK_IMPORTED_MODULE_17__.Path.equals(item.anchor.path, path_0) : slate__WEBPACK_IMPORTED_MODULE_17__.Range.intersection(item, {\n      anchor: {\n        path: path_0,\n        offset: 0\n      },\n      focus: {\n        path: path_0,\n        offset: 0\n      }\n    }) || slate__WEBPACK_IMPORTED_MODULE_17__.Range.includes(item, path_0));\n    return result_1.length > 0 ? result_1 : [];\n  }, [slateEditor, schemaTypes, rangeDecorationState]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(() => {\n    ref.current = slate_react__WEBPACK_IMPORTED_MODULE_19__.ReactEditor.toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);\n  }, [slateEditor, ref]), portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    slate_react__WEBPACK_IMPORTED_MODULE_19__.Editable,\n    {\n      ...restProps,\n      autoFocus: !1,\n      className: restProps.className || \"pt-editable\",\n      decorate,\n      onBlur: handleOnBlur,\n      onCopy: handleCopy,\n      onClick: handleClick,\n      onDOMBeforeInput: handleOnBeforeInput,\n      onFocus: handleOnFocus,\n      onKeyDown: handleKeyDown,\n      onPaste: handlePaste,\n      readOnly,\n      renderPlaceholder: void 0,\n      renderElement,\n      renderLeaf,\n      scrollSelectionIntoView: scrollSelectionIntoViewToSlate\n    }\n  ) : null;\n});\nPortableTextEditable.displayName = \"ForwardRef(PortableTextEditable)\";\nconst EditorContext = react__WEBPACK_IMPORTED_MODULE_4__.createContext(void 0);\nfunction EditorProvider(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(30), editor = useEditor(props.config), editorActor = editor._internal.editorActor, slateEditor = editor._internal.slateEditor, editable = editor.editable;\n  let t0, t1;\n  $[0] !== editor ? (t1 = new PortableTextEditor({\n    editor\n  }), $[0] = editor, $[1] = t1) : t1 = $[1], t0 = t1;\n  const portableTextEditor = t0;\n  let t2;\n  $[2] !== portableTextEditor.change$ ? (t2 = (change) => {\n    portableTextEditor.change$.next(change);\n  }, $[2] = portableTextEditor.change$, $[3] = t2) : t2 = $[3];\n  let t3;\n  $[4] !== editorActor || $[5] !== t2 ? (t3 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RouteEventsToChanges, { editorActor, onChange: t2 }), $[4] = editorActor, $[5] = t2, $[6] = t3) : t3 = $[6];\n  let t4;\n  $[7] !== editable.getValue || $[8] !== editorActor || $[9] !== portableTextEditor || $[10] !== slateEditor.instance ? (t4 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Synchronizer, { editorActor, getValue: editable.getValue, portableTextEditor, slateEditor: slateEditor.instance }), $[7] = editable.getValue, $[8] = editorActor, $[9] = portableTextEditor, $[10] = slateEditor.instance, $[11] = t4) : t4 = $[11];\n  let t5;\n  $[12] !== editorActor || $[13] !== props.children ? (t5 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorSelectionProvider, { editorActor, children: props.children }), $[12] = editorActor, $[13] = props.children, $[14] = t5) : t5 = $[14];\n  let t6;\n  $[15] !== portableTextEditor || $[16] !== t5 ? (t6 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorContext.Provider, { value: portableTextEditor, children: t5 }), $[15] = portableTextEditor, $[16] = t5, $[17] = t6) : t6 = $[17];\n  let t7;\n  $[18] !== slateEditor.initialValue || $[19] !== slateEditor.instance || $[20] !== t6 ? (t7 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_19__.Slate, { editor: slateEditor.instance, initialValue: slateEditor.initialValue, children: t6 }), $[18] = slateEditor.initialValue, $[19] = slateEditor.instance, $[20] = t6, $[21] = t7) : t7 = $[21];\n  let t8;\n  $[22] !== editorActor || $[23] !== t7 ? (t8 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorActorContext.Provider, { value: editorActor, children: t7 }), $[22] = editorActor, $[23] = t7, $[24] = t8) : t8 = $[24];\n  let t9;\n  return $[25] !== editor || $[26] !== t3 || $[27] !== t4 || $[28] !== t8 ? (t9 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(EditorContext.Provider, { value: editor, children: [\n    t3,\n    t4,\n    t8\n  ] }), $[25] = editor, $[26] = t3, $[27] = t4, $[28] = t8, $[29] = t9) : t9 = $[29], t9;\n}\nfunction useEditorContext() {\n  const editor = react__WEBPACK_IMPORTED_MODULE_4__.useContext(EditorContext);\n  if (!editor)\n    throw new Error(\"No Editor set. Use EditorProvider to set one.\");\n  return editor;\n}\nfunction EditorEventListener(props) {\n  const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(4), editor = useEditorContext(), on = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_27__.useEffectEvent)(props.on);\n  let t0, t1;\n  return $[0] !== editor || $[1] !== on ? (t0 = () => {\n    const subscription = editor.on(\"*\", on);\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, t1 = [editor, on], $[0] = editor, $[1] = on, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t0, t1), null;\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0s7QUFDNUg7QUFDQztBQUNlO0FBQ0M7QUFDakI7QUFDTjtBQUN1STtBQUNjO0FBQzFFO0FBQ2pGO0FBQ2U7QUFDQTtBQUNUO0FBQ0g7QUFDbUI7QUFDUjtBQUNBO0FBQzZFO0FBQy9FO0FBQ1k7QUFDQTtBQUNtQztBQUN2RDtBQUNnQjtBQUNWO0FBQzZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUVBQXVCO0FBQzlDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVFQUF1QjtBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNERBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrRUFBb0I7QUFDM0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkNBQTJDLDREQUFZLG9GQUFvRiw0REFBWTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJDQUEyQyw0REFBWSxzRkFBc0YsNERBQVk7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4REFBOEQsc0RBQUcseUJBQXlCLDJCQUEyQjtBQUNySDtBQUNBLDhJQUE4SSxzREFBRyxpQkFBaUIsaUdBQWlHO0FBQ25RO0FBQ0EsNEVBQTRFLHNEQUFHLHdDQUF3Qyx1Q0FBdUM7QUFDOUo7QUFDQSx1RUFBdUUsc0RBQUcsdUNBQXVDLHlDQUF5QztBQUMxSjtBQUNBLCtHQUErRyxzREFBRyxDQUFDLCtDQUFLLElBQUksb0ZBQW9GO0FBQ2hOO0FBQ0EsZ0VBQWdFLHNEQUFHLGdDQUFnQyxrQ0FBa0M7QUFDckk7QUFDQSxrR0FBa0csdURBQUksMkJBQTJCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLDZDQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBQyx1Q0FBdUMsaUVBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywrRkFBK0YsZ0RBQVM7QUFDM0c7QUFrQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9saWIvaW5kZXgubWpzP2Y4ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNLZXlTZWdtZW50LCBpc1BvcnRhYmxlVGV4dFRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRTcGFuIGFzIGlzUG9ydGFibGVUZXh0U3BhbiQxLCBkZWZpbmVUeXBlLCBkZWZpbmVGaWVsZCwgaXNQb3J0YWJsZVRleHRMaXN0QmxvY2sgfSBmcm9tIFwiQHNhbml0eS90eXBlc1wiO1xuaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSBcIkBzYW5pdHkvc2NoZW1hXCI7XG5pbXBvcnQgc3RhcnRDYXNlIGZyb20gXCJsb2Rhc2guc3RhcnRjYXNlXCI7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyB1c2VTZWxlY3RvciwgdXNlQWN0b3JSZWYgfSBmcm9tIFwiQHhzdGF0ZS9yZWFjdFwiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcImxvZGFzaC9pc0VxdWFsLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwibG9kYXNoL25vb3AuanNcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZU1lbW8sIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUNhbGxiYWNrLCBzdGFydFRyYW5zaXRpb24sIENvbXBvbmVudCwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgRWRpdG9yLCBFbGVtZW50IGFzIEVsZW1lbnQkMSwgUmFuZ2UsIFBvaW50LCBUZXh0LCBQYXRoLCBUcmFuc2Zvcm1zLCBPcGVyYXRpb24sIE5vZGUsIGNyZWF0ZUVkaXRvciBhcyBjcmVhdGVFZGl0b3IkMSwgZGVsZXRlQmFja3dhcmQsIGRlbGV0ZUZvcndhcmQsIGluc2VydFRleHQgfSBmcm9tIFwic2xhdGVcIjtcbmltcG9ydCB7IHVzZVNsYXRlU3RhdGljLCBSZWFjdEVkaXRvciwgdXNlU2VsZWN0ZWQsIHdpdGhSZWFjdCwgU2xhdGUsIHVzZVNsYXRlLCBFZGl0YWJsZSB9IGZyb20gXCJzbGF0ZS1yZWFjdFwiO1xuaW1wb3J0IGRlYnVnJG0gZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBjIH0gZnJvbSBcInJlYWN0LWNvbXBpbGVyLXJ1bnRpbWVcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xuaW1wb3J0IHVuaXEgZnJvbSBcImxvZGFzaC91bmlxLmpzXCI7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IHVzZUVmZmVjdEV2ZW50IH0gZnJvbSBcInVzZS1lZmZlY3QtZXZlbnRcIjtcbmltcG9ydCB0aHJvdHRsZSBmcm9tIFwibG9kYXNoL3Rocm90dGxlLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcImxvZGFzaC9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IHsgdW5zZXQsIHNldCwgc2V0SWZNaXNzaW5nLCBpbnNlcnQsIGRpZmZNYXRjaFBhdGNoIGFzIGRpZmZNYXRjaFBhdGNoJDEsIGFwcGx5QWxsIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvcGF0Y2hlc1wiO1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSBcImxvZGFzaC9mbGF0dGVuLmpzXCI7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tIFwibG9kYXNoL2lzUGxhaW5PYmplY3QuanNcIjtcbmltcG9ydCBnZXRSYW5kb21WYWx1ZXMgZnJvbSBcImdldC1yYW5kb20tdmFsdWVzLWVzbVwiO1xuaW1wb3J0IHsgc2V0dXAsIGFzc2lnbiwgYXNzZXJ0RXZlbnQsIGVtaXQsIGVucXVldWVBY3Rpb25zLCBjcmVhdGVBY3RvciB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCBnZXQgZnJvbSBcImxvZGFzaC9nZXQuanNcIjtcbmltcG9ydCBpc1VuZGVmaW5lZCBmcm9tIFwibG9kYXNoL2lzVW5kZWZpbmVkLmpzXCI7XG5pbXBvcnQgb21pdEJ5IGZyb20gXCJsb2Rhc2gvb21pdEJ5LmpzXCI7XG5pbXBvcnQgeyBodG1sVG9CbG9ja3MsIG5vcm1hbGl6ZUJsb2NrIH0gZnJvbSBcIkBzYW5pdHkvYmxvY2stdG9vbHNcIjtcbmZ1bmN0aW9uIGRlZmluZUJlaGF2aW9yKGJlaGF2aW9yKSB7XG4gIHJldHVybiBiZWhhdmlvcjtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpIHtcbiAgcmV0dXJuIGNvbnRleHQuc2VsZWN0aW9uPy5hbmNob3IucGF0aC5qb2luKCkgPT09IGNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5wYXRoLmpvaW4oKSAmJiBjb250ZXh0LnNlbGVjdGlvbj8uYW5jaG9yLm9mZnNldCA9PT0gY29udGV4dC5zZWxlY3Rpb24/LmZvY3VzLm9mZnNldDtcbn1cbmZ1bmN0aW9uIGdldEZvY3VzQmxvY2soY29udGV4dCkge1xuICBjb25zdCBrZXkgPSBjb250ZXh0LnNlbGVjdGlvbiAmJiBpc0tleVNlZ21lbnQoY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIG5vZGUgPSBrZXkgPyBjb250ZXh0LnZhbHVlLmZpbmQoKGJsb2NrKSA9PiBibG9jay5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSAmJiBrZXkgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleToga2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldEZvY3VzVGV4dEJsb2NrKGNvbnRleHQpIHtcbiAgY29uc3QgZm9jdXNCbG9jayA9IGdldEZvY3VzQmxvY2soY29udGV4dCk7XG4gIHJldHVybiBmb2N1c0Jsb2NrICYmIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGZvY3VzQmxvY2subm9kZSkgPyB7XG4gICAgbm9kZTogZm9jdXNCbG9jay5ub2RlLFxuICAgIHBhdGg6IGZvY3VzQmxvY2sucGF0aFxuICB9IDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0Rm9jdXNCbG9ja09iamVjdChjb250ZXh0KSB7XG4gIGNvbnN0IGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKGNvbnRleHQpO1xuICByZXR1cm4gZm9jdXNCbG9jayAmJiAhaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soZm9jdXNCbG9jay5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0Jsb2NrLm5vZGUsXG4gICAgcGF0aDogZm9jdXNCbG9jay5wYXRoXG4gIH0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRGb2N1c0NoaWxkKGNvbnRleHQpIHtcbiAgY29uc3QgZm9jdXNCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKGNvbnRleHQpO1xuICBpZiAoIWZvY3VzQmxvY2spXG4gICAgcmV0dXJuO1xuICBjb25zdCBrZXkgPSBjb250ZXh0LnNlbGVjdGlvbiAmJiBpc0tleVNlZ21lbnQoY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFsyXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzJdLl9rZXkgOiB2b2lkIDAsIG5vZGUgPSBrZXkgPyBmb2N1c0Jsb2NrLm5vZGUuY2hpbGRyZW4uZmluZCgoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSAmJiBrZXkgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbLi4uZm9jdXNCbG9jay5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgIF9rZXk6IGtleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRGb2N1c1NwYW4oY29udGV4dCkge1xuICBjb25zdCBmb2N1c0NoaWxkID0gZ2V0Rm9jdXNDaGlsZChjb250ZXh0KTtcbiAgcmV0dXJuIGZvY3VzQ2hpbGQgJiYgaXNQb3J0YWJsZVRleHRTcGFuJDEoZm9jdXNDaGlsZC5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0NoaWxkLm5vZGUsXG4gICAgcGF0aDogZm9jdXNDaGlsZC5wYXRoXG4gIH0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25TdGFydEJsb2NrKGNvbnRleHQpIHtcbiAgY29uc3Qga2V5ID0gY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyBpc0tleVNlZ21lbnQoY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdLl9rZXkgOiB2b2lkIDAgOiBpc0tleVNlZ21lbnQoY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0pID8gY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgbm9kZSA9IGtleSA/IGNvbnRleHQudmFsdWUuZmluZCgoYmxvY2spID0+IGJsb2NrLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIHJldHVybiBub2RlICYmIGtleSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBrZXlcbiAgICB9XVxuICB9IDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uRW5kQmxvY2soY29udGV4dCkge1xuICBjb25zdCBrZXkgPSBjb250ZXh0LnNlbGVjdGlvbi5iYWNrd2FyZCA/IGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5IDogdm9pZCAwIDogaXNLZXlTZWdtZW50KGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwLCBub2RlID0ga2V5ID8gY29udGV4dC52YWx1ZS5maW5kKChibG9jaykgPT4gYmxvY2suX2tleSA9PT0ga2V5KSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5vZGUgJiYga2V5ID8ge1xuICAgIG5vZGUsXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IGtleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c0Jsb2NrKGNvbnRleHQpIHtcbiAgbGV0IHByZXZpb3VzQmxvY2s7XG4gIGNvbnN0IHNlbGVjdGlvblN0YXJ0QmxvY2sgPSBnZXRTZWxlY3Rpb25TdGFydEJsb2NrKGNvbnRleHQpO1xuICBpZiAoIXNlbGVjdGlvblN0YXJ0QmxvY2spXG4gICAgcmV0dXJuO1xuICBsZXQgZm91bmRTZWxlY3Rpb25TdGFydEJsb2NrID0gITE7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgY29udGV4dC52YWx1ZSkge1xuICAgIGlmIChibG9jay5fa2V5ID09PSBzZWxlY3Rpb25TdGFydEJsb2NrLm5vZGUuX2tleSkge1xuICAgICAgZm91bmRTZWxlY3Rpb25TdGFydEJsb2NrID0gITA7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldmlvdXNCbG9jayA9IHtcbiAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgcGF0aDogW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV1cbiAgICB9O1xuICB9XG4gIGlmIChmb3VuZFNlbGVjdGlvblN0YXJ0QmxvY2sgJiYgcHJldmlvdXNCbG9jaylcbiAgICByZXR1cm4gcHJldmlvdXNCbG9jaztcbn1cbmZ1bmN0aW9uIGdldE5leHRCbG9jayhjb250ZXh0KSB7XG4gIGxldCBuZXh0QmxvY2s7XG4gIGNvbnN0IHNlbGVjdGlvbkVuZEJsb2NrID0gZ2V0U2VsZWN0aW9uRW5kQmxvY2soY29udGV4dCk7XG4gIGlmICghc2VsZWN0aW9uRW5kQmxvY2spXG4gICAgcmV0dXJuO1xuICBsZXQgZm91bmRTZWxlY3Rpb25FbmRCbG9jayA9ICExO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGNvbnRleHQudmFsdWUpIHtcbiAgICBpZiAoYmxvY2suX2tleSA9PT0gc2VsZWN0aW9uRW5kQmxvY2subm9kZS5fa2V5KSB7XG4gICAgICBmb3VuZFNlbGVjdGlvbkVuZEJsb2NrID0gITA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZvdW5kU2VsZWN0aW9uRW5kQmxvY2spIHtcbiAgICAgIG5leHRCbG9jayA9IHtcbiAgICAgICAgbm9kZTogYmxvY2ssXG4gICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoZm91bmRTZWxlY3Rpb25FbmRCbG9jayAmJiBuZXh0QmxvY2spXG4gICAgcmV0dXJuIG5leHRCbG9jaztcbn1cbmZ1bmN0aW9uIGlzRW1wdHlUZXh0QmxvY2soYmxvY2spIHtcbiAgaWYgKCFpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhibG9jaykpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBvbmx5VGV4dCA9IGJsb2NrLmNoaWxkcmVuLmV2ZXJ5KGlzUG9ydGFibGVUZXh0U3BhbiQxKSwgYmxvY2tUZXh0ID0gZ2V0VGV4dEJsb2NrVGV4dChibG9jayk7XG4gIHJldHVybiBvbmx5VGV4dCAmJiBibG9ja1RleHQgPT09IFwiXCI7XG59XG5mdW5jdGlvbiBnZXRUZXh0QmxvY2tUZXh0KGJsb2NrKSB7XG4gIHJldHVybiBibG9jay5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC50ZXh0ID8/IFwiXCIpLmpvaW4oXCJcIik7XG59XG5jb25zdCBicmVha2luZ0Jsb2NrT2JqZWN0ID0ge1xuICBvbjogXCJpbnNlcnQgYnJlYWtcIixcbiAgZ3VhcmQ6ICh7XG4gICAgY29udGV4dFxuICB9KSA9PiAhIWdldEZvY3VzQmxvY2tPYmplY3QoY29udGV4dCksXG4gIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgIHR5cGU6IFwiaW5zZXJ0IHRleHQgYmxvY2tcIixcbiAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICB9XV1cbn0sIGRlbGV0aW5nRW1wdHlUZXh0QmxvY2tBZnRlckJsb2NrT2JqZWN0ID0ge1xuICBvbjogXCJkZWxldGUgYmFja3dhcmRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgY29udGV4dFxuICB9KSA9PiB7XG4gICAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhjb250ZXh0KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQoY29udGV4dCksIHByZXZpb3VzQmxvY2sgPSBnZXRQcmV2aW91c0Jsb2NrKGNvbnRleHQpO1xuICAgIHJldHVybiAhZm9jdXNUZXh0QmxvY2sgfHwgIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhcHJldmlvdXNCbG9jayA/ICExIDogaXNFbXB0eVRleHRCbG9jayhmb2N1c1RleHRCbG9jay5ub2RlKSAmJiAhaXNQb3J0YWJsZVRleHRUZXh0QmxvY2socHJldmlvdXNCbG9jay5ub2RlKSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgcHJldmlvdXNCbG9ja1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgcHJldmlvdXNCbG9ja1xuICB9KSA9PiBbe1xuICAgIHR5cGU6IFwiZGVsZXRlIGJsb2NrXCIsXG4gICAgYmxvY2tQYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0sIHtcbiAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgIHNlbGVjdGlvbjoge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IHByZXZpb3VzQmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogcHJldmlvdXNCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9XG4gIH1dXVxufSwgZGVsZXRpbmdFbXB0eVRleHRCbG9ja0JlZm9yZUJsb2NrT2JqZWN0ID0ge1xuICBvbjogXCJkZWxldGUgZm9yd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKGNvbnRleHQpLCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBzZWxlY3Rpb25Jc0NvbGxhcHNlZChjb250ZXh0KSwgbmV4dEJsb2NrID0gZ2V0TmV4dEJsb2NrKGNvbnRleHQpO1xuICAgIHJldHVybiAhZm9jdXNUZXh0QmxvY2sgfHwgIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhbmV4dEJsb2NrID8gITEgOiBpc0VtcHR5VGV4dEJsb2NrKGZvY3VzVGV4dEJsb2NrLm5vZGUpICYmICFpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhuZXh0QmxvY2subm9kZSkgPyB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIG5leHRCbG9ja1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgbmV4dEJsb2NrXG4gIH0pID0+IFt7XG4gICAgdHlwZTogXCJkZWxldGUgYmxvY2tcIixcbiAgICBibG9ja1BhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgfSwge1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgc2VsZWN0aW9uOiB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogbmV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IG5leHRCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9XG4gIH1dXVxufSwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzID0ge1xuICBicmVha2luZ0Jsb2NrT2JqZWN0LFxuICBkZWxldGluZ0VtcHR5VGV4dEJsb2NrQWZ0ZXJCbG9ja09iamVjdCxcbiAgZGVsZXRpbmdFbXB0eVRleHRCbG9ja0JlZm9yZUJsb2NrT2JqZWN0XG59LCBkZWNvcmF0b3JBZGQgPSB7XG4gIG9uOiBcImRlY29yYXRvci5hZGRcIixcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW3tcbiAgICB0eXBlOiBcImRlY29yYXRvci5hZGRcIixcbiAgICBkZWNvcmF0b3I6IGV2ZW50LmRlY29yYXRvclxuICB9LCB7XG4gICAgdHlwZTogXCJyZXNlbGVjdFwiXG4gIH1dXVxufSwgZGVjb3JhdG9yUmVtb3ZlID0ge1xuICBvbjogXCJkZWNvcmF0b3IucmVtb3ZlXCIsXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFt7XG4gICAgdHlwZTogXCJkZWNvcmF0b3IucmVtb3ZlXCIsXG4gICAgZGVjb3JhdG9yOiBldmVudC5kZWNvcmF0b3JcbiAgfSwge1xuICAgIHR5cGU6IFwicmVzZWxlY3RcIlxuICB9XV1cbn0sIGRlY29yYXRvclRvZ2dsZSA9IHtcbiAgb246IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbe1xuICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgIGRlY29yYXRvcjogZXZlbnQuZGVjb3JhdG9yXG4gIH0sIHtcbiAgICB0eXBlOiBcInJlc2VsZWN0XCJcbiAgfV1dXG59LCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzID0ge1xuICBkZWNvcmF0b3JBZGQsXG4gIGRlY29yYXRvclJlbW92ZSxcbiAgZGVjb3JhdG9yVG9nZ2xlXG59LCBjbGVhckxpc3RPbkJhY2tzcGFjZSA9IHtcbiAgb246IFwiZGVsZXRlIGJhY2t3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIGNvbnRleHRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKGNvbnRleHQpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oY29udGV4dCk7XG4gICAgcmV0dXJuICFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFmb2N1c1NwYW4gPyAhMSA6IGZvY3VzVGV4dEJsb2NrLm5vZGUuY2hpbGRyZW5bMF0uX2tleSA9PT0gZm9jdXNTcGFuLm5vZGUuX2tleSAmJiBjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgPT09IDAgJiYgZm9jdXNUZXh0QmxvY2subm9kZS5sZXZlbCA9PT0gMSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9ja1xuICB9KSA9PiBbe1xuICAgIHR5cGU6IFwidW5zZXQgYmxvY2tcIixcbiAgICBwcm9wczogW1wibGlzdEl0ZW1cIiwgXCJsZXZlbFwiXSxcbiAgICBwYXRoczogW2ZvY3VzVGV4dEJsb2NrLnBhdGhdXG4gIH1dXVxufSwgdW5pbmRlbnRMaXN0T25CYWNrc3BhY2UgPSB7XG4gIG9uOiBcImRlbGV0ZSBiYWNrd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBzZWxlY3Rpb25Jc0NvbGxhcHNlZChjb250ZXh0KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhjb250ZXh0KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKGNvbnRleHQpO1xuICAgIHJldHVybiAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFmb2N1c1RleHRCbG9jayB8fCAhZm9jdXNTcGFuID8gITEgOiBmb2N1c1RleHRCbG9jay5ub2RlLmNoaWxkcmVuWzBdLl9rZXkgPT09IGZvY3VzU3Bhbi5ub2RlLl9rZXkgJiYgY29udGV4dC5zZWxlY3Rpb24uZm9jdXMub2Zmc2V0ID09PSAwICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWwgIT09IHZvaWQgMCAmJiBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsID4gMSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgbGV2ZWw6IGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWwgLSAxXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9jayxcbiAgICBsZXZlbFxuICB9KSA9PiBbe1xuICAgIHR5cGU6IFwic2V0IGJsb2NrXCIsXG4gICAgbGV2ZWwsXG4gICAgcGF0aHM6IFtmb2N1c1RleHRCbG9jay5wYXRoXVxuICB9XV1cbn0sIGNvcmVMaXN0QmVoYXZpb3JzID0ge1xuICBjbGVhckxpc3RPbkJhY2tzcGFjZSxcbiAgdW5pbmRlbnRMaXN0T25CYWNrc3BhY2Vcbn0sIHNvZnRSZXR1cm4gPSB7XG4gIG9uOiBcImluc2VydCBzb2Z0IGJyZWFrXCIsXG4gIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgIHR5cGU6IFwiaW5zZXJ0IHRleHRcIixcbiAgICB0ZXh0OiBgXG5gXG4gIH1dXVxufSwgY29yZUJlaGF2aW9ycyA9IFtzb2Z0UmV0dXJuLCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzLmRlY29yYXRvckFkZCwgY29yZURlY29yYXRvckJlaGF2aW9ycy5kZWNvcmF0b3JSZW1vdmUsIGNvcmVEZWNvcmF0b3JCZWhhdmlvcnMuZGVjb3JhdG9yVG9nZ2xlLCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuYnJlYWtpbmdCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmRlbGV0aW5nRW1wdHlUZXh0QmxvY2tBZnRlckJsb2NrT2JqZWN0LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuZGVsZXRpbmdFbXB0eVRleHRCbG9ja0JlZm9yZUJsb2NrT2JqZWN0LCBjb3JlTGlzdEJlaGF2aW9ycy5jbGVhckxpc3RPbkJhY2tzcGFjZSwgY29yZUxpc3RCZWhhdmlvcnMudW5pbmRlbnRMaXN0T25CYWNrc3BhY2VdLCBjb3JlQmVoYXZpb3IgPSB7XG4gIHNvZnRSZXR1cm4sXG4gIGRlY29yYXRvcnM6IGNvcmVEZWNvcmF0b3JCZWhhdmlvcnMsXG4gIGJsb2NrT2JqZWN0czogY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLFxuICBsaXN0czogY29yZUxpc3RCZWhhdmlvcnNcbn07XG5mdW5jdGlvbiBjcmVhdGVMaW5rQmVoYXZpb3JzKGNvbmZpZykge1xuICBjb25zdCBwYXN0ZUxpbmtPblNlbGVjdGlvbiA9IHtcbiAgICBvbjogXCJwYXN0ZVwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQoY29udGV4dCksIHRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpLCB1cmwgPSBsb29rc0xpa2VVcmwodGV4dCkgPyB0ZXh0IDogdm9pZCAwLCBhbm5vdGF0aW9uID0gdXJsICE9PSB2b2lkIDAgPyBjb25maWcubGlua0Fubm90YXRpb24/Lih7XG4gICAgICAgIHVybCxcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gYW5ub3RhdGlvbiAmJiAhc2VsZWN0aW9uQ29sbGFwc2VkID8ge1xuICAgICAgICBhbm5vdGF0aW9uXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIGFubm90YXRpb25cbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJhbm5vdGF0aW9uLmFkZFwiLFxuICAgICAgYW5ub3RhdGlvblxuICAgIH1dXVxuICB9LCBwYXN0ZUxpbmtBdENhcmV0ID0ge1xuICAgIG9uOiBcInBhc3RlXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oY29udGV4dCksIHNlbGVjdGlvbkNvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpO1xuICAgICAgaWYgKCFmb2N1c1NwYW4gfHwgIXNlbGVjdGlvbkNvbGxhcHNlZClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgdGV4dCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIiksIHVybCA9IGxvb2tzTGlrZVVybCh0ZXh0KSA/IHRleHQgOiB2b2lkIDAsIGFubm90YXRpb24gPSB1cmwgIT09IHZvaWQgMCA/IGNvbmZpZy5saW5rQW5ub3RhdGlvbj8uKHtcbiAgICAgICAgdXJsLFxuICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hXG4gICAgICB9KSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB1cmwgJiYgYW5ub3RhdGlvbiAmJiBzZWxlY3Rpb25Db2xsYXBzZWQgPyB7XG4gICAgICAgIGZvY3VzU3BhbixcbiAgICAgICAgYW5ub3RhdGlvbixcbiAgICAgICAgdXJsXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIGFubm90YXRpb24sXG4gICAgICB1cmxcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQgc3BhblwiLFxuICAgICAgdGV4dDogdXJsLFxuICAgICAgYW5ub3RhdGlvbnM6IFthbm5vdGF0aW9uXVxuICAgIH1dXVxuICB9O1xuICByZXR1cm4gW3Bhc3RlTGlua09uU2VsZWN0aW9uLCBwYXN0ZUxpbmtBdENhcmV0XTtcbn1cbmZ1bmN0aW9uIGxvb2tzTGlrZVVybCh0ZXh0KSB7XG4gIGxldCBsb29rc0xpa2VVcmwyID0gITE7XG4gIHRyeSB7XG4gICAgbmV3IFVSTCh0ZXh0KSwgbG9va3NMaWtlVXJsMiA9ICEwO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gbG9va3NMaWtlVXJsMjtcbn1cbmZ1bmN0aW9uIGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQoe1xuICB2YWx1ZSxcbiAgYmxvY2tPZmZzZXRcbn0pIHtcbiAgbGV0IG9mZnNldExlZnQgPSBibG9ja09mZnNldC5vZmZzZXQsIHNlbGVjdGlvblBvaW50O1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIHZhbHVlKVxuICAgIGlmIChibG9jay5fa2V5ID09PSBibG9ja09mZnNldC5wYXRoWzBdLl9rZXkgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNQb3J0YWJsZVRleHRTcGFuJDEoY2hpbGQpKSB7XG4gICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGVjdGlvblBvaW50ID0ge1xuICAgICAgICAgICAgICBwYXRoOiBbLi4uYmxvY2tPZmZzZXQucGF0aCwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvZmZzZXRMZWZ0IDw9IGNoaWxkLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Qb2ludCA9IHtcbiAgICAgICAgICAgICAgcGF0aDogWy4uLmJsb2NrT2Zmc2V0LnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0TGVmdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXRMZWZ0IC09IGNoaWxkLnRleHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICByZXR1cm4gc2VsZWN0aW9uUG9pbnQ7XG59XG5mdW5jdGlvbiBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgdmFsdWUsXG4gIHNlbGVjdGlvblBvaW50XG59KSB7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIHZhbHVlKVxuICAgIGlmIChibG9jay5fa2V5ID09PSBzZWxlY3Rpb25Qb2ludC5wYXRoWzBdLl9rZXkgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNQb3J0YWJsZVRleHRTcGFuJDEoY2hpbGQpKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLl9rZXkgPT09IHNlbGVjdGlvblBvaW50LnBhdGhbMl0uX2tleSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgKyBzZWxlY3Rpb25Qb2ludC5vZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgb2Zmc2V0ICs9IGNoaWxkLnRleHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNLZXllZFNlZ21lbnQkMShzZWdtZW50KSB7XG4gIHJldHVybiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIHNlZ21lbnQgIT09IG51bGwgJiYgXCJfa2V5XCIgaW4gc2VnbWVudDtcbn1cbmZ1bmN0aW9uIHJldmVyc2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIHJldHVybiBzZWxlY3Rpb24gJiYgKHNlbGVjdGlvbi5iYWNrd2FyZCA/IHtcbiAgICBhbmNob3I6IHNlbGVjdGlvbi5mb2N1cyxcbiAgICBmb2N1czogc2VsZWN0aW9uLmFuY2hvcixcbiAgICBiYWNrd2FyZDogITFcbiAgfSA6IHtcbiAgICBhbmNob3I6IHNlbGVjdGlvbi5mb2N1cyxcbiAgICBmb2N1czogc2VsZWN0aW9uLmFuY2hvcixcbiAgICBiYWNrd2FyZDogITBcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25UZXh0KHtcbiAgdmFsdWUsXG4gIHNlbGVjdGlvblxufSkge1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIGlmICghdmFsdWUgfHwgIXNlbGVjdGlvbilcbiAgICByZXR1cm4gdGV4dDtcbiAgY29uc3QgZm9yd2FyZFNlbGVjdGlvbiA9IHNlbGVjdGlvbi5iYWNrd2FyZCA/IHJldmVyc2VTZWxlY3Rpb24oc2VsZWN0aW9uKSA6IHNlbGVjdGlvbjtcbiAgaWYgKCFmb3J3YXJkU2VsZWN0aW9uKVxuICAgIHJldHVybiB0ZXh0O1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIHZhbHVlKVxuICAgIGlmICghKGlzS2V5ZWRTZWdtZW50JDEoZm9yd2FyZFNlbGVjdGlvbi5hbmNob3IucGF0aFswXSkgJiYgYmxvY2suX2tleSAhPT0gZm9yd2FyZFNlbGVjdGlvbi5hbmNob3IucGF0aFswXS5fa2V5KSAmJiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhibG9jaykpIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4kMShjaGlsZCkpIHtcbiAgICAgICAgICBpZiAoaXNLZXllZFNlZ21lbnQkMShmb3J3YXJkU2VsZWN0aW9uLmFuY2hvci5wYXRoWzJdKSAmJiBjaGlsZC5fa2V5ID09PSBmb3J3YXJkU2VsZWN0aW9uLmFuY2hvci5wYXRoWzJdLl9rZXkgJiYgaXNLZXllZFNlZ21lbnQkMShmb3J3YXJkU2VsZWN0aW9uLmZvY3VzLnBhdGhbMl0pICYmIGNoaWxkLl9rZXkgPT09IGZvcndhcmRTZWxlY3Rpb24uZm9jdXMucGF0aFsyXS5fa2V5KSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dCArIGNoaWxkLnRleHQuc2xpY2UoZm9yd2FyZFNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0LCBmb3J3YXJkU2VsZWN0aW9uLmZvY3VzLm9mZnNldCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzS2V5ZWRTZWdtZW50JDEoZm9yd2FyZFNlbGVjdGlvbi5hbmNob3IucGF0aFsyXSkgJiYgY2hpbGQuX2tleSA9PT0gZm9yd2FyZFNlbGVjdGlvbi5hbmNob3IucGF0aFsyXS5fa2V5KSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dCArIGNoaWxkLnRleHQuc2xpY2UoZm9yd2FyZFNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNLZXllZFNlZ21lbnQkMShmb3J3YXJkU2VsZWN0aW9uLmZvY3VzLnBhdGhbMl0pICYmIGNoaWxkLl9rZXkgPT09IGZvcndhcmRTZWxlY3Rpb24uZm9jdXMucGF0aFsyXS5fa2V5KSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dCArIGNoaWxkLnRleHQuc2xpY2UoMCwgZm9yd2FyZFNlbGVjdGlvbi5mb2N1cy5vZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBpZiAoaXNLZXllZFNlZ21lbnQkMShmb3J3YXJkU2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pICYmIGJsb2NrLl9rZXkgPT09IGZvcndhcmRTZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5KVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRQb2ludCh7XG4gIG5vZGUsXG4gIHBhdGhcbn0pIHtcbiAgcmV0dXJuIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKG5vZGUpID8ge1xuICAgIHBhdGg6IFsuLi5wYXRoLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgIF9rZXk6IG5vZGUuY2hpbGRyZW5bMF0uX2tleVxuICAgIH1dLFxuICAgIG9mZnNldDogMFxuICB9IDoge1xuICAgIHBhdGgsXG4gICAgb2Zmc2V0OiAwXG4gIH07XG59XG5mdW5jdGlvbiBnZXRCbG9ja1RleHRCZWZvcmUoe1xuICB2YWx1ZSxcbiAgcG9pbnRcbn0pIHtcbiAgY29uc3Qga2V5ID0gaXNLZXllZFNlZ21lbnQkMShwb2ludC5wYXRoWzBdKSA/IHBvaW50LnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgYmxvY2sgPSBrZXkgPyB2YWx1ZS5maW5kKChibG9jazIpID0+IGJsb2NrMi5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICBpZiAoIWJsb2NrKVxuICAgIHJldHVybiBcIlwiO1xuICBjb25zdCBzdGFydFBvaW50ID0gZ2V0U3RhcnRQb2ludCh7XG4gICAgbm9kZTogYmxvY2ssXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9XVxuICB9KTtcbiAgcmV0dXJuIGdldFNlbGVjdGlvblRleHQoe1xuICAgIHZhbHVlLFxuICAgIHNlbGVjdGlvbjoge1xuICAgICAgYW5jaG9yOiBzdGFydFBvaW50LFxuICAgICAgZm9jdXM6IHBvaW50XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hcmtkb3duQmVoYXZpb3JzKGNvbmZpZykge1xuICBjb25zdCBhdXRvbWF0aWNCbG9ja3F1b3RlT25TcGFjZSA9IHtcbiAgICBvbjogXCJpbnNlcnQgdGV4dFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRleHQgIT09IFwiIFwiKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBzZWxlY3Rpb25Jc0NvbGxhcHNlZChjb250ZXh0KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhjb250ZXh0KSwgZm9jdXNTcGFuID0gZ2V0Rm9jdXNTcGFuKGNvbnRleHQpO1xuICAgICAgaWYgKCFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFmb2N1c1NwYW4pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGJsb2NrT2Zmc2V0ID0gc3BhblNlbGVjdGlvblBvaW50VG9CbG9ja09mZnNldCh7XG4gICAgICAgIHZhbHVlOiBjb250ZXh0LnZhbHVlLFxuICAgICAgICBzZWxlY3Rpb25Qb2ludDoge1xuICAgICAgICAgIHBhdGg6IFt7XG4gICAgICAgICAgICBfa2V5OiBmb2N1c1RleHRCbG9jay5ub2RlLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzU3Bhbi5ub2RlLl9rZXlcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBvZmZzZXQ6IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLm9mZnNldFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghYmxvY2tPZmZzZXQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IGJsb2NrVGV4dCA9IGdldFRleHRCbG9ja1RleHQoZm9jdXNUZXh0QmxvY2subm9kZSksIGNhcmV0QXRUaGVFbmRPZlF1b3RlID0gYmxvY2tPZmZzZXQub2Zmc2V0ID09PSAxLCBsb29rc0xpa2VNYXJrZG93blF1b3RlID0gL14+Ly50ZXN0KGJsb2NrVGV4dCksIGJsb2NrcXVvdGVTdHlsZSA9IGNvbmZpZy5ibG9ja3F1b3RlU3R5bGU/Lih7XG4gICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNhcmV0QXRUaGVFbmRPZlF1b3RlICYmIGxvb2tzTGlrZU1hcmtkb3duUXVvdGUgJiYgYmxvY2txdW90ZVN0eWxlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgICBzdHlsZTogYmxvY2txdW90ZVN0eWxlXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKCkgPT4gW3tcbiAgICAgIHR5cGU6IFwiaW5zZXJ0IHRleHRcIixcbiAgICAgIHRleHQ6IFwiIFwiXG4gICAgfV0sIChfLCB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIHN0eWxlXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwidW5zZXQgYmxvY2tcIixcbiAgICAgIHByb3BzOiBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLFxuICAgICAgcGF0aHM6IFtmb2N1c1RleHRCbG9jay5wYXRoXVxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwic2V0IGJsb2NrXCIsXG4gICAgICBzdHlsZSxcbiAgICAgIHBhdGhzOiBbZm9jdXNUZXh0QmxvY2sucGF0aF1cbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImRlbGV0ZSB0ZXh0XCIsXG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAyXG4gICAgICB9XG4gICAgfV1dXG4gIH0sIGF1dG9tYXRpY0hyID0ge1xuICAgIG9uOiBcImluc2VydCB0ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBockNoYXJhY3RlciA9IGV2ZW50LnRleHQgPT09IFwiLVwiID8gXCItXCIgOiBldmVudC50ZXh0ID09PSBcIipcIiA/IFwiKlwiIDogZXZlbnQudGV4dCA9PT0gXCJfXCIgPyBcIl9cIiA6IHZvaWQgMDtcbiAgICAgIGlmIChockNoYXJhY3RlciA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBock9iamVjdCA9IGNvbmZpZy5ob3Jpem9udGFsUnVsZU9iamVjdD8uKHtcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICAgICAgfSksIGZvY3VzQmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayhjb250ZXh0KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQoY29udGV4dCk7XG4gICAgICBpZiAoIWhyT2JqZWN0IHx8ICFmb2N1c0Jsb2NrIHx8ICFzZWxlY3Rpb25Db2xsYXBzZWQpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHRleHRCZWZvcmUgPSBnZXRCbG9ja1RleHRCZWZvcmUoe1xuICAgICAgICB2YWx1ZTogY29udGV4dC52YWx1ZSxcbiAgICAgICAgcG9pbnQ6IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzXG4gICAgICB9KSwgaHJCbG9ja09mZnNldHMgPSB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IGZvY3VzQmxvY2sucGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBmb2N1c0Jsb2NrLnBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdGV4dEJlZm9yZSA9PT0gYCR7aHJDaGFyYWN0ZXJ9JHtockNoYXJhY3Rlcn1gID8ge1xuICAgICAgICBock9iamVjdCxcbiAgICAgICAgZm9jdXNCbG9jayxcbiAgICAgICAgaHJDaGFyYWN0ZXIsXG4gICAgICAgIGhyQmxvY2tPZmZzZXRzXG4gICAgICB9IDogITE7XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIGhyQ2hhcmFjdGVyXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwiaW5zZXJ0IHRleHRcIixcbiAgICAgIHRleHQ6IGhyQ2hhcmFjdGVyXG4gICAgfV0sIChfLCB7XG4gICAgICBock9iamVjdCxcbiAgICAgIGhyQmxvY2tPZmZzZXRzXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwiaW5zZXJ0IGJsb2NrIG9iamVjdFwiLFxuICAgICAgcGxhY2VtZW50OiBcImJlZm9yZVwiLFxuICAgICAgYmxvY2tPYmplY3Q6IGhyT2JqZWN0XG4gICAgfSwge1xuICAgICAgdHlwZTogXCJkZWxldGUgdGV4dFwiLFxuICAgICAgLi4uaHJCbG9ja09mZnNldHNcbiAgICB9XV1cbiAgfSwgYXV0b21hdGljSHJPblBhc3RlID0ge1xuICAgIG9uOiBcInBhc3RlXCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSwgaHJSZWdFeHAgPSAvXigtLS0pJHwoX19fKSR8KFxcKlxcKlxcKikkL2dtLCBockNoYXJhY3RlcnMgPSB0ZXh0Lm1hdGNoKGhyUmVnRXhwKT8uWzBdLCBock9iamVjdCA9IGNvbmZpZy5ob3Jpem9udGFsUnVsZU9iamVjdD8uKHtcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICAgICAgfSksIGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKGNvbnRleHQpO1xuICAgICAgcmV0dXJuICFockNoYXJhY3RlcnMgfHwgIWhyT2JqZWN0IHx8ICFmb2N1c0Jsb2NrID8gITEgOiB7XG4gICAgICAgIGhyQ2hhcmFjdGVycyxcbiAgICAgICAgaHJPYmplY3QsXG4gICAgICAgIGZvY3VzQmxvY2tcbiAgICAgIH07XG4gICAgfSxcbiAgICBhY3Rpb25zOiBbKF8sIHtcbiAgICAgIGhyQ2hhcmFjdGVyc1xuICAgIH0pID0+IFt7XG4gICAgICB0eXBlOiBcImluc2VydCB0ZXh0XCIsXG4gICAgICB0ZXh0OiBockNoYXJhY3RlcnNcbiAgICB9XSwgKF8sIHtcbiAgICAgIGhyT2JqZWN0LFxuICAgICAgZm9jdXNCbG9ja1xuICAgIH0pID0+IGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGZvY3VzQmxvY2subm9kZSkgPyBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQgdGV4dCBibG9ja1wiLFxuICAgICAgdGV4dEJsb2NrOiB7XG4gICAgICAgIGNoaWxkcmVuOiBmb2N1c0Jsb2NrLm5vZGUuY2hpbGRyZW5cbiAgICAgIH0sXG4gICAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiaW5zZXJ0IGJsb2NrIG9iamVjdFwiLFxuICAgICAgYmxvY2tPYmplY3Q6IGhyT2JqZWN0LFxuICAgICAgcGxhY2VtZW50OiBcImFmdGVyXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImRlbGV0ZSBibG9ja1wiLFxuICAgICAgYmxvY2tQYXRoOiBmb2N1c0Jsb2NrLnBhdGhcbiAgICB9XSA6IFt7XG4gICAgICB0eXBlOiBcImluc2VydCBibG9jayBvYmplY3RcIixcbiAgICAgIGJsb2NrT2JqZWN0OiBock9iamVjdCxcbiAgICAgIHBsYWNlbWVudDogXCJhZnRlclwiXG4gICAgfV1dXG4gIH0sIGF1dG9tYXRpY0hlYWRpbmdPblNwYWNlID0ge1xuICAgIG9uOiBcImluc2VydCB0ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGV4dCAhPT0gXCIgXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKGNvbnRleHQpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oY29udGV4dCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYmxvY2tPZmZzZXQgPSBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHQudmFsdWUsXG4gICAgICAgIHNlbGVjdGlvblBvaW50OiB7XG4gICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzVGV4dEJsb2NrLm5vZGUuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogZm9jdXNTcGFuLm5vZGUuX2tleVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIG9mZnNldDogY29udGV4dC5zZWxlY3Rpb24uZm9jdXMub2Zmc2V0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFibG9ja09mZnNldClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gZ2V0VGV4dEJsb2NrVGV4dChmb2N1c1RleHRCbG9jay5ub2RlKSwgbWFya2Rvd25IZWFkaW5nU2VhcmNoID0gL14jKy8uZXhlYyhibG9ja1RleHQpLCBsZXZlbCA9IG1hcmtkb3duSGVhZGluZ1NlYXJjaCA/IG1hcmtkb3duSGVhZGluZ1NlYXJjaFswXS5sZW5ndGggOiB2b2lkIDA7XG4gICAgICBpZiAoYmxvY2tPZmZzZXQub2Zmc2V0ICE9PSBsZXZlbClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3Qgc3R5bGUgPSBsZXZlbCAhPT0gdm9pZCAwID8gY29uZmlnLmhlYWRpbmdTdHlsZT8uKHtcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYSxcbiAgICAgICAgbGV2ZWxcbiAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGxldmVsICE9PSB2b2lkIDAgJiYgc3R5bGUgIT09IHZvaWQgMCA/IHtcbiAgICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBsZXZlbFxuICAgICAgfSA6ICExO1xuICAgIH0sXG4gICAgYWN0aW9uczogWygpID0+IFt7XG4gICAgICB0eXBlOiBcImluc2VydCB0ZXh0XCIsXG4gICAgICB0ZXh0OiBcIiBcIlxuICAgIH1dLCAoXywge1xuICAgICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgICBzdHlsZSxcbiAgICAgIGxldmVsXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwidW5zZXQgYmxvY2tcIixcbiAgICAgIHByb3BzOiBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLFxuICAgICAgcGF0aHM6IFtmb2N1c1RleHRCbG9jay5wYXRoXVxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwic2V0IGJsb2NrXCIsXG4gICAgICBzdHlsZSxcbiAgICAgIHBhdGhzOiBbZm9jdXNUZXh0QmxvY2sucGF0aF1cbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImRlbGV0ZSB0ZXh0XCIsXG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogZm9jdXNUZXh0QmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiBsZXZlbCArIDFcbiAgICAgIH1cbiAgICB9XV1cbiAgfSwgY2xlYXJTdHlsZU9uQmFja3NwYWNlID0ge1xuICAgIG9uOiBcImRlbGV0ZSBiYWNrd2FyZFwiLFxuICAgIGd1YXJkOiAoe1xuICAgICAgY29udGV4dFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKGNvbnRleHQpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oY29udGV4dCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYXRUaGVCZWdpbm5pbmdPZkJMb2NrID0gZm9jdXNUZXh0QmxvY2subm9kZS5jaGlsZHJlblswXS5fa2V5ID09PSBmb2N1c1NwYW4ubm9kZS5fa2V5ICYmIGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLm9mZnNldCA9PT0gMCwgZGVmYXVsdFN0eWxlID0gY29uZmlnLmRlZmF1bHRTdHlsZT8uKHtcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXRUaGVCZWdpbm5pbmdPZkJMb2NrICYmIGRlZmF1bHRTdHlsZSAmJiBmb2N1c1RleHRCbG9jay5ub2RlLnN0eWxlICE9PSBkZWZhdWx0U3R5bGUgPyB7XG4gICAgICAgIGRlZmF1bHRTdHlsZSxcbiAgICAgICAgZm9jdXNUZXh0QmxvY2tcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoXywge1xuICAgICAgZGVmYXVsdFN0eWxlLFxuICAgICAgZm9jdXNUZXh0QmxvY2tcbiAgICB9KSA9PiBbe1xuICAgICAgdHlwZTogXCJzZXQgYmxvY2tcIixcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGUsXG4gICAgICBwYXRoczogW2ZvY3VzVGV4dEJsb2NrLnBhdGhdXG4gICAgfV1dXG4gIH0sIGF1dG9tYXRpY0xpc3RPblNwYWNlID0ge1xuICAgIG9uOiBcImluc2VydCB0ZXh0XCIsXG4gICAgZ3VhcmQ6ICh7XG4gICAgICBjb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoZXZlbnQudGV4dCAhPT0gXCIgXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKGNvbnRleHQpLCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKGNvbnRleHQpLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oY29udGV4dCk7XG4gICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhZm9jdXNUZXh0QmxvY2sgfHwgIWZvY3VzU3BhbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYmxvY2tPZmZzZXQgPSBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHQudmFsdWUsXG4gICAgICAgIHNlbGVjdGlvblBvaW50OiB7XG4gICAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICAgIF9rZXk6IGZvY3VzVGV4dEJsb2NrLm5vZGUuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogZm9jdXNTcGFuLm5vZGUuX2tleVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIG9mZnNldDogY29udGV4dC5zZWxlY3Rpb24uZm9jdXMub2Zmc2V0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFibG9ja09mZnNldClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgYmxvY2tUZXh0ID0gZ2V0VGV4dEJsb2NrVGV4dChmb2N1c1RleHRCbG9jay5ub2RlKSwgZGVmYXVsdFN0eWxlID0gY29uZmlnLmRlZmF1bHRTdHlsZT8uKHtcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICAgICAgfSksIGxvb2tzTGlrZVVub3JkZXJlZExpc3QgPSAvXigtfFxcKikvLnRlc3QoYmxvY2tUZXh0KSwgdW5vcmRlcmVkTGlzdFN0eWxlID0gY29uZmlnLnVub3JkZXJlZExpc3RTdHlsZT8uKHtcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICAgICAgfSksIGNhcmV0QXRUaGVFbmRPZlVub3JkZXJlZExpc3QgPSBibG9ja09mZnNldC5vZmZzZXQgPT09IDE7XG4gICAgICBpZiAoZGVmYXVsdFN0eWxlICYmIGNhcmV0QXRUaGVFbmRPZlVub3JkZXJlZExpc3QgJiYgbG9va3NMaWtlVW5vcmRlcmVkTGlzdCAmJiB1bm9yZGVyZWRMaXN0U3R5bGUgIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgICAgICBsaXN0SXRlbTogdW5vcmRlcmVkTGlzdFN0eWxlLFxuICAgICAgICAgIGxpc3RJdGVtTGVuZ3RoOiAxLFxuICAgICAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IGxvb2tzTGlrZU9yZGVyZWRMaXN0ID0gL14xXFwuLy50ZXN0KGJsb2NrVGV4dCksIG9yZGVyZWRMaXN0U3R5bGUgPSBjb25maWcub3JkZXJlZExpc3RTdHlsZT8uKHtcbiAgICAgICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICAgICAgfSksIGNhcmV0QXRUaGVFbmRPZk9yZGVyZWRMaXN0ID0gYmxvY2tPZmZzZXQub2Zmc2V0ID09PSAyO1xuICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSAmJiBjYXJldEF0VGhlRW5kT2ZPcmRlcmVkTGlzdCAmJiBsb29rc0xpa2VPcmRlcmVkTGlzdCAmJiBvcmRlcmVkTGlzdFN0eWxlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgICBsaXN0SXRlbTogb3JkZXJlZExpc3RTdHlsZSxcbiAgICAgICAgbGlzdEl0ZW1MZW5ndGg6IDIsXG4gICAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICAgIH0gOiAhMTtcbiAgICB9LFxuICAgIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgICAgdHlwZTogXCJpbnNlcnQgdGV4dFwiLFxuICAgICAgdGV4dDogXCIgXCJcbiAgICB9XSwgKF8sIHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgc3R5bGUsXG4gICAgICBsaXN0SXRlbSxcbiAgICAgIGxpc3RJdGVtTGVuZ3RoXG4gICAgfSkgPT4gW3tcbiAgICAgIHR5cGU6IFwic2V0IGJsb2NrXCIsXG4gICAgICBsaXN0SXRlbSxcbiAgICAgIGxldmVsOiAxLFxuICAgICAgc3R5bGUsXG4gICAgICBwYXRoczogW2ZvY3VzVGV4dEJsb2NrLnBhdGhdXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJkZWxldGUgdGV4dFwiLFxuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogbGlzdEl0ZW1MZW5ndGggKyAxXG4gICAgICB9XG4gICAgfV1dXG4gIH07XG4gIHJldHVybiBbYXV0b21hdGljQmxvY2txdW90ZU9uU3BhY2UsIGF1dG9tYXRpY0hlYWRpbmdPblNwYWNlLCBhdXRvbWF0aWNIciwgYXV0b21hdGljSHJPblBhc3RlLCBjbGVhclN0eWxlT25CYWNrc3BhY2UsIGF1dG9tYXRpY0xpc3RPblNwYWNlXTtcbn1cbmZ1bmN0aW9uIGdldFBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKHBvcnRhYmxlVGV4dFR5cGUpIHtcbiAgaWYgKCFwb3J0YWJsZVRleHRUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciAncG9ydGFibGV0ZXh0VHlwZScgbWlzc2luZyAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBibG9ja1R5cGUgPSBwb3J0YWJsZVRleHRUeXBlLm9mPy5maW5kKGZpbmRCbG9ja1R5cGUpO1xuICBpZiAoIWJsb2NrVHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayB0eXBlIGlzIG5vdCBkZWZpbmVkIGluIHRoaXMgc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IGNoaWxkcmVuRmllbGQgPSBibG9ja1R5cGUuZmllbGRzPy5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gXCJjaGlsZHJlblwiKTtcbiAgaWYgKCFjaGlsZHJlbkZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNoaWxkcmVuIGZpZWxkIGZvciBibG9jayB0eXBlIGZvdW5kIGluIHNjaGVtYSAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBvZlR5cGUgPSBjaGlsZHJlbkZpZWxkLnR5cGUub2Y7XG4gIGlmICghb2ZUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkIHR5cGVzIGZvciBibG9jayBjaGlsZHJlbiBub3QgZm91bmQgaW4gc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IHNwYW5UeXBlID0gb2ZUeXBlLmZpbmQoKG1lbWJlclR5cGUpID0+IG1lbWJlclR5cGUubmFtZSA9PT0gXCJzcGFuXCIpO1xuICBpZiAoIXNwYW5UeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNwYW4gdHlwZSBub3QgZm91bmQgaW4gc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IGlubGluZU9iamVjdFR5cGVzID0gb2ZUeXBlLmZpbHRlcigobWVtYmVyVHlwZSkgPT4gbWVtYmVyVHlwZS5uYW1lICE9PSBcInNwYW5cIikgfHwgW10sIGJsb2NrT2JqZWN0VHlwZXMgPSBwb3J0YWJsZVRleHRUeXBlLm9mPy5maWx0ZXIoKGZpZWxkKSA9PiBmaWVsZC5uYW1lICE9PSBibG9ja1R5cGUubmFtZSkgfHwgW107XG4gIHJldHVybiB7XG4gICAgc3R5bGVzOiByZXNvbHZlRW5hYmxlZFN0eWxlcyhibG9ja1R5cGUpLFxuICAgIGRlY29yYXRvcnM6IHJlc29sdmVFbmFibGVkRGVjb3JhdG9ycyhzcGFuVHlwZSksXG4gICAgbGlzdHM6IHJlc29sdmVFbmFibGVkTGlzdEl0ZW1zKGJsb2NrVHlwZSksXG4gICAgYmxvY2s6IGJsb2NrVHlwZSxcbiAgICBzcGFuOiBzcGFuVHlwZSxcbiAgICBwb3J0YWJsZVRleHQ6IHBvcnRhYmxlVGV4dFR5cGUsXG4gICAgaW5saW5lT2JqZWN0czogaW5saW5lT2JqZWN0VHlwZXMsXG4gICAgYmxvY2tPYmplY3RzOiBibG9ja09iamVjdFR5cGVzLFxuICAgIGFubm90YXRpb25zOiBzcGFuVHlwZS5hbm5vdGF0aW9uc1xuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWRTdHlsZXMoYmxvY2tUeXBlKSB7XG4gIGNvbnN0IHN0eWxlRmllbGQgPSBibG9ja1R5cGUuZmllbGRzPy5maW5kKChidEZpZWxkKSA9PiBidEZpZWxkLm5hbWUgPT09IFwic3R5bGVcIik7XG4gIGlmICghc3R5bGVGaWVsZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGZpZWxkIHdpdGggbmFtZSAnc3R5bGUnIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBibG9jayB0eXBlIChyZXF1aXJlZCkuXCIpO1xuICBjb25zdCB0ZXh0U3R5bGVzID0gc3R5bGVGaWVsZC50eXBlLm9wdGlvbnM/Lmxpc3QgJiYgc3R5bGVGaWVsZC50eXBlLm9wdGlvbnMubGlzdD8uZmlsdGVyKChzdHlsZSkgPT4gc3R5bGUudmFsdWUpO1xuICBpZiAoIXRleHRTdHlsZXMgfHwgdGV4dFN0eWxlcy5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlIGZpZWxkcyBuZWVkIGF0IGxlYXN0IG9uZSBzdHlsZSBkZWZpbmVkLiBJLmU6IHt0aXRsZTogJ05vcm1hbCcsIHZhbHVlOiAnbm9ybWFsJ30uXCIpO1xuICByZXR1cm4gdGV4dFN0eWxlcztcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkRGVjb3JhdG9ycyhzcGFuVHlwZSkge1xuICByZXR1cm4gc3BhblR5cGUuZGVjb3JhdG9ycztcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkTGlzdEl0ZW1zKGJsb2NrVHlwZSkge1xuICBjb25zdCBsaXN0RmllbGQgPSBibG9ja1R5cGUuZmllbGRzPy5maW5kKChidEZpZWxkKSA9PiBidEZpZWxkLm5hbWUgPT09IFwibGlzdEl0ZW1cIik7XG4gIGlmICghbGlzdEZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkEgZmllbGQgd2l0aCBuYW1lICdsaXN0SXRlbScgaXMgbm90IGRlZmluZWQgaW4gdGhlIGJsb2NrIHR5cGUgKHJlcXVpcmVkKS5cIik7XG4gIGNvbnN0IGxpc3RJdGVtcyA9IGxpc3RGaWVsZC50eXBlLm9wdGlvbnM/Lmxpc3QgJiYgbGlzdEZpZWxkLnR5cGUub3B0aW9ucy5saXN0LmZpbHRlcigobGlzdCkgPT4gbGlzdC52YWx1ZSk7XG4gIGlmICghbGlzdEl0ZW1zKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsaXN0IGZpZWxkIG5lZWQgYXQgbGVhc3QgdG8gYmUgYW4gZW1wdHkgYXJyYXlcIik7XG4gIHJldHVybiBsaXN0SXRlbXM7XG59XG5mdW5jdGlvbiBmaW5kQmxvY2tUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUudHlwZSA/IGZpbmRCbG9ja1R5cGUodHlwZS50eXBlKSA6IHR5cGUubmFtZSA9PT0gXCJibG9ja1wiID8gdHlwZSA6IG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVTY2hlbWEoZGVmaW5pdGlvbikge1xuICByZXR1cm4gZGVmaW5pdGlvbjtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVTY2hlbWFEZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgY29uc3QgYmxvY2tPYmplY3RzID0gZGVmaW5pdGlvbj8uYmxvY2tPYmplY3RzPy5tYXAoKGJsb2NrT2JqZWN0KSA9PiBkZWZpbmVUeXBlKHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIC8vIFZlcnkgbmFpdmUgd2F5IHRvIHdvcmsgYXJvdW5kIGBTYW5pdHlTY2hlbWEuY29tcGlsZWAgYWRkaW5nIGRlZmF1bHRcbiAgICAvLyBmaWVsZHMgdG8gb2JqZWN0cyB3aXRoIHRoZSBuYW1lIGBpbWFnZWBcbiAgICBuYW1lOiBibG9ja09iamVjdC5uYW1lID09PSBcImltYWdlXCIgPyBcInRtcC1pbWFnZVwiIDogYmxvY2tPYmplY3QubmFtZSxcbiAgICB0aXRsZTogYmxvY2tPYmplY3QudGl0bGUsXG4gICAgaWNvbjogYmxvY2tPYmplY3QuaWNvbixcbiAgICBmaWVsZHM6IFtdXG4gIH0pKSA/PyBbXSwgaW5saW5lT2JqZWN0cyA9IGRlZmluaXRpb24/LmlubGluZU9iamVjdHM/Lm1hcCgoaW5saW5lT2JqZWN0KSA9PiBkZWZpbmVUeXBlKHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIG5hbWU6IGlubGluZU9iamVjdC5uYW1lLFxuICAgIHRpdGxlOiBpbmxpbmVPYmplY3QudGl0bGUsXG4gICAgaWNvbjogaW5saW5lT2JqZWN0Lmljb24sXG4gICAgZmllbGRzOiBbXVxuICB9KSkgPz8gW10sIHBvcnRhYmxlVGV4dFNjaGVtYSA9IGRlZmluZUZpZWxkKHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbmFtZTogXCJwb3J0YWJsZS10ZXh0XCIsXG4gICAgb2Y6IFsuLi5ibG9ja09iamVjdHMubWFwKChibG9ja09iamVjdCkgPT4gKHtcbiAgICAgIHR5cGU6IGJsb2NrT2JqZWN0Lm5hbWVcbiAgICB9KSksIHtcbiAgICAgIHR5cGU6IFwiYmxvY2tcIixcbiAgICAgIG5hbWU6IFwiYmxvY2tcIixcbiAgICAgIG9mOiBpbmxpbmVPYmplY3RzLm1hcCgoaW5saW5lT2JqZWN0KSA9PiAoe1xuICAgICAgICB0eXBlOiBpbmxpbmVPYmplY3QubmFtZVxuICAgICAgfSkpLFxuICAgICAgbWFya3M6IHtcbiAgICAgICAgZGVjb3JhdG9yczogZGVmaW5pdGlvbj8uZGVjb3JhdG9ycz8ubWFwKChkZWNvcmF0b3IpID0+ICh7XG4gICAgICAgICAgdGl0bGU6IGRlY29yYXRvci50aXRsZSA/PyBzdGFydENhc2UoZGVjb3JhdG9yLm5hbWUpLFxuICAgICAgICAgIHZhbHVlOiBkZWNvcmF0b3IubmFtZSxcbiAgICAgICAgICBpY29uOiBkZWNvcmF0b3IuaWNvblxuICAgICAgICB9KSkgPz8gW10sXG4gICAgICAgIGFubm90YXRpb25zOiBkZWZpbml0aW9uPy5hbm5vdGF0aW9ucz8ubWFwKChhbm5vdGF0aW9uKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IGFubm90YXRpb24ubmFtZSxcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgIHRpdGxlOiBhbm5vdGF0aW9uLnRpdGxlLFxuICAgICAgICAgIGljb246IGFubm90YXRpb24uaWNvblxuICAgICAgICB9KSkgPz8gW11cbiAgICAgIH0sXG4gICAgICBsaXN0czogZGVmaW5pdGlvbj8ubGlzdHM/Lm1hcCgobGlzdCkgPT4gKHtcbiAgICAgICAgdmFsdWU6IGxpc3QubmFtZSxcbiAgICAgICAgdGl0bGU6IGxpc3QudGl0bGUgPz8gc3RhcnRDYXNlKGxpc3QubmFtZSksXG4gICAgICAgIGljb246IGxpc3QuaWNvblxuICAgICAgfSkpID8/IFtdLFxuICAgICAgc3R5bGVzOiBkZWZpbml0aW9uPy5zdHlsZXM/Lm1hcCgoc3R5bGUpID0+ICh7XG4gICAgICAgIHZhbHVlOiBzdHlsZS5uYW1lLFxuICAgICAgICB0aXRsZTogc3R5bGUudGl0bGUgPz8gc3RhcnRDYXNlKHN0eWxlLm5hbWUpLFxuICAgICAgICBpY29uOiBzdHlsZS5pY29uXG4gICAgICB9KSkgPz8gW11cbiAgICB9XVxuICB9KSwgc2NoZW1hID0gU2NoZW1hLmNvbXBpbGUoe1xuICAgIHR5cGVzOiBbcG9ydGFibGVUZXh0U2NoZW1hLCAuLi5ibG9ja09iamVjdHMsIC4uLmlubGluZU9iamVjdHNdXG4gIH0pLmdldChcInBvcnRhYmxlLXRleHRcIiksIHB0ZVNjaGVtYSA9IGdldFBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKHNjaGVtYSk7XG4gIHJldHVybiB7XG4gICAgLi4ucHRlU2NoZW1hLFxuICAgIGJsb2NrT2JqZWN0czogcHRlU2NoZW1hLmJsb2NrT2JqZWN0cy5tYXAoKGJsb2NrT2JqZWN0KSA9PiBibG9ja09iamVjdC5uYW1lID09PSBcInRtcC1pbWFnZVwiID8ge1xuICAgICAgLi4uYmxvY2tPYmplY3QsXG4gICAgICBuYW1lOiBcImltYWdlXCIsXG4gICAgICB0eXBlOiB7XG4gICAgICAgIC4uLmJsb2NrT2JqZWN0LnR5cGUsXG4gICAgICAgIG5hbWU6IFwiaW1hZ2VcIlxuICAgICAgfVxuICAgIH0gOiBibG9ja09iamVjdClcbiAgfTtcbn1cbmNvbnN0IHJvb3ROYW1lID0gXCJzYW5pdHktcHRlOlwiO1xuZGVidWckbShyb290TmFtZSk7XG5mdW5jdGlvbiBkZWJ1Z1dpdGhOYW1lKG5hbWUpIHtcbiAgY29uc3QgbmFtZXNwYWNlID0gYCR7cm9vdE5hbWV9JHtuYW1lfWA7XG4gIHJldHVybiBkZWJ1ZyRtICYmIGRlYnVnJG0uZW5hYmxlZChuYW1lc3BhY2UpID8gZGVidWckbShuYW1lc3BhY2UpIDogZGVidWckbShyb290TmFtZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXllZFBhdGgocG9pbnQsIHZhbHVlLCB0eXBlcykge1xuICBjb25zdCBibG9ja1BhdGggPSBbcG9pbnQucGF0aFswXV07XG4gIGlmICghdmFsdWUpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGJsb2NrID0gdmFsdWVbYmxvY2tQYXRoWzBdXTtcbiAgaWYgKCFibG9jaylcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3Qga2V5ZWRCbG9ja1BhdGggPSBbe1xuICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgfV07XG4gIGlmIChibG9jay5fdHlwZSAhPT0gdHlwZXMuYmxvY2submFtZSlcbiAgICByZXR1cm4ga2V5ZWRCbG9ja1BhdGg7XG4gIGxldCBrZXllZENoaWxkUGF0aDtcbiAgY29uc3QgY2hpbGRQYXRoID0gcG9pbnQucGF0aC5zbGljZSgwLCAyKSwgY2hpbGQgPSBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBibG9jay5jaGlsZHJlbltjaGlsZFBhdGhbMV1dO1xuICByZXR1cm4gY2hpbGQgJiYgKGtleWVkQ2hpbGRQYXRoID0gW1wiY2hpbGRyZW5cIiwge1xuICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgfV0pLCBrZXllZENoaWxkUGF0aCA/IFsuLi5rZXllZEJsb2NrUGF0aCwgLi4ua2V5ZWRDaGlsZFBhdGhdIDoga2V5ZWRCbG9ja1BhdGg7XG59XG5mdW5jdGlvbiBjcmVhdGVBcnJheWVkUGF0aChwb2ludCwgZWRpdG9yKSB7XG4gIGlmICghZWRpdG9yKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IFtdLFxuICAgIG1hdGNoOiAobikgPT4gaXNLZXlTZWdtZW50KHBvaW50LnBhdGhbMF0pICYmIG4uX2tleSA9PT0gcG9pbnQucGF0aFswXS5fa2V5XG4gIH0pKVswXSB8fCBbdm9pZCAwLCB2b2lkIDBdO1xuICBpZiAoIWJsb2NrIHx8ICFFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSlcbiAgICByZXR1cm4gW107XG4gIGlmIChlZGl0b3IuaXNWb2lkKGJsb2NrKSlcbiAgICByZXR1cm4gW2Jsb2NrUGF0aFswXSwgMF07XG4gIGNvbnN0IGNoaWxkUGF0aCA9IFtwb2ludC5wYXRoWzJdXSwgY2hpbGRJbmRleCA9IGJsb2NrLmNoaWxkcmVuLmZpbmRJbmRleCgoY2hpbGQpID0+IGlzRXF1YWwoW3tcbiAgICBfa2V5OiBjaGlsZC5fa2V5XG4gIH1dLCBjaGlsZFBhdGgpKTtcbiAgaWYgKGNoaWxkSW5kZXggPj0gMCAmJiBibG9jay5jaGlsZHJlbltjaGlsZEluZGV4XSkge1xuICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgcmV0dXJuIEVsZW1lbnQkMS5pc0VsZW1lbnQoY2hpbGQpICYmIGVkaXRvci5pc1ZvaWQoY2hpbGQpID8gYmxvY2tQYXRoLmNvbmNhdChjaGlsZEluZGV4KS5jb25jYXQoMCkgOiBibG9ja1BhdGguY29uY2F0KGNoaWxkSW5kZXgpO1xuICB9XG4gIHJldHVybiBibG9ja1BhdGg7XG59XG5mdW5jdGlvbiB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlLCByYW5nZSwgdHlwZXMpIHtcbiAgaWYgKCFyYW5nZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IGFuY2hvciA9IG51bGwsIGZvY3VzID0gbnVsbDtcbiAgY29uc3QgYW5jaG9yUGF0aCA9IHJhbmdlLmFuY2hvciAmJiBjcmVhdGVLZXllZFBhdGgocmFuZ2UuYW5jaG9yLCB2YWx1ZSwgdHlwZXMpO1xuICBhbmNob3JQYXRoICYmIHJhbmdlLmFuY2hvciAmJiAoYW5jaG9yID0ge1xuICAgIHBhdGg6IGFuY2hvclBhdGgsXG4gICAgb2Zmc2V0OiByYW5nZS5hbmNob3Iub2Zmc2V0XG4gIH0pO1xuICBjb25zdCBmb2N1c1BhdGggPSByYW5nZS5mb2N1cyAmJiBjcmVhdGVLZXllZFBhdGgocmFuZ2UuZm9jdXMsIHZhbHVlLCB0eXBlcyk7XG4gIGZvY3VzUGF0aCAmJiByYW5nZS5mb2N1cyAmJiAoZm9jdXMgPSB7XG4gICAgcGF0aDogZm9jdXNQYXRoLFxuICAgIG9mZnNldDogcmFuZ2UuZm9jdXMub2Zmc2V0XG4gIH0pO1xuICBjb25zdCBiYWNrd2FyZCA9ICEhKFJhbmdlLmlzUmFuZ2UocmFuZ2UpICYmIFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpKTtcbiAgcmV0dXJuIGFuY2hvciAmJiBmb2N1cyA/IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXMsXG4gICAgYmFja3dhcmRcbiAgfSA6IG51bGw7XG59XG5mdW5jdGlvbiB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uLCBlZGl0b3IpIHtcbiAgaWYgKCFzZWxlY3Rpb24gfHwgIWVkaXRvcilcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgYW5jaG9yID0ge1xuICAgIHBhdGg6IGNyZWF0ZUFycmF5ZWRQYXRoKHNlbGVjdGlvbi5hbmNob3IsIGVkaXRvciksXG4gICAgb2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldFxuICB9LCBmb2N1cyA9IHtcbiAgICBwYXRoOiBjcmVhdGVBcnJheWVkUGF0aChzZWxlY3Rpb24uZm9jdXMsIGVkaXRvciksXG4gICAgb2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXMub2Zmc2V0XG4gIH07XG4gIHJldHVybiBmb2N1cy5wYXRoLmxlbmd0aCA9PT0gMCB8fCBhbmNob3IucGF0aC5sZW5ndGggPT09IDAgPyBudWxsIDogYW5jaG9yICYmIGZvY3VzID8ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG1vdmVSYW5nZUJ5T3BlcmF0aW9uKHJhbmdlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gUG9pbnQudHJhbnNmb3JtKHJhbmdlLmFuY2hvciwgb3BlcmF0aW9uKSwgZm9jdXMgPSBQb2ludC50cmFuc2Zvcm0ocmFuZ2UuZm9jdXMsIG9wZXJhdGlvbik7XG4gIHJldHVybiBhbmNob3IgPT09IG51bGwgfHwgZm9jdXMgPT09IG51bGwgPyBudWxsIDogUG9pbnQuZXF1YWxzKGFuY2hvciwgcmFuZ2UuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMoZm9jdXMsIHJhbmdlLmZvY3VzKSA/IHJhbmdlIDoge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQocG9pbnQsIHZhbHVlKSB7XG4gIGlmICghcG9pbnQgfHwgIXZhbHVlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBuZXdQYXRoID0gW107XG4gIGxldCBuZXdPZmZzZXQgPSBwb2ludC5vZmZzZXQgfHwgMDtcbiAgY29uc3QgYmxvY2tLZXkgPSB0eXBlb2YgcG9pbnQucGF0aFswXSA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHBvaW50LnBhdGhbMF0gJiYgcG9pbnQucGF0aFswXS5fa2V5LCBjaGlsZEtleSA9IHR5cGVvZiBwb2ludC5wYXRoWzJdID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gcG9pbnQucGF0aFsyXSAmJiBwb2ludC5wYXRoWzJdLl9rZXksIGJsb2NrID0gdmFsdWUuZmluZCgoYmxrKSA9PiBibGsuX2tleSA9PT0gYmxvY2tLZXkpO1xuICBpZiAoYmxvY2spXG4gICAgbmV3UGF0aC5wdXNoKHtcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9KTtcbiAgZWxzZVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoYmxvY2sgJiYgcG9pbnQucGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiKSB7XG4gICAgaWYgKCFibG9jay5jaGlsZHJlbiB8fCBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjaGlsZCA9IEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIGJsb2NrLmNoaWxkcmVuLmZpbmQoKGNsZCkgPT4gY2xkLl9rZXkgPT09IGNoaWxkS2V5KTtcbiAgICBpZiAoY2hpbGQpXG4gICAgICBuZXdQYXRoLnB1c2goXCJjaGlsZHJlblwiKSwgbmV3UGF0aC5wdXNoKHtcbiAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgfSksIG5ld09mZnNldCA9IGNoaWxkLnRleHQgJiYgY2hpbGQudGV4dC5sZW5ndGggPj0gcG9pbnQub2Zmc2V0ID8gcG9pbnQub2Zmc2V0IDogY2hpbGQudGV4dCAmJiBjaGlsZC50ZXh0Lmxlbmd0aCB8fCAwO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aDogbmV3UGF0aCxcbiAgICBvZmZzZXQ6IG5ld09mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbiwgdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb24gfHwgIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IG5ld0FuY2hvciA9IG51bGwsIG5ld0ZvY3VzID0gbnVsbDtcbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICByZXR1cm4gYW5jaG9yICYmIHZhbHVlLmZpbmQoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgX2tleTogYmxrLl9rZXlcbiAgfSwgYW5jaG9yLnBhdGhbMF0pKSAmJiAobmV3QW5jaG9yID0gbm9ybWFsaXplUG9pbnQoYW5jaG9yLCB2YWx1ZSkpLCBmb2N1cyAmJiB2YWx1ZS5maW5kKChibGspID0+IGlzRXF1YWwoe1xuICAgIF9rZXk6IGJsay5fa2V5XG4gIH0sIGZvY3VzLnBhdGhbMF0pKSAmJiAobmV3Rm9jdXMgPSBub3JtYWxpemVQb2ludChmb2N1cywgdmFsdWUpKSwgbmV3QW5jaG9yICYmIG5ld0ZvY3VzID8ge1xuICAgIGFuY2hvcjogbmV3QW5jaG9yLFxuICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICBiYWNrd2FyZDogc2VsZWN0aW9uLmJhY2t3YXJkXG4gIH0gOiBudWxsO1xufVxuY29uc3QgVk9JRF9DSElMRF9LRVkgPSBcInZvaWQtY2hpbGRcIjtcbmZ1bmN0aW9uIGtlZXBPYmplY3RFcXVhbGl0eShvYmplY3QsIGtleU1hcCkge1xuICBjb25zdCB2YWx1ZSA9IGtleU1hcFtvYmplY3QuX2tleV07XG4gIHJldHVybiB2YWx1ZSAmJiBpc0VxdWFsKG9iamVjdCwgdmFsdWUpID8gdmFsdWUgOiAoa2V5TWFwW29iamVjdC5fa2V5XSA9IG9iamVjdCwgb2JqZWN0KTtcbn1cbmZ1bmN0aW9uIHRvU2xhdGVWYWx1ZSh2YWx1ZSwge1xuICBzY2hlbWFUeXBlc1xufSwga2V5TWFwID0ge30pIHtcbiAgcmV0dXJuIHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKChibG9jaykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIF90eXBlLFxuICAgICAgX2tleSxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gYmxvY2ssIHZvaWRDaGlsZHJlbiA9IFt7XG4gICAgICBfa2V5OiBWT0lEX0NISUxEX0tFWSxcbiAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgIHRleHQ6IFwiXCIsXG4gICAgICBtYXJrczogW11cbiAgICB9XTtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUpIHtcbiAgICAgIGNvbnN0IHRleHRCbG9jayA9IGJsb2NrO1xuICAgICAgbGV0IGhhc0lubGluZXMgPSAhMTtcbiAgICAgIGNvbnN0IGhhc01pc3NpbmdTdHlsZSA9IHR5cGVvZiB0ZXh0QmxvY2suc3R5bGUgPiBcInVcIiwgaGFzTWlzc2luZ01hcmtEZWZzID0gdHlwZW9mIHRleHRCbG9jay5tYXJrRGVmcyA+IFwidVwiLCBoYXNNaXNzaW5nQ2hpbGRyZW4gPSB0eXBlb2YgdGV4dEJsb2NrLmNoaWxkcmVuID4gXCJ1XCIsIGNoaWxkcmVuID0gKHRleHRCbG9jay5jaGlsZHJlbiB8fCBbXSkubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgX3R5cGU6IGNUeXBlLFxuICAgICAgICAgIF9rZXk6IGNLZXksXG4gICAgICAgICAgLi4uY1Jlc3RcbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICByZXR1cm4gY1R5cGUgIT09IFwic3BhblwiID8gKGhhc0lubGluZXMgPSAhMCwga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgICBfdHlwZTogY1R5cGUsXG4gICAgICAgICAgX2tleTogY0tleSxcbiAgICAgICAgICBjaGlsZHJlbjogdm9pZENoaWxkcmVuLFxuICAgICAgICAgIHZhbHVlOiBjUmVzdCxcbiAgICAgICAgICBfX2lubGluZTogITBcbiAgICAgICAgfSwga2V5TWFwKSkgOiBjaGlsZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICFoYXNNaXNzaW5nU3R5bGUgJiYgIWhhc01pc3NpbmdNYXJrRGVmcyAmJiAhaGFzTWlzc2luZ0NoaWxkcmVuICYmICFoYXNJbmxpbmVzICYmIEVsZW1lbnQkMS5pc0VsZW1lbnQoYmxvY2spID8gYmxvY2sgOiAoaGFzTWlzc2luZ1N0eWxlICYmIChyZXN0LnN0eWxlID0gc2NoZW1hVHlwZXMuc3R5bGVzWzBdLnZhbHVlKSwga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgX3R5cGUsXG4gICAgICAgIF9rZXksXG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9LCBrZXlNYXApKTtcbiAgICB9XG4gICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICBfdHlwZSxcbiAgICAgIF9rZXksXG4gICAgICBjaGlsZHJlbjogdm9pZENoaWxkcmVuLFxuICAgICAgdmFsdWU6IHJlc3RcbiAgICB9LCBrZXlNYXApO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gZnJvbVNsYXRlVmFsdWUodmFsdWUsIHRleHRCbG9ja1R5cGUsIGtleU1hcCA9IHt9KSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoKGJsb2NrKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgX2tleSxcbiAgICAgIF90eXBlXG4gICAgfSA9IGJsb2NrO1xuICAgIGlmICghX2tleSB8fCAhX3R5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCBibG9ja1wiKTtcbiAgICBpZiAoX3R5cGUgPT09IHRleHRCbG9ja1R5cGUgJiYgXCJjaGlsZHJlblwiIGluIGJsb2NrICYmIEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIF9rZXkpIHtcbiAgICAgIGxldCBoYXNJbmxpbmVzID0gITE7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIF90eXBlOiBfY1R5cGVcbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGNoaWxkICYmIF9jVHlwZSAhPT0gXCJzcGFuXCIpIHtcbiAgICAgICAgICBoYXNJbmxpbmVzID0gITA7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgICAgICBfa2V5OiBrLFxuICAgICAgICAgICAgX3R5cGU6IHQsXG4gICAgICAgICAgICBfX2lubGluZTogX2ksXG4gICAgICAgICAgICBjaGlsZHJlbjogX2MsXG4gICAgICAgICAgICAuLi5yZXN0XG4gICAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICAgIHJldHVybiBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIC4uLnYsXG4gICAgICAgICAgICBfa2V5OiBrLFxuICAgICAgICAgICAgX3R5cGU6IHRcbiAgICAgICAgICB9LCBrZXlNYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhhc0lubGluZXMgPyBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgICAuLi5ibG9jayxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIF9rZXksXG4gICAgICAgIF90eXBlXG4gICAgICB9LCBrZXlNYXApIDogYmxvY2s7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrVmFsdWUgPSBcInZhbHVlXCIgaW4gYmxvY2sgJiYgYmxvY2sudmFsdWU7XG4gICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICBfa2V5LFxuICAgICAgX3R5cGUsXG4gICAgICAuLi50eXBlb2YgYmxvY2tWYWx1ZSA9PSBcIm9iamVjdFwiID8gYmxvY2tWYWx1ZSA6IHt9XG4gICAgfSwga2V5TWFwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0VxdWFsVG9FbXB0eUVkaXRvcihjaGlsZHJlbiwgc2NoZW1hVHlwZXMpIHtcbiAgcmV0dXJuIGNoaWxkcmVuID09PSB2b2lkIDAgfHwgY2hpbGRyZW4gJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBFbGVtZW50JDEuaXNFbGVtZW50KGNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSAmJiBcInN0eWxlXCIgaW4gY2hpbGRyZW5bMF0gJiYgY2hpbGRyZW5bMF0uc3R5bGUgPT09IHNjaGVtYVR5cGVzLnN0eWxlc1swXS52YWx1ZSAmJiAhKFwibGlzdEl0ZW1cIiBpbiBjaGlsZHJlblswXSkgJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlblswXS5jaGlsZHJlbikgJiYgY2hpbGRyZW5bMF0uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFRleHQuaXNUZXh0KGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5jaGlsZHJlblswXS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgIWNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLm1hcmtzPy5qb2luKFwiXCIpICYmIGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCI7XG59XG5jb25zdCBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX1BST0NFU1NJTkdfTE9DQUxfQ0hBTkdFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJU19EUkFHR0lORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX0RSQUdHSU5HX0VMRU1FTlRfVEFSR0VUID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBLRVlfVE9fU0xBVEVfRUxFTUVOVCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBLRVlfVE9fVkFMVUVfRUxFTUVOVCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIERlZmF1bHRPYmplY3QgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgJCA9IGMoNCk7XG4gIGxldCB0MDtcbiAgJFswXSAhPT0gcHJvcHMudmFsdWUgPyAodDAgPSBKU09OLnN0cmluZ2lmeShwcm9wcy52YWx1ZSwgbnVsbCwgMiksICRbMF0gPSBwcm9wcy52YWx1ZSwgJFsxXSA9IHQwKSA6IHQwID0gJFsxXTtcbiAgbGV0IHQxO1xuICByZXR1cm4gJFsyXSAhPT0gdDAgPyAodDEgPSAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJwcmVcIiwgeyBjaGlsZHJlbjogdDAgfSkgfSksICRbMl0gPSB0MCwgJFszXSA9IHQxKSA6IHQxID0gJFszXSwgdDE7XG59O1xuRGVmYXVsdE9iamVjdC5kaXNwbGF5TmFtZSA9IFwiRGVmYXVsdE9iamVjdFwiO1xuY29uc3QgRGVmYXVsdEJsb2NrT2JqZWN0ID0gc3R5bGVkLmRpdmBcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIGJvcmRlcjogJHsocHJvcHMpID0+IHByb3BzLnNlbGVjdGVkID8gXCIxcHggc29saWQgYmx1ZVwiIDogXCIxcHggc29saWQgdHJhbnNwYXJlbnRcIn07XG5gO1xuc3R5bGVkLnNwYW5gXG4gIGJhY2tncm91bmQ6ICM5OTk7XG4gIGJvcmRlcjogJHsocHJvcHMpID0+IHByb3BzLnNlbGVjdGVkID8gXCIxcHggc29saWQgYmx1ZVwiIDogXCIxcHggc29saWQgdHJhbnNwYXJlbnRcIn07XG5gO1xuY29uc3QgRGVmYXVsdExpc3RJdGVtID0gc3R5bGVkLmRpdmBcbiAgJi5wdC1saXN0LWl0ZW0ge1xuICAgIHdpZHRoOiBmaXQtY29udGVudDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZGlzcGxheTogYmxvY2s7XG5cbiAgICAvKiBJbXBvcnRhbnQgJ3RyYW5zZm9ybScgaW4gb3JkZXIgdG8gZm9yY2UgcmVmcmVzaCB0aGUgOjpiZWZvcmUgYW5kIDo6YWZ0ZXIgcnVsZXNcbiAgICAgIGluIFdlYmtpdDogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxOTQ3NjI4LzgzMTQ4MFxuICAgICovXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgIG1hcmdpbi1sZWZ0OiAkeyhwcm9wcykgPT4gZ2V0TGVmdFBvc2l0aW9uRm9yTGlzdExldmVsKHByb3BzLmxpc3RMZXZlbCl9O1xuICB9XG4gICYucHQtbGlzdC1pdGVtID4gLnB0LWxpc3QtaXRlbS1pbm5lciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgICAmOmJlZm9yZSB7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgIH1cbiAgfVxuICAmLnB0LWxpc3QtaXRlbS1idWxsZXQgPiAucHQtbGlzdC1pdGVtLWlubmVyOmJlZm9yZSB7XG4gICAgICBjb250ZW50OiAnJHsocHJvcHMpID0+IGdldENvbnRlbnRGb3JMaXN0TGV2ZWxBbmRTdHlsZShwcm9wcy5saXN0TGV2ZWwsIHByb3BzLmxpc3RTdHlsZSl9JztcbiAgICAgIGZvbnQtc2l6ZTogMC40Mzc1cmVtOyAvKiA3cHggKi9cbiAgICAgIGxpbmUtaGVpZ2h0OiAxLjVyZW07IC8qIFNhbWUgYXMgYm9keSB0ZXh0ICovXG4gICAgICAvKiBPcHRpY2FsIGFsaWdubWVudCAqL1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cbiAgfVxuICAmLnB0LWxpc3QtaXRlbS1idWxsZXQgPiAucHQtbGlzdC1pdGVtLWlubmVyIHtcbiAgICAmOmJlZm9yZSB7XG4gICAgICBtaW4td2lkdGg6IDEuNXJlbTsgLyogTWFrZSBzdXJlIHNwYWNlIGJldHdlZW4gYnVsbGV0IGFuZCB0ZXh0IG5ldmVyIHNocmlua3MgKi9cbiAgICB9XG4gIH1cbiAgJi5wdC1saXN0LWl0ZW0tbnVtYmVyIHtcbiAgICBjb3VudGVyLWluY3JlbWVudDogJHsocHJvcHMpID0+IGdldENvdW50ZXJJbmNyZW1lbnRGb3JMaXN0TGV2ZWwocHJvcHMubGlzdExldmVsKX07XG4gICAgY291bnRlci1yZXNldDogJHsocHJvcHMpID0+IGdldENvdW50ZXJSZXNldEZvckxpc3RMZXZlbChwcm9wcy5saXN0TGV2ZWwpfTtcbiAgfVxuICAmICsgOm5vdCgucHQtbGlzdC1pdGVtLW51bWJlcikge1xuICAgIGNvdW50ZXItcmVzZXQ6IGxpc3RJdGVtTnVtYmVyO1xuICB9XG4gICYucHQtbGlzdC1pdGVtLW51bWJlciA+IC5wdC1saXN0LWl0ZW0taW5uZXI6YmVmb3JlIHtcbiAgICBjb250ZW50OiAkeyhwcm9wcykgPT4gZ2V0Q291bnRlckNvbnRlbnRGb3JMaXN0TGV2ZWwocHJvcHMubGlzdExldmVsKX07XG4gICAgbWluLXdpZHRoOiAxLjVyZW07IC8qIE1ha2Ugc3VyZSBzcGFjZSBiZXR3ZWVuIG51bWJlciBhbmQgdGV4dCBuZXZlciBzaHJpbmtzICovXG4gICAgLyogT3B0aWNhbCBhbGlnbm1lbnQgKi9cbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdG9wOiAxcHg7XG4gIH1cbmAsIERlZmF1bHRMaXN0SXRlbUlubmVyID0gc3R5bGVkLmRpdmBgO1xuZnVuY3Rpb24gZ2V0TGVmdFBvc2l0aW9uRm9yTGlzdExldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAoTnVtYmVyKGxldmVsKSkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBcIjEuNWVtXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFwiM2VtXCI7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFwiNC41ZW1cIjtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gXCI2ZW1cIjtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gXCI3LjVlbVwiO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBcIjllbVwiO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBcIjEwLjVlbVwiO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBcIjEyZW1cIjtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gXCIxMy41ZW1cIjtcbiAgICBjYXNlIDEwOlxuICAgICAgcmV0dXJuIFwiMTVlbVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCIwZW1cIjtcbiAgfVxufVxuY29uc3QgYnVsbGV0cyA9IFtcIlxcdTI1Q0ZcIiwgXCJcXHUyNUNCXCIsIFwiXFx1MjVBMFwiXTtcbmZ1bmN0aW9uIGdldENvbnRlbnRGb3JMaXN0TGV2ZWxBbmRTdHlsZShsZXZlbCwgc3R5bGUpIHtcbiAgY29uc3Qgbm9ybWFsaXplZExldmVsID0gKGxldmVsIC0gMSkgJSAzO1xuICByZXR1cm4gc3R5bGUgPT09IFwiYnVsbGV0XCIgPyBidWxsZXRzW25vcm1hbGl6ZWRMZXZlbF0gOiBcIipcIjtcbn1cbmZ1bmN0aW9uIGdldENvdW50ZXJJbmNyZW1lbnRGb3JMaXN0TGV2ZWwobGV2ZWwpIHtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1BbHBoYVwiO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtUm9tYW5cIjtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbU51bWJlck5leHRcIjtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbUxldHRlck5leHRcIjtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbVJvbWFuTmV4dFwiO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dE5leHRcIjtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbUFscGhhTmV4dE5leHRcIjtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbVJvbWFuTmV4dE5leHRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1OdW1iZXJOZXh0TmV4dE5leHRcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q291bnRlclJlc2V0Rm9yTGlzdExldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbUFscGhhXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1Sb21hblwiO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dFwiO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTGV0dGVyTmV4dFwiO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtUm9tYW5OZXh0XCI7XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1OdW1iZXJOZXh0TmV4dFwiO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtQWxwaGFOZXh0TmV4dFwiO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtUm9tYW5OZXh0TmV4dFwiO1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dE5leHROZXh0XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dE5leHROZXh0XCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvdW50ZXJDb250ZW50Rm9yTGlzdExldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtTnVtYmVyKSAnLiAnXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbUFscGhhLCBsb3dlci1hbHBoYSkgJy4gJ1wiO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1Sb21hbiwgbG93ZXItcm9tYW4pICcuICdcIjtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtTnVtYmVyTmV4dCkgJy4gJ1wiO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1MZXR0ZXJOZXh0LCBsb3dlci1hbHBoYSkgJy4gJ1wiO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1Sb21hbk5leHQsIGxvd2VyLXJvbWFuKSAnLiAnXCI7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbU51bWJlck5leHROZXh0KSAnLiAnXCI7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbUFscGhhTmV4dE5leHQsIGxvd2VyLWFscGhhKSAnLiAnXCI7XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbVJvbWFuTmV4dE5leHQsIGxvd2VyLXJvbWFuKSAnLiAnXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1OdW1iZXJOZXh0TmV4dE5leHQpICcuICdcIjtcbiAgfVxufVxuY29uc3QgZGVidWckbCA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnRzOkRyYWdnYWJsZUJsb2NrXCIpLCBEcmFnZ2FibGVCbG9jayA9ICh0MCkgPT4ge1xuICBjb25zdCAkID0gYyg1MSksIHtcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50LFxuICAgIHJlYWRPbmx5LFxuICAgIGJsb2NrUmVmXG4gIH0gPSB0MCwgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKSwgZHJhZ0dob3N0UmVmID0gdXNlUmVmKCksIFtpc0RyYWdPdmVyLCBzZXRJc0RyYWdPdmVyXSA9IHVzZVN0YXRlKCExKTtcbiAgbGV0IHQxLCB0MjtcbiAgJFswXSAhPT0gZWRpdG9yIHx8ICRbMV0gIT09IGVsZW1lbnQgPyAodDIgPSBFZGl0b3IuaXNWb2lkKGVkaXRvciwgZWxlbWVudCksICRbMF0gPSBlZGl0b3IsICRbMV0gPSBlbGVtZW50LCAkWzJdID0gdDIpIDogdDIgPSAkWzJdLCB0MSA9IHQyO1xuICBjb25zdCBpc1ZvaWQgPSB0MTtcbiAgbGV0IHQzLCB0NDtcbiAgJFszXSAhPT0gZWRpdG9yIHx8ICRbNF0gIT09IGVsZW1lbnQgPyAodDQgPSBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBlbGVtZW50KSwgJFszXSA9IGVkaXRvciwgJFs0XSA9IGVsZW1lbnQsICRbNV0gPSB0NCkgOiB0NCA9ICRbNV0sIHQzID0gdDQ7XG4gIGNvbnN0IGlzSW5saW5lID0gdDMsIFtibG9ja0VsZW1lbnQsIHNldEJsb2NrRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgbGV0IHQ1LCB0NjtcbiAgJFs2XSAhPT0gYmxvY2tSZWYgfHwgJFs3XSAhPT0gZWRpdG9yIHx8ICRbOF0gIT09IGVsZW1lbnQgPyAodDUgPSAoKSA9PiBzZXRCbG9ja0VsZW1lbnQoYmxvY2tSZWYgPyBibG9ja1JlZi5jdXJyZW50IDogUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWxlbWVudCkpLCB0NiA9IFtlZGl0b3IsIGVsZW1lbnQsIGJsb2NrUmVmXSwgJFs2XSA9IGJsb2NrUmVmLCAkWzddID0gZWRpdG9yLCAkWzhdID0gZWxlbWVudCwgJFs5XSA9IHQ1LCAkWzEwXSA9IHQ2KSA6ICh0NSA9ICRbOV0sIHQ2ID0gJFsxMF0pLCB1c2VFZmZlY3QodDUsIHQ2KTtcbiAgbGV0IHQ3O1xuICAkWzExXSAhPT0gYmxvY2tFbGVtZW50IHx8ICRbMTJdICE9PSBlZGl0b3IgfHwgJFsxM10gIT09IGVsZW1lbnQgPyAodDcgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc015RHJhZ092ZXIgPSBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgIGlmICghaXNNeURyYWdPdmVyIHx8ICFibG9ja0VsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKSwgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcIm1vdmVcIiwgSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuc2V0KGVkaXRvciwgZWxlbWVudCk7XG4gICAgY29uc3QgZWxlbWVudFJlY3QgPSBibG9ja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG9mZnNldCA9IGVsZW1lbnRSZWN0LnRvcCwgaGVpZ2h0ID0gZWxlbWVudFJlY3QuaGVpZ2h0LCBZID0gZXZlbnQucGFnZVksIGxvYyA9IE1hdGguYWJzKG9mZnNldCAtIFkpO1xuICAgIGlmIChlbGVtZW50ID09PSBlZGl0b3IuY2hpbGRyZW5bMF0gfHwgKGxvYyA8IGhlaWdodCAvIDIgPyBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04uc2V0KGVkaXRvciwgXCJ0b3BcIikgOiBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04uc2V0KGVkaXRvciwgXCJib3R0b21cIikpLCBpc015RHJhZ092ZXIgPT09IGVsZW1lbnQpIHtcbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJub25lXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldElzRHJhZ092ZXIoITApO1xuICB9LCAkWzExXSA9IGJsb2NrRWxlbWVudCwgJFsxMl0gPSBlZGl0b3IsICRbMTNdID0gZWxlbWVudCwgJFsxNF0gPSB0NykgOiB0NyA9ICRbMTRdO1xuICBjb25zdCBoYW5kbGVEcmFnT3ZlciA9IHQ3O1xuICBsZXQgdDg7XG4gICRbMTVdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0OCA9ICgpID0+IHtcbiAgICBzZXRJc0RyYWdPdmVyKCExKTtcbiAgfSwgJFsxNV0gPSB0OCkgOiB0OCA9ICRbMTVdO1xuICBjb25zdCBoYW5kbGVEcmFnTGVhdmUgPSB0ODtcbiAgbGV0IHQ5O1xuICAkWzE2XSAhPT0gZWRpdG9yIHx8ICRbMTddICE9PSBlbGVtZW50ID8gKHQ5ID0gKGV2ZW50XzApID0+IHtcbiAgICBjb25zdCB0YXJnZXRCbG9jayA9IElTX0RSQUdHSU5HX0VMRU1FTlRfVEFSR0VULmdldChlZGl0b3IpO1xuICAgIGlmICh0YXJnZXRCbG9jaykge1xuICAgICAgSVNfRFJBR0dJTkcuc2V0KGVkaXRvciwgITEpLCBldmVudF8wLnByZXZlbnREZWZhdWx0KCksIGV2ZW50XzAuc3RvcFByb3BhZ2F0aW9uKCksIElTX0RSQUdHSU5HX0VMRU1FTlRfVEFSR0VULmRlbGV0ZShlZGl0b3IpLCBkcmFnR2hvc3RSZWYuY3VycmVudCAmJiAoZGVidWckbChcIlJlbW92aW5nIGRyYWcgZ2hvc3RcIiksIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZHJhZ0dob3N0UmVmLmN1cnJlbnQpKTtcbiAgICAgIGNvbnN0IGRyYWdQb3NpdGlvbiA9IElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5nZXQoZWRpdG9yKTtcbiAgICAgIElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICAgIGxldCB0YXJnZXRQYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCB0YXJnZXRCbG9jayk7XG4gICAgICBjb25zdCBteVBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIGVsZW1lbnQpLCBpc0JlZm9yZSA9IFBhdGguaXNCZWZvcmUobXlQYXRoLCB0YXJnZXRQYXRoKTtcbiAgICAgIGlmIChkcmFnUG9zaXRpb24gPT09IFwiYm90dG9tXCIgJiYgIWlzQmVmb3JlKSB7XG4gICAgICAgIGlmICh0YXJnZXRQYXRoWzBdID49IGVkaXRvci5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgZGVidWckbChcInRhcmdldCBpcyBhbHJlYWR5IGF0IHRoZSBib3R0b20sIG5vdCBtb3ZpbmdcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aCA9IHRhcmdldFBhdGg7XG4gICAgICAgIHRhcmdldFBhdGggPSBQYXRoLm5leHQodGFyZ2V0UGF0aCksIGRlYnVnJGwoYEFkanVzdGluZyB0YXJnZXRQYXRoIGZyb20gJHtKU09OLnN0cmluZ2lmeShvcmlnaW5hbFBhdGgpfSB0byAke0pTT04uc3RyaW5naWZ5KHRhcmdldFBhdGgpfWApO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdQb3NpdGlvbiA9PT0gXCJ0b3BcIiAmJiBpc0JlZm9yZSAmJiB0YXJnZXRQYXRoWzBdICE9PSBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFBhdGhfMCA9IHRhcmdldFBhdGg7XG4gICAgICAgIHRhcmdldFBhdGggPSBQYXRoLnByZXZpb3VzKHRhcmdldFBhdGgpLCBkZWJ1ZyRsKGBBZGp1c3RpbmcgdGFyZ2V0UGF0aCBmcm9tICR7SlNPTi5zdHJpbmdpZnkob3JpZ2luYWxQYXRoXzApfSB0byAke0pTT04uc3RyaW5naWZ5KHRhcmdldFBhdGgpfWApO1xuICAgICAgfVxuICAgICAgaWYgKFBhdGguZXF1YWxzKHRhcmdldFBhdGgsIG15UGF0aCkpIHtcbiAgICAgICAgZXZlbnRfMC5wcmV2ZW50RGVmYXVsdCgpLCBkZWJ1ZyRsKFwidGFyZ2V0UGF0aCBhbmQgbXlQYXRoIGlzIHRoZSBzYW1lLCBub3QgbW92aW5nXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWJ1ZyRsKGBNb3ZpbmcgZWxlbWVudCAke2VsZW1lbnQuX2tleX0gZnJvbSBwYXRoICR7SlNPTi5zdHJpbmdpZnkobXlQYXRoKX0gdG8gJHtKU09OLnN0cmluZ2lmeSh0YXJnZXRQYXRoKX0gKCR7ZHJhZ1Bvc2l0aW9ufSlgKSwgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBteVBhdGgsXG4gICAgICAgIHRvOiB0YXJnZXRQYXRoXG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlYnVnJGwoXCJObyB0YXJnZXQgZWxlbWVudCwgbm90IGRvaW5nIGFueXRoaW5nXCIpO1xuICB9LCAkWzE2XSA9IGVkaXRvciwgJFsxN10gPSBlbGVtZW50LCAkWzE4XSA9IHQ5KSA6IHQ5ID0gJFsxOF07XG4gIGNvbnN0IGhhbmRsZURyYWdFbmQgPSB0OTtcbiAgbGV0IHQxMDtcbiAgJFsxOV0gIT09IGVkaXRvciB8fCAkWzIwXSAhPT0gZWxlbWVudCA/ICh0MTAgPSAoZXZlbnRfMSkgPT4ge1xuICAgIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuZ2V0KGVkaXRvcikgJiYgKGRlYnVnJGwoXCJPbiBkcm9wIChwcmV2ZW50ZWQpXCIsIGVsZW1lbnQpLCBldmVudF8xLnByZXZlbnREZWZhdWx0KCksIGV2ZW50XzEuc3RvcFByb3BhZ2F0aW9uKCksIHNldElzRHJhZ092ZXIoITEpKTtcbiAgfSwgJFsxOV0gPSBlZGl0b3IsICRbMjBdID0gZWxlbWVudCwgJFsyMV0gPSB0MTApIDogdDEwID0gJFsyMV07XG4gIGNvbnN0IGhhbmRsZURyb3AgPSB0MTA7XG4gIGxldCB0MTE7XG4gICRbMjJdICE9PSBlZGl0b3IgfHwgJFsyM10gIT09IGVsZW1lbnQgfHwgJFsyNF0gIT09IGlzVm9pZCA/ICh0MTEgPSAoZXZlbnRfMikgPT4ge1xuICAgIGlmICghaXNWb2lkKSB7XG4gICAgICBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBJU19EUkFHR0lORy5zZXQoZWRpdG9yLCAhMCksIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuc2V0KGVkaXRvciwgZWxlbWVudCksIGV2ZW50XzIuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnRfMi50YXJnZXQ7XG4gICAgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKHRhcmdldC5zdHlsZS5vcGFjaXR5ID0gXCIxXCIpO1xuICB9LCAkWzIyXSA9IGVkaXRvciwgJFsyM10gPSBlbGVtZW50LCAkWzI0XSA9IGlzVm9pZCwgJFsyNV0gPSB0MTEpIDogdDExID0gJFsyNV07XG4gIGNvbnN0IGhhbmRsZURyYWcgPSB0MTE7XG4gIGxldCB0MTI7XG4gICRbMjZdICE9PSBibG9ja0VsZW1lbnQgfHwgJFsyN10gIT09IGVkaXRvciB8fCAkWzI4XSAhPT0gaGFuZGxlRHJhZyB8fCAkWzI5XSAhPT0gaXNJbmxpbmUgfHwgJFszMF0gIT09IGlzVm9pZCA/ICh0MTIgPSAoZXZlbnRfMykgPT4ge1xuICAgIGlmICghaXNWb2lkIHx8IGlzSW5saW5lKSB7XG4gICAgICBkZWJ1ZyRsKFwiTm90IGRyYWdnaW5nIGJsb2NrXCIpLCBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpLCBJU19EUkFHR0lORy5zZXQoZWRpdG9yLCAhMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkZWJ1ZyRsKFwiRHJhZyBzdGFydFwiKSwgSVNfRFJBR0dJTkcuc2V0KGVkaXRvciwgITApLCBldmVudF8zLmRhdGFUcmFuc2ZlciAmJiAoZXZlbnRfMy5kYXRhVHJhbnNmZXIuc2V0RGF0YShcImFwcGxpY2F0aW9uL3BvcnRhYmxlLXRleHRcIiwgXCJzb21ldGhpbmdcIiksIGV2ZW50XzMuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcIm1vdmVcIiksIGJsb2NrRWxlbWVudCAmJiBibG9ja0VsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgbGV0IGRyYWdHaG9zdCA9IGJsb2NrRWxlbWVudC5jbG9uZU5vZGUoITApO1xuICAgICAgY29uc3QgY3VzdG9tR2hvc3QgPSBkcmFnR2hvc3QucXVlcnlTZWxlY3RvcihcIltkYXRhLXB0LWRyYWctZ2hvc3QtZWxlbWVudF1cIik7XG4gICAgICBpZiAoY3VzdG9tR2hvc3QgJiYgKGRyYWdHaG9zdCA9IGN1c3RvbUdob3N0KSwgZHJhZ0dob3N0LnNldEF0dHJpYnV0ZShcImRhdGEtZHJhZ2dlZFwiLCBcIlwiKSwgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBkcmFnR2hvc3RSZWYuY3VycmVudCA9IGRyYWdHaG9zdCwgZHJhZ0dob3N0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCBkcmFnR2hvc3Quc3R5bGUubGVmdCA9IFwiLTk5OTk5cHhcIiwgZHJhZ0dob3N0LnN0eWxlLmJveFNpemluZyA9IFwiYm9yZGVyLWJveFwiLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRyYWdHaG9zdCk7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBibG9ja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHggPSBldmVudF8zLmNsaWVudFggLSByZWN0LmxlZnQsIHkgPSBldmVudF8zLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICAgICAgZHJhZ0dob3N0LnN0eWxlLndpZHRoID0gYCR7cmVjdC53aWR0aH1weGAsIGRyYWdHaG9zdC5zdHlsZS5oZWlnaHQgPSBgJHtyZWN0LmhlaWdodH1weGAsIGV2ZW50XzMuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnR2hvc3QsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEcmFnKGV2ZW50XzMpO1xuICB9LCAkWzI2XSA9IGJsb2NrRWxlbWVudCwgJFsyN10gPSBlZGl0b3IsICRbMjhdID0gaGFuZGxlRHJhZywgJFsyOV0gPSBpc0lubGluZSwgJFszMF0gPSBpc1ZvaWQsICRbMzFdID0gdDEyKSA6IHQxMiA9ICRbMzFdO1xuICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSB0MTI7XG4gIGxldCB0MTM7XG4gICRbMzJdICE9PSBlZGl0b3IgfHwgJFszM10gIT09IGlzRHJhZ092ZXIgPyAodDEzID0gaXNEcmFnT3ZlciAmJiBlZGl0b3IuY2hpbGRyZW5bMF0gPT09IElTX0RSQUdHSU5HX0VMRU1FTlRfVEFSR0VULmdldChlZGl0b3IpLCAkWzMyXSA9IGVkaXRvciwgJFszM10gPSBpc0RyYWdPdmVyLCAkWzM0XSA9IHQxMykgOiB0MTMgPSAkWzM0XTtcbiAgY29uc3QgaXNEcmFnZ2luZ092ZXJGaXJzdEJsb2NrID0gdDEzO1xuICBsZXQgdDE0O1xuICAkWzM1XSAhPT0gZWRpdG9yIHx8ICRbMzZdICE9PSBpc0RyYWdPdmVyID8gKHQxNCA9IGlzRHJhZ092ZXIgJiYgZWRpdG9yLmNoaWxkcmVuW2VkaXRvci5jaGlsZHJlbi5sZW5ndGggLSAxXSA9PT0gSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZ2V0KGVkaXRvciksICRbMzVdID0gZWRpdG9yLCAkWzM2XSA9IGlzRHJhZ092ZXIsICRbMzddID0gdDE0KSA6IHQxNCA9ICRbMzddO1xuICBjb25zdCBpc0RyYWdnaW5nT3Zlckxhc3RCbG9jayA9IHQxNCwgZHJhZ1Bvc2l0aW9uXzAgPSBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04uZ2V0KGVkaXRvciksIGlzRHJhZ2dpbmdPdmVyVG9wID0gaXNEcmFnZ2luZ092ZXJGaXJzdEJsb2NrIHx8IGlzRHJhZ092ZXIgJiYgIWlzRHJhZ2dpbmdPdmVyRmlyc3RCbG9jayAmJiAhaXNEcmFnZ2luZ092ZXJMYXN0QmxvY2sgJiYgZHJhZ1Bvc2l0aW9uXzAgPT09IFwidG9wXCIsIGlzRHJhZ2dpbmdPdmVyQm90dG9tID0gaXNEcmFnZ2luZ092ZXJMYXN0QmxvY2sgfHwgaXNEcmFnT3ZlciAmJiAhaXNEcmFnZ2luZ092ZXJGaXJzdEJsb2NrICYmICFpc0RyYWdnaW5nT3Zlckxhc3RCbG9jayAmJiBkcmFnUG9zaXRpb25fMCA9PT0gXCJib3R0b21cIjtcbiAgbGV0IHQxNSwgdDE2O1xuICAkWzM4XSA9PT0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIikgPyAodDE2ID0gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJwdC1kcm9wLWluZGljYXRvclwiLCBzdHlsZToge1xuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogMSxcbiAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIGN1cnJlbnRDb2xvclwiLFxuICAgIHpJbmRleDogNVxuICB9IH0pLCAkWzM4XSA9IHQxNikgOiB0MTYgPSAkWzM4XSwgdDE1ID0gdDE2O1xuICBjb25zdCBkcm9wSW5kaWNhdG9yID0gdDE1O1xuICBpZiAocmVhZE9ubHkpIHtcbiAgICBsZXQgdDE3MjtcbiAgICByZXR1cm4gJFszOV0gIT09IGNoaWxkcmVuID8gKHQxNzIgPSAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuIH0pLCAkWzM5XSA9IGNoaWxkcmVuLCAkWzQwXSA9IHQxNzIpIDogdDE3MiA9ICRbNDBdLCB0MTcyO1xuICB9XG4gIGNvbnN0IHQxNyA9IGlzRHJhZ2dpbmdPdmVyVG9wICYmIGRyb3BJbmRpY2F0b3IsIHQxOCA9IGlzRHJhZ2dpbmdPdmVyQm90dG9tICYmIGRyb3BJbmRpY2F0b3I7XG4gIGxldCB0MTk7XG4gIHJldHVybiAkWzQxXSAhPT0gY2hpbGRyZW4gfHwgJFs0Ml0gIT09IGhhbmRsZURyYWcgfHwgJFs0M10gIT09IGhhbmRsZURyYWdFbmQgfHwgJFs0NF0gIT09IGhhbmRsZURyYWdPdmVyIHx8ICRbNDVdICE9PSBoYW5kbGVEcmFnU3RhcnQgfHwgJFs0Nl0gIT09IGhhbmRsZURyb3AgfHwgJFs0N10gIT09IGlzVm9pZCB8fCAkWzQ4XSAhPT0gdDE3IHx8ICRbNDldICE9PSB0MTggPyAodDE5ID0gLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgeyBkcmFnZ2FibGU6IGlzVm9pZCwgb25EcmFnU3RhcnQ6IGhhbmRsZURyYWdTdGFydCwgb25EcmFnOiBoYW5kbGVEcmFnLCBvbkRyYWdPdmVyOiBoYW5kbGVEcmFnT3Zlciwgb25EcmFnTGVhdmU6IGhhbmRsZURyYWdMZWF2ZSwgb25EcmFnRW5kOiBoYW5kbGVEcmFnRW5kLCBvbkRyb3A6IGhhbmRsZURyb3AsIGNoaWxkcmVuOiBbXG4gICAgdDE3LFxuICAgIGNoaWxkcmVuLFxuICAgIHQxOFxuICBdIH0pLCAkWzQxXSA9IGNoaWxkcmVuLCAkWzQyXSA9IGhhbmRsZURyYWcsICRbNDNdID0gaGFuZGxlRHJhZ0VuZCwgJFs0NF0gPSBoYW5kbGVEcmFnT3ZlciwgJFs0NV0gPSBoYW5kbGVEcmFnU3RhcnQsICRbNDZdID0gaGFuZGxlRHJvcCwgJFs0N10gPSBpc1ZvaWQsICRbNDhdID0gdDE3LCAkWzQ5XSA9IHQxOCwgJFs1MF0gPSB0MTkpIDogdDE5ID0gJFs1MF0sIHQxOTtcbn07XG5EcmFnZ2FibGVCbG9jay5kaXNwbGF5TmFtZSA9IFwiRHJhZ2dhYmxlQmxvY2tcIjtcbmRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnRzOkVsZW1lbnRcIik7XG5jb25zdCBFTVBUWV9BTk5PVEFUSU9OUyA9IFtdLCBpbmxpbmVCbG9ja1N0eWxlID0ge1xuICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiXG59LCBFbGVtZW50ID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgY2hpbGRyZW4sXG4gIGVsZW1lbnQsXG4gIHNjaGVtYVR5cGVzLFxuICByZWFkT25seSxcbiAgcmVuZGVyQmxvY2ssXG4gIHJlbmRlckNoaWxkLFxuICByZW5kZXJMaXN0SXRlbSxcbiAgcmVuZGVyU3R5bGUsXG4gIHNwZWxsQ2hlY2tcbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKSwgc2VsZWN0ZWQgPSB1c2VTZWxlY3RlZCgpLCBibG9ja1JlZiA9IHVzZVJlZihudWxsKSwgaW5saW5lQmxvY2tPYmplY3RSZWYgPSB1c2VSZWYobnVsbCksIGZvY3VzZWQgPSBzZWxlY3RlZCAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pIHx8ICExLCB2YWx1ZSA9IHVzZU1lbW8oKCkgPT4gZnJvbVNsYXRlVmFsdWUoW2VsZW1lbnRdLCBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF0sIFtlZGl0b3IsIGVsZW1lbnQsIHNjaGVtYVR5cGVzLmJsb2NrLm5hbWVdKTtcbiAgbGV0IHJlbmRlcmVkQmxvY2sgPSBjaGlsZHJlbiwgY2xhc3NOYW1lO1xuICBjb25zdCBibG9ja1BhdGggPSB1c2VNZW1vKCgpID0+IFt7XG4gICAgX2tleTogZWxlbWVudC5fa2V5XG4gIH1dLCBbZWxlbWVudF0pO1xuICBpZiAodHlwZW9mIGVsZW1lbnQuX3R5cGUgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBlbGVtZW50IHRvIGhhdmUgYSBfdHlwZSBwcm9wZXJ0eVwiKTtcbiAgaWYgKHR5cGVvZiBlbGVtZW50Ll9rZXkgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBlbGVtZW50IHRvIGhhdmUgYSBfa2V5IHByb3BlcnR5XCIpO1xuICBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgY29uc3QgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgZWxlbWVudCksIFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgsIHtcbiAgICAgIGRlcHRoOiAxXG4gICAgfSksIHNjaGVtYVR5cGUgPSBzY2hlbWFUeXBlcy5pbmxpbmVPYmplY3RzLmZpbmQoKF90eXBlKSA9PiBfdHlwZS5uYW1lID09PSBlbGVtZW50Ll90eXBlKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCB0eXBlIGZvciBpbmxpbmUgYmxvY2sgZWxlbWVudFwiKTtcbiAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykpIHtcbiAgICAgIGNvbnN0IGVsbVBhdGggPSBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogZWxlbWVudC5fa2V5XG4gICAgICB9XTtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyAuLi5hdHRyaWJ1dGVzLCBjaGlsZHJlbjogW1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgZHJhZ2dhYmxlOiAhcmVhZE9ubHksIGNsYXNzTmFtZTogXCJwdC1pbmxpbmUtb2JqZWN0XCIsIFwiZGF0YS10ZXN0aWRcIjogXCJwdC1pbmxpbmUtb2JqZWN0XCIsIHJlZjogaW5saW5lQmxvY2tPYmplY3RSZWYsIHN0eWxlOiBpbmxpbmVCbG9ja1N0eWxlLCBjb250ZW50RWRpdGFibGU6ICExLCBjaGlsZHJlbjogW1xuICAgICAgICAgIHJlbmRlckNoaWxkICYmIHJlbmRlckNoaWxkKHtcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBFTVBUWV9BTk5PVEFUSU9OUyxcbiAgICAgICAgICAgIC8vIFRoZXNlIGlubGluZSBvYmplY3RzIGN1cnJlbnRseSBkb2Vzbid0IHN1cHBvcnQgYW5ub3RhdGlvbnMuIFRoaXMgaXMgYSBsaW1pdGF0aW9uIG9mIHRoZSBjdXJyZW50IFBUIHNwZWMvbW9kZWwuXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0T2JqZWN0LCB7IHZhbHVlIH0pLFxuICAgICAgICAgICAgZWRpdG9yRWxlbWVudFJlZjogaW5saW5lQmxvY2tPYmplY3RSZWYsXG4gICAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgICAgcGF0aDogZWxtUGF0aCxcbiAgICAgICAgICAgIHNjaGVtYVR5cGUsXG4gICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgIHR5cGU6IHNjaGVtYVR5cGUsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgICFyZW5kZXJDaGlsZCAmJiAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRPYmplY3QsIHsgdmFsdWUgfSlcbiAgICAgICAgXSB9LCBlbGVtZW50Ll9rZXkpXG4gICAgICBdIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayBub3QgZm91bmQhXCIpO1xuICB9XG4gIGlmIChlbGVtZW50Ll90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lKSB7XG4gICAgY2xhc3NOYW1lID0gXCJwdC1ibG9jayBwdC10ZXh0LWJsb2NrXCI7XG4gICAgY29uc3QgaXNMaXN0SXRlbSA9IFwibGlzdEl0ZW1cIiBpbiBlbGVtZW50LCBzdHlsZSA9IFwic3R5bGVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQuc3R5bGUgfHwgXCJub3JtYWxcIjtcbiAgICBjbGFzc05hbWUgPSBgcHQtYmxvY2sgcHQtdGV4dC1ibG9jayBwdC10ZXh0LWJsb2NrLXN0eWxlLSR7c3R5bGV9YDtcbiAgICBjb25zdCBibG9ja1N0eWxlVHlwZSA9IHNjaGVtYVR5cGVzLnN0eWxlcy5maW5kKChpdGVtKSA9PiBpdGVtLnZhbHVlID09PSBzdHlsZSk7XG4gICAgcmVuZGVyU3R5bGUgJiYgYmxvY2tTdHlsZVR5cGUgJiYgKHJlbmRlcmVkQmxvY2sgPSByZW5kZXJTdHlsZSh7XG4gICAgICBibG9jazogZWxlbWVudCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZm9jdXNlZCxcbiAgICAgIHNlbGVjdGVkLFxuICAgICAgdmFsdWU6IHN0eWxlLFxuICAgICAgcGF0aDogYmxvY2tQYXRoLFxuICAgICAgc2NoZW1hVHlwZTogYmxvY2tTdHlsZVR5cGUsXG4gICAgICBlZGl0b3JFbGVtZW50UmVmOiBibG9ja1JlZlxuICAgIH0pKTtcbiAgICBsZXQgbGV2ZWw7XG4gICAgaWYgKGlzTGlzdEl0ZW0gJiYgKHR5cGVvZiBlbGVtZW50LmxldmVsID09IFwibnVtYmVyXCIgJiYgKGxldmVsID0gZWxlbWVudC5sZXZlbCksIGNsYXNzTmFtZSArPSBgIHB0LWxpc3QtaXRlbSBwdC1saXN0LWl0ZW0tJHtlbGVtZW50Lmxpc3RJdGVtfSBwdC1saXN0LWl0ZW0tbGV2ZWwtJHtsZXZlbCB8fCAxfWApLCBlZGl0b3IuaXNMaXN0QmxvY2sodmFsdWUpICYmIGlzTGlzdEl0ZW0gJiYgZWxlbWVudC5saXN0SXRlbSkge1xuICAgICAgY29uc3QgbGlzdFR5cGUgPSBzY2hlbWFUeXBlcy5saXN0cy5maW5kKChpdGVtXzApID0+IGl0ZW1fMC52YWx1ZSA9PT0gZWxlbWVudC5saXN0SXRlbSk7XG4gICAgICByZW5kZXJMaXN0SXRlbSAmJiBsaXN0VHlwZSA/IHJlbmRlcmVkQmxvY2sgPSByZW5kZXJMaXN0SXRlbSh7XG4gICAgICAgIGJsb2NrOiB2YWx1ZSxcbiAgICAgICAgY2hpbGRyZW46IHJlbmRlcmVkQmxvY2ssXG4gICAgICAgIGZvY3VzZWQsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgICAgICB2YWx1ZTogZWxlbWVudC5saXN0SXRlbSxcbiAgICAgICAgcGF0aDogYmxvY2tQYXRoLFxuICAgICAgICBzY2hlbWFUeXBlOiBsaXN0VHlwZSxcbiAgICAgICAgbGV2ZWw6IHZhbHVlLmxldmVsIHx8IDEsXG4gICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmXG4gICAgICB9KSA6IHJlbmRlcmVkQmxvY2sgPSAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRMaXN0SXRlbSwgeyBsaXN0U3R5bGU6IHZhbHVlLmxpc3RJdGVtIHx8IHNjaGVtYVR5cGVzLmxpc3RzWzBdLnZhbHVlLCBsaXN0TGV2ZWw6IHZhbHVlLmxldmVsIHx8IDEsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRMaXN0SXRlbUlubmVyLCB7IGNoaWxkcmVuOiByZW5kZXJlZEJsb2NrIH0pIH0pO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICBjaGlsZHJlbjogcmVuZGVyZWRCbG9jayxcbiAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmLFxuICAgICAgZm9jdXNlZCxcbiAgICAgIGxldmVsLFxuICAgICAgbGlzdEl0ZW06IGlzTGlzdEl0ZW0gPyBlbGVtZW50Lmxpc3RJdGVtIDogdm9pZCAwLFxuICAgICAgcGF0aDogYmxvY2tQYXRoLFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICBzdHlsZSxcbiAgICAgIHNjaGVtYVR5cGU6IHNjaGVtYVR5cGVzLmJsb2NrLFxuICAgICAgdmFsdWVcbiAgICB9LCBcInR5cGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZXMuYmxvY2s7XG4gICAgICB9XG4gICAgfSksIHByb3BzT3JEZWZhdWx0UmVuZGVyZWQgPSByZW5kZXJCbG9jayA/IHJlbmRlckJsb2NrKHJlbmRlclByb3BzKSA6IGNoaWxkcmVuO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgLi4uYXR0cmlidXRlcywgY2xhc3NOYW1lLCBzcGVsbENoZWNrLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEcmFnZ2FibGVCbG9jaywgeyBlbGVtZW50LCByZWFkT25seSwgYmxvY2tSZWYsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgcmVmOiBibG9ja1JlZiwgY2hpbGRyZW46IHByb3BzT3JEZWZhdWx0UmVuZGVyZWQgfSkgfSkgfSwgZWxlbWVudC5fa2V5KTtcbiAgfVxuICBjb25zdCBzY2hlbWFUeXBlXzAgPSBzY2hlbWFUeXBlcy5ibG9ja09iamVjdHMuZmluZCgoX3R5cGVfMCkgPT4gX3R5cGVfMC5uYW1lID09PSBlbGVtZW50Ll90eXBlKTtcbiAgaWYgKCFzY2hlbWFUeXBlXzApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBzY2hlbWEgdHlwZSBmb3IgYmxvY2sgZWxlbWVudCBvZiBfdHlwZSAke2VsZW1lbnQuX3R5cGV9YCk7XG4gIGNsYXNzTmFtZSA9IFwicHQtYmxvY2sgcHQtb2JqZWN0LWJsb2NrXCI7XG4gIGNvbnN0IGJsb2NrXzAgPSBmcm9tU2xhdGVWYWx1ZShbZWxlbWVudF0sIHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXTtcbiAgbGV0IHJlbmRlcmVkQmxvY2tGcm9tUHJvcHM7XG4gIGlmIChyZW5kZXJCbG9jaykge1xuICAgIGNvbnN0IF9wcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0T2JqZWN0LCB7IHZhbHVlIH0pLFxuICAgICAgZWRpdG9yRWxlbWVudFJlZjogYmxvY2tSZWYsXG4gICAgICBmb2N1c2VkLFxuICAgICAgcGF0aDogYmxvY2tQYXRoLFxuICAgICAgc2NoZW1hVHlwZTogc2NoZW1hVHlwZV8wLFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICB2YWx1ZTogYmxvY2tfMFxuICAgIH0sIFwidHlwZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIlByb3BlcnR5ICd0eXBlJyBpcyBkZXByZWNhdGVkLCB1c2UgJ3NjaGVtYVR5cGUnIGluc3RlYWQuXCIpLCBzY2hlbWFUeXBlXzA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVuZGVyZWRCbG9ja0Zyb21Qcm9wcyA9IHJlbmRlckJsb2NrKF9wcm9wcyk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgLi4uYXR0cmlidXRlcywgY2xhc3NOYW1lLCBjaGlsZHJlbjogW1xuICAgIGNoaWxkcmVuLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKERyYWdnYWJsZUJsb2NrLCB7IGVsZW1lbnQsIHJlYWRPbmx5LCBibG9ja1JlZiwgY2hpbGRyZW46IFtcbiAgICAgIHJlbmRlcmVkQmxvY2tGcm9tUHJvcHMgJiYgLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHJlZjogYmxvY2tSZWYsIGNvbnRlbnRFZGl0YWJsZTogITEsIGNoaWxkcmVuOiByZW5kZXJlZEJsb2NrRnJvbVByb3BzIH0pLFxuICAgICAgIXJlbmRlcmVkQmxvY2tGcm9tUHJvcHMgJiYgLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0QmxvY2tPYmplY3QsIHsgc2VsZWN0ZWQsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRPYmplY3QsIHsgdmFsdWUgfSkgfSlcbiAgICBdIH0pXG4gIF0gfSwgZWxlbWVudC5fa2V5KTtcbn07XG5FbGVtZW50LmRpc3BsYXlOYW1lID0gXCJFbGVtZW50XCI7XG5jb25zdCBQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKSwgdXNlUG9ydGFibGVUZXh0RWRpdG9yID0gKCkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VDb250ZXh0KFBvcnRhYmxlVGV4dEVkaXRvckNvbnRleHQpO1xuICBpZiAoIWVkaXRvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVBvcnRhYmxlVGV4dEVkaXRvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8UG9ydGFibGVUZXh0RWRpdG9yPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5mdW5jdGlvbiBEZWZhdWx0QW5ub3RhdGlvbihwcm9wcykge1xuICBjb25zdCAkID0gYyg2KTtcbiAgbGV0IHQwO1xuICAkWzBdICE9PSBwcm9wcy5hbm5vdGF0aW9uID8gKHQwID0gKCkgPT4gYWxlcnQoSlNPTi5zdHJpbmdpZnkocHJvcHMuYW5ub3RhdGlvbikpLCAkWzBdID0gcHJvcHMuYW5ub3RhdGlvbiwgJFsxXSA9IHQwKSA6IHQwID0gJFsxXTtcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSB0MDtcbiAgbGV0IHQxO1xuICAkWzJdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0MSA9IHtcbiAgICBjb2xvcjogXCJibHVlXCJcbiAgfSwgJFsyXSA9IHQxKSA6IHQxID0gJFsyXTtcbiAgbGV0IHQyO1xuICByZXR1cm4gJFszXSAhPT0gaGFuZGxlQ2xpY2sgfHwgJFs0XSAhPT0gcHJvcHMuY2hpbGRyZW4gPyAodDIgPSAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IHN0eWxlOiB0MSwgb25DbGljazogaGFuZGxlQ2xpY2ssIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFszXSA9IGhhbmRsZUNsaWNrLCAkWzRdID0gcHJvcHMuY2hpbGRyZW4sICRbNV0gPSB0MikgOiB0MiA9ICRbNV0sIHQyO1xufVxuRGVmYXVsdEFubm90YXRpb24uZGlzcGxheU5hbWUgPSBcIkRlZmF1bHRBbm5vdGF0aW9uXCI7XG5mdW5jdGlvbiBjb21waWxlVHlwZShyYXdUeXBlKSB7XG4gIHJldHVybiBTY2hlbWEuY29tcGlsZSh7XG4gICAgbmFtZTogXCJibG9ja1R5cGVTY2hlbWFcIixcbiAgICB0eXBlczogW3Jhd1R5cGVdXG4gIH0pLmdldChyYXdUeXBlLm5hbWUpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSwgdHlwZXMsIGtleUdlbmVyYXRvcikge1xuICBsZXQgcmVzb2x1dGlvbiA9IG51bGwsIHZhbGlkID0gITA7XG4gIGNvbnN0IHZhbGlkQ2hpbGRUeXBlcyA9IFt0eXBlcy5zcGFuLm5hbWUsIC4uLnR5cGVzLmlubGluZU9iamVjdHMubWFwKCh0KSA9PiB0Lm5hbWUpXSwgdmFsaWRCbG9ja1R5cGVzID0gW3R5cGVzLmJsb2NrLm5hbWUsIC4uLnR5cGVzLmJsb2NrT2JqZWN0cy5tYXAoKHQpID0+IHQubmFtZSldO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICB2YWxpZDogITAsXG4gICAgcmVzb2x1dGlvbjogbnVsbCxcbiAgICB2YWx1ZVxuICB9IDogIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCA/IHtcbiAgICB2YWxpZDogITEsXG4gICAgcmVzb2x1dGlvbjoge1xuICAgICAgcGF0Y2hlczogW3Vuc2V0KFtdKV0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJFZGl0b3IgdmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBQb3J0YWJsZSBUZXh0IGJsb2Nrcywgb3IgdW5kZWZpbmVkLlwiLFxuICAgICAgYWN0aW9uOiBcIlVuc2V0IHRoZSB2YWx1ZVwiLFxuICAgICAgaXRlbTogdmFsdWUsXG4gICAgICBpMThuOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLWFycmF5LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1hcnJheS5hY3Rpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWVcbiAgfSA6ICh2YWx1ZS5zb21lKChibGssIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGJsaykpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFtpbmRleF0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayBtdXN0IGJlIGFuIG9iamVjdCwgZ290ICR7U3RyaW5nKGJsayl9YCxcbiAgICAgICAgYWN0aW9uOiBcIlVuc2V0IGludmFsaWQgaXRlbVwiLFxuICAgICAgICBpdGVtOiBibGssXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1vYmplY3QuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub3QtYW4tb2JqZWN0LmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwO1xuICAgIGlmICghYmxrLl9rZXkgfHwgdHlwZW9mIGJsay5fa2V5ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgICAgIH0sIFtpbmRleF0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayBhdCBpbmRleCAke2luZGV4fSBpcyBtaXNzaW5nIHJlcXVpcmVkIF9rZXkuYCxcbiAgICAgICAgYWN0aW9uOiBcIlNldCB0aGUgYmxvY2sgd2l0aCBhIHJhbmRvbSBfa2V5IHZhbHVlXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1rZXkuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWtleS5hY3Rpb25cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAhMDtcbiAgICBpZiAoIWJsay5fdHlwZSB8fCAhdmFsaWRCbG9ja1R5cGVzLmluY2x1ZGVzKGJsay5fdHlwZSkpIHtcbiAgICAgIGlmIChibGsuX3R5cGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tUeXBlTmFtZSA9IHR5cGVzLmJsb2NrLm5hbWU7XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgICAgX3R5cGU6IGN1cnJlbnRCbG9ja1R5cGVOYW1lXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkIHR5cGUgbmFtZSAnJHtibGsuX3R5cGV9Jy4gQWNjb3JkaW5nIHRvIHRoZSBzY2hlbWEsIHRoZSBibG9jayB0eXBlIG5hbWUgaXMgJyR7Y3VycmVudEJsb2NrVHlwZU5hbWV9J2AsXG4gICAgICAgICAgYWN0aW9uOiBgVXNlIHR5cGUgJyR7Y3VycmVudEJsb2NrVHlwZU5hbWV9J2AsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW5jb3JyZWN0LWJsb2NrLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmluY29ycmVjdC1ibG9jay10eXBlLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgIGV4cGVjdGVkVHlwZU5hbWU6IGN1cnJlbnRCbG9ja1R5cGVOYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhYmxrLl90eXBlICYmIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKHtcbiAgICAgICAgLi4uYmxrLFxuICAgICAgICBfdHlwZTogdHlwZXMuYmxvY2submFtZVxuICAgICAgfSkgPyAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgLi4uYmxrLFxuICAgICAgICAgIF90eXBlOiB0eXBlcy5ibG9jay5uYW1lXG4gICAgICAgIH0sIFt7XG4gICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgfV0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBpcyBtaXNzaW5nIGEgdHlwZSBuYW1lLiBBY2NvcmRpbmcgdG8gdGhlIHNjaGVtYSwgdGhlIGJsb2NrIHR5cGUgbmFtZSBpcyAnJHt0eXBlcy5ibG9jay5uYW1lfSdgLFxuICAgICAgICBhY3Rpb246IGBVc2UgdHlwZSAnJHt0eXBlcy5ibG9jay5uYW1lfSdgLFxuICAgICAgICBpdGVtOiBibGssXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctYmxvY2stdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctYmxvY2stdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICBleHBlY3RlZFR5cGVOYW1lOiB0eXBlcy5ibG9jay5uYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAhMCkgOiBibGsuX3R5cGUgPyAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7XG4gICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgfV0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBoYXMgaW52YWxpZCBfdHlwZSAnJHtibGsuX3R5cGV9J2AsXG4gICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIGJsb2NrXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZGlzYWxsb3dlZC10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZGlzYWxsb3dlZC10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBibGsuX3R5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwKSA6IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGlzIG1pc3NpbmcgYW4gX3R5cGUgcHJvcGVydHlgLFxuICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBibG9ja1wiLFxuICAgICAgICBpdGVtOiBibGssXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIGtleTogYmxrLl9rZXlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwKTtcbiAgICB9XG4gICAgaWYgKGJsay5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZSkge1xuICAgICAgY29uc3QgdGV4dEJsb2NrID0gYmxrO1xuICAgICAgaWYgKHRleHRCbG9jay5jaGlsZHJlbiAmJiAhQXJyYXkuaXNBcnJheSh0ZXh0QmxvY2suY2hpbGRyZW4pKVxuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgIH0sIFt7XG4gICAgICAgICAgICBfa2V5OiB0ZXh0QmxvY2suX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBUZXh0IGJsb2NrIHdpdGggX2tleSAnJHt0ZXh0QmxvY2suX2tleX0nIGhhcyBhIGludmFsaWQgcmVxdWlyZWQgcHJvcGVydHkgJ2NoaWxkcmVuJy5gLFxuICAgICAgICAgIGFjdGlvbjogXCJSZXNldCB0aGUgY2hpbGRyZW4gcHJvcGVydHlcIixcbiAgICAgICAgICBpdGVtOiB0ZXh0QmxvY2ssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLW9yLWludmFsaWQtY2hpbGRyZW4uZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmctb3ItaW52YWxpZC1jaGlsZHJlbi5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IHRleHRCbG9jay5fa2V5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMDtcbiAgICAgIGlmICh0ZXh0QmxvY2suY2hpbGRyZW4gPT09IHZvaWQgMCB8fCBBcnJheS5pc0FycmF5KHRleHRCbG9jay5jaGlsZHJlbikgJiYgdGV4dEJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBuZXdTcGFuID0ge1xuICAgICAgICAgIF90eXBlOiB0eXBlcy5zcGFuLm5hbWUsXG4gICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICBtYXJrczogW11cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgYXV0b1Jlc29sdmU6ICEwLFxuICAgICAgICAgIHBhdGNoZXM6IFtzZXRJZk1pc3NpbmcoW10sIFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIl0pLCBpbnNlcnQoW25ld1NwYW5dLCBcImFmdGVyXCIsIFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgMF0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkcmVuIGZvciB0ZXh0IGJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGlzIGVtcHR5LmAsXG4gICAgICAgICAgYWN0aW9uOiBcIkluc2VydCBhbiBlbXB0eSB0ZXh0XCIsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZW1wdHktY2hpbGRyZW4uZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmVtcHR5LWNoaWxkcmVuLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwO1xuICAgICAgfVxuICAgICAgY29uc3QgYWxsVXNlZE1hcmtzID0gdW5pcShmbGF0dGVuKHRleHRCbG9jay5jaGlsZHJlbi5maWx0ZXIoKGNsZCkgPT4gY2xkLl90eXBlID09PSB0eXBlcy5zcGFuLm5hbWUpLm1hcCgoY2xkKSA9PiBjbGQubWFya3MgfHwgW10pKSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShibGsubWFya0RlZnMpICYmIGJsay5tYXJrRGVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHVudXNlZE1hcmtEZWZzID0gdW5pcShibGsubWFya0RlZnMubWFwKChkZWYpID0+IGRlZi5fa2V5KS5maWx0ZXIoKGtleSkgPT4gIWFsbFVzZWRNYXJrcy5pbmNsdWRlcyhrZXkpKSk7XG4gICAgICAgIGlmICh1bnVzZWRNYXJrRGVmcy5sZW5ndGggPiAwKVxuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgYXV0b1Jlc29sdmU6ICEwLFxuICAgICAgICAgICAgcGF0Y2hlczogdW51c2VkTWFya0RlZnMubWFwKChtYXJrRGVmS2V5KSA9PiB1bnNldChbe1xuICAgICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfSwgXCJtYXJrRGVmc1wiLCB7XG4gICAgICAgICAgICAgIF9rZXk6IG1hcmtEZWZLZXlcbiAgICAgICAgICAgIH1dKSksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIGNvbnRhaW5zIG9ycGhhbmVkIGRhdGEgKHVudXNlZCBtYXJrIGRlZmluaXRpb25zKTogJHt1bnVzZWRNYXJrRGVmcy5qb2luKFwiLCBcIil9LmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHVudXNlZCBtYXJrIGRlZmluaXRpb24gaXRlbVwiLFxuICAgICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmstZGVmcy5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrLWRlZnMuYWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgICAgdW51c2VkTWFya0RlZnM6IHVudXNlZE1hcmtEZWZzLm1hcCgobSkgPT4gbS50b1N0cmluZygpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICB9XG4gICAgICBjb25zdCBvcnBoYW5lZE1hcmtzID0gYWxsVXNlZE1hcmtzLmZpbHRlcigobWFyaykgPT4gIXR5cGVzLmRlY29yYXRvcnMubWFwKChkZWMpID0+IGRlYy52YWx1ZSkuaW5jbHVkZXMobWFyaykpLmZpbHRlcigobWFyaykgPT4gdGV4dEJsb2NrLm1hcmtEZWZzID09PSB2b2lkIDAgfHwgIXRleHRCbG9jay5tYXJrRGVmcy5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrKSk7XG4gICAgICBpZiAob3JwaGFuZWRNYXJrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHNwYW5DaGlsZHJlbiA9IHRleHRCbG9jay5jaGlsZHJlbi5maWx0ZXIoKGNsZCkgPT4gY2xkLl90eXBlID09PSB0eXBlcy5zcGFuLm5hbWUgJiYgQXJyYXkuaXNBcnJheShjbGQubWFya3MpICYmIGNsZC5tYXJrcy5zb21lKChtYXJrKSA9PiBvcnBoYW5lZE1hcmtzLmluY2x1ZGVzKG1hcmspKSk7XG4gICAgICAgIGlmIChzcGFuQ2hpbGRyZW4pIHtcbiAgICAgICAgICBjb25zdCBvcnBoYW5lZCA9IG9ycGhhbmVkTWFya3Muam9pbihcIiwgXCIpO1xuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgYXV0b1Jlc29sdmU6ICEwLFxuICAgICAgICAgICAgcGF0Y2hlczogc3BhbkNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHNldCgoY2hpbGQubWFya3MgfHwgW10pLmZpbHRlcigoY01yaykgPT4gIW9ycGhhbmVkTWFya3MuaW5jbHVkZXMoY01yaykpLCBbe1xuICAgICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH0sIFwibWFya3NcIl0pKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgY29udGFpbnMgbWFya3MgKCR7b3JwaGFuZWR9KSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGNvbnRlbnQgbW9kZWwuYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgaW52YWxpZCBtYXJrc1wiLFxuICAgICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmtzLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmtzLmFjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICAgIG9ycGhhbmVkTWFya3M6IG9ycGhhbmVkTWFya3MubWFwKChtKSA9PiBtLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dEJsb2NrLmNoaWxkcmVuLnNvbWUoKGNoaWxkLCBjSW5kZXgpID0+IHtcbiAgICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KGNoaWxkKSlcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCBjSW5kZXhdKV0sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIGF0IGluZGV4ICcke2NJbmRleH0nIGluIGJsb2NrIHdpdGgga2V5ICcke2Jsay5fa2V5fScgaXMgbm90IGFuIG9iamVjdC5gLFxuICAgICAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgaXRlbVwiLFxuICAgICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vbi1vYmplY3QtY2hpbGQuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm9uLW9iamVjdC1jaGlsZC5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICBpbmRleDogY0luZGV4XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgICAgaWYgKCFjaGlsZC5fa2V5IHx8IHR5cGVvZiBjaGlsZC5fa2V5ICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IHtcbiAgICAgICAgICAgIC4uLmNoaWxkLFxuICAgICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgYXV0b1Jlc29sdmU6ICEwLFxuICAgICAgICAgICAgcGF0Y2hlczogW3NldChuZXdDaGlsZCwgW3tcbiAgICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgY0luZGV4XSldLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCBhdCBpbmRleCAke2NJbmRleH0gaXMgbWlzc2luZyByZXF1aXJlZCBfa2V5IGluIGJsb2NrIHdpdGggX2tleSAke2Jsay5fa2V5fS5gLFxuICAgICAgICAgICAgYWN0aW9uOiBcIlNldCBhIG5ldyByYW5kb20gX2tleSBvbiB0aGUgb2JqZWN0XCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1jaGlsZC1rZXkuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1jaGlsZC1rZXkuYWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgICAgaW5kZXg6IGNJbmRleFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkLl90eXBlID8gdmFsaWRDaGlsZFR5cGVzLmluY2x1ZGVzKGNoaWxkLl90eXBlKSA/IGNoaWxkLl90eXBlID09PSB0eXBlcy5zcGFuLm5hbWUgJiYgdHlwZW9mIGNoaWxkLnRleHQgIT0gXCJzdHJpbmdcIiA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgICAgLi4uY2hpbGQsXG4gICAgICAgICAgICB0ZXh0OiBcIlwiXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIHdpdGggX2tleSAnJHtjaGlsZC5fa2V5fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBoYXMgbWlzc2luZyBvciBpbnZhbGlkIHRleHQgcHJvcGVydHkhYCxcbiAgICAgICAgICBhY3Rpb246IFwiV3JpdGUgYW4gZW1wdHkgdGV4dCBwcm9wZXJ0eSB0byB0aGUgb2JqZWN0XCIsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW52YWxpZC1zcGFuLXRleHQuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmludmFsaWQtc3Bhbi10ZXh0LmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgIGNoaWxkS2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMCkgOiAhMSA6IChyZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICB9XSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgd2l0aCBfa2V5ICcke2NoaWxkLl9rZXl9JyBpbiBibG9jayB3aXRoIGtleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkICdfdHlwZScgcHJvcGVydHkgKCR7Y2hpbGQuX3R5cGV9KS5gLFxuICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIG9iamVjdFwiLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmRpc2FsbG93ZWQtY2hpbGQtdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZGlzYWxsb3dlZC1jaGlsZC10eXBlLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgIGNoaWxkS2V5OiBjaGlsZC5fa2V5LFxuICAgICAgICAgICAgICBjaGlsZFR5cGU6IGNoaWxkLl90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMCkgOiAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIHdpdGggX2tleSAnJHtjaGlsZC5fa2V5fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBpcyBtaXNzaW5nICdfdHlwZScgcHJvcGVydHkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBvYmplY3RcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQtdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICBjaGlsZEtleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITApO1xuICAgICAgfSkgJiYgKHZhbGlkID0gITEpO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH0pICYmICh2YWxpZCA9ICExKSwge1xuICAgIHZhbGlkLFxuICAgIHJlc29sdXRpb24sXG4gICAgdmFsdWVcbiAgfSk7XG59XG5mdW5jdGlvbiB3aXRoUmVtb3RlQ2hhbmdlcyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSB8fCAhMTtcbiAgSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5zZXQoZWRpdG9yLCAhMCksIGZuKCksIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSB7XG4gIHJldHVybiBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTLmdldChlZGl0b3IpO1xufVxuZnVuY3Rpb24gaXNDaGFuZ2luZ0xvY2FsbHkoZWRpdG9yKSB7XG4gIHJldHVybiBJU19QUk9DRVNTSU5HX0xPQ0FMX0NIQU5HRVMuZ2V0KGVkaXRvcik7XG59XG5jb25zdCBQQVRDSElORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd2l0aG91dFBhdGNoaW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzUGF0Y2hpbmcoZWRpdG9yKTtcbiAgUEFUQ0hJTkcuc2V0KGVkaXRvciwgITEpLCBmbigpLCBQQVRDSElORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzUGF0Y2hpbmcoZWRpdG9yKSB7XG4gIHJldHVybiBQQVRDSElORy5nZXQoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIGlzSGlnaFN1cnJvZ2F0ZShjaGFyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY2hhckNvZGUgPj0gNTUyOTYgJiYgY2hhckNvZGUgPD0gNTYzMTk7XG59XG5mdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjaGFyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY2hhckNvZGUgPj0gNTYzMjAgJiYgY2hhckNvZGUgPD0gNTczNDM7XG59XG5mdW5jdGlvbiBjbG9uZURpZmYoZGlmZjIpIHtcbiAgY29uc3QgW3R5cGUsIHBhdGNoXSA9IGRpZmYyO1xuICByZXR1cm4gW3R5cGUsIHBhdGNoXTtcbn1cbmZ1bmN0aW9uIGdldENvbW1vbk92ZXJsYXAodGV4dEEsIHRleHRCKSB7XG4gIGxldCB0ZXh0MSA9IHRleHRBLCB0ZXh0MiA9IHRleHRCO1xuICBjb25zdCB0ZXh0MUxlbmd0aCA9IHRleHQxLmxlbmd0aCwgdGV4dDJMZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XG4gIGlmICh0ZXh0MUxlbmd0aCA9PT0gMCB8fCB0ZXh0Mkxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gMDtcbiAgdGV4dDFMZW5ndGggPiB0ZXh0Mkxlbmd0aCA/IHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGgpIDogdGV4dDFMZW5ndGggPCB0ZXh0Mkxlbmd0aCAmJiAodGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDFMZW5ndGgpKTtcbiAgY29uc3QgdGV4dExlbmd0aCA9IE1hdGgubWluKHRleHQxTGVuZ3RoLCB0ZXh0Mkxlbmd0aCk7XG4gIGlmICh0ZXh0MSA9PT0gdGV4dDIpXG4gICAgcmV0dXJuIHRleHRMZW5ndGg7XG4gIGxldCBiZXN0ID0gMCwgbGVuZ3RoID0gMTtcbiAgZm9yIChsZXQgZm91bmQgPSAwOyBmb3VuZCAhPT0gLTE7ICkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSB0ZXh0MS5zdWJzdHJpbmcodGV4dExlbmd0aCAtIGxlbmd0aCk7XG4gICAgaWYgKGZvdW5kID0gdGV4dDIuaW5kZXhPZihwYXR0ZXJuKSwgZm91bmQgPT09IC0xKVxuICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgbGVuZ3RoICs9IGZvdW5kLCAoZm91bmQgPT09IDAgfHwgdGV4dDEuc3Vic3RyaW5nKHRleHRMZW5ndGggLSBsZW5ndGgpID09PSB0ZXh0Mi5zdWJzdHJpbmcoMCwgbGVuZ3RoKSkgJiYgKGJlc3QgPSBsZW5ndGgsIGxlbmd0aCsrKTtcbiAgfVxuICByZXR1cm4gYmVzdDtcbn1cbmZ1bmN0aW9uIGdldENvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpIHtcbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDFbMF0gIT09IHRleHQyWzBdKVxuICAgIHJldHVybiAwO1xuICBsZXQgcG9pbnRlck1pbiA9IDAsIHBvaW50ZXJNYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCksIHBvaW50ZXJNaWQgPSBwb2ludGVyTWF4LCBwb2ludGVyU3RhcnQgPSAwO1xuICBmb3IgKDsgcG9pbnRlck1pbiA8IHBvaW50ZXJNaWQ7IClcbiAgICB0ZXh0MS5zdWJzdHJpbmcocG9pbnRlclN0YXJ0LCBwb2ludGVyTWlkKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHBvaW50ZXJTdGFydCwgcG9pbnRlck1pZCkgPyAocG9pbnRlck1pbiA9IHBvaW50ZXJNaWQsIHBvaW50ZXJTdGFydCA9IHBvaW50ZXJNaW4pIDogcG9pbnRlck1heCA9IHBvaW50ZXJNaWQsIHBvaW50ZXJNaWQgPSBNYXRoLmZsb29yKChwb2ludGVyTWF4IC0gcG9pbnRlck1pbikgLyAyICsgcG9pbnRlck1pbik7XG4gIHJldHVybiBwb2ludGVyTWlkO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mikge1xuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MVt0ZXh0MS5sZW5ndGggLSAxXSAhPT0gdGV4dDJbdGV4dDIubGVuZ3RoIC0gMV0pXG4gICAgcmV0dXJuIDA7XG4gIGxldCBwb2ludGVyTWluID0gMCwgcG9pbnRlck1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKSwgcG9pbnRlck1pZCA9IHBvaW50ZXJNYXgsIHBvaW50ZXJFbmQgPSAwO1xuICBmb3IgKDsgcG9pbnRlck1pbiA8IHBvaW50ZXJNaWQ7IClcbiAgICB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gcG9pbnRlck1pZCwgdGV4dDEubGVuZ3RoIC0gcG9pbnRlckVuZCkgPT09IHRleHQyLnN1YnN0cmluZyh0ZXh0Mi5sZW5ndGggLSBwb2ludGVyTWlkLCB0ZXh0Mi5sZW5ndGggLSBwb2ludGVyRW5kKSA/IChwb2ludGVyTWluID0gcG9pbnRlck1pZCwgcG9pbnRlckVuZCA9IHBvaW50ZXJNaW4pIDogcG9pbnRlck1heCA9IHBvaW50ZXJNaWQsIHBvaW50ZXJNaWQgPSBNYXRoLmZsb29yKChwb2ludGVyTWF4IC0gcG9pbnRlck1pbikgLyAyICsgcG9pbnRlck1pbik7XG4gIHJldHVybiBwb2ludGVyTWlkO1xufVxuZnVuY3Rpb24gY2xlYW51cFNlbWFudGljKHJhd0RpZmZzKSB7XG4gIGxldCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpLCBoYXNDaGFuZ2VzID0gITE7XG4gIGNvbnN0IGVxdWFsaXRpZXMgPSBbXTtcbiAgbGV0IGVxdWFsaXRpZXNMZW5ndGggPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBwb2ludGVyID0gMCwgbGVuZ3RoSW5zZXJ0aW9uczEgPSAwLCBsZW5ndGhEZWxldGlvbnMxID0gMCwgbGVuZ3RoSW5zZXJ0aW9uczIgPSAwLCBsZW5ndGhEZWxldGlvbnMyID0gMDtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7IClcbiAgICBkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9FUVVBTCA/IChlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyLCBsZW5ndGhJbnNlcnRpb25zMSA9IGxlbmd0aEluc2VydGlvbnMyLCBsZW5ndGhEZWxldGlvbnMxID0gbGVuZ3RoRGVsZXRpb25zMiwgbGVuZ3RoSW5zZXJ0aW9uczIgPSAwLCBsZW5ndGhEZWxldGlvbnMyID0gMCwgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV0pIDogKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0lOU0VSVCA/IGxlbmd0aEluc2VydGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA6IGxlbmd0aERlbGV0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoLCBsYXN0RXF1YWxpdHkgJiYgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhJbnNlcnRpb25zMSwgbGVuZ3RoRGVsZXRpb25zMSkgJiYgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhJbnNlcnRpb25zMiwgbGVuZ3RoRGVsZXRpb25zMikgJiYgKGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCwgW0RJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHldKSwgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJULCBlcXVhbGl0aWVzTGVuZ3RoLS0sIGVxdWFsaXRpZXNMZW5ndGgtLSwgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMSwgbGVuZ3RoSW5zZXJ0aW9uczEgPSAwLCBsZW5ndGhEZWxldGlvbnMxID0gMCwgbGVuZ3RoSW5zZXJ0aW9uczIgPSAwLCBsZW5ndGhEZWxldGlvbnMyID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgaGFzQ2hhbmdlcyA9ICEwKSksIHBvaW50ZXIrKztcbiAgZm9yIChoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcyA9IGNsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKSwgcG9pbnRlciA9IDE7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfREVMRVRFICYmIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgY29uc3QgZGVsZXRpb24gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0sIGluc2VydGlvbiA9IGRpZmZzW3BvaW50ZXJdWzFdLCBvdmVybGFwTGVuZ3RoMSA9IGdldENvbW1vbk92ZXJsYXAoZGVsZXRpb24sIGluc2VydGlvbiksIG92ZXJsYXBMZW5ndGgyID0gZ2V0Q29tbW9uT3ZlcmxhcChpbnNlcnRpb24sIGRlbGV0aW9uKTtcbiAgICAgIG92ZXJsYXBMZW5ndGgxID49IG92ZXJsYXBMZW5ndGgyID8gKG92ZXJsYXBMZW5ndGgxID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHwgb3ZlcmxhcExlbmd0aDEgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfRVFVQUwsIGluc2VydGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcExlbmd0aDEpXSksIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGRlbGV0aW9uLnN1YnN0cmluZygwLCBkZWxldGlvbi5sZW5ndGggLSBvdmVybGFwTGVuZ3RoMSksIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcob3ZlcmxhcExlbmd0aDEpLCBwb2ludGVyKyspIDogKG92ZXJsYXBMZW5ndGgyID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHwgb3ZlcmxhcExlbmd0aDIgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfRVFVQUwsIGRlbGV0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwTGVuZ3RoMildKSwgZGlmZnNbcG9pbnRlciAtIDFdWzBdID0gRElGRl9JTlNFUlQsIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcoMCwgaW5zZXJ0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgyKSwgZGlmZnNbcG9pbnRlciArIDFdWzBdID0gRElGRl9ERUxFVEUsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRlbGV0aW9uLnN1YnN0cmluZyhvdmVybGFwTGVuZ3RoMiksIHBvaW50ZXIrKyksIHBvaW50ZXIrKztcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn1cbmNvbnN0IG5vbkFscGhhTnVtZXJpY1JlZ2V4ID0gL1teYS16QS1aMC05XS8sIHdoaXRlc3BhY2VSZWdleCA9IC9cXHMvLCBsaW5lYnJlYWtSZWdleCA9IC9bXFxyXFxuXS8sIGJsYW5rbGluZUVuZFJlZ2V4ID0gL1xcblxccj9cXG4kLywgYmxhbmtsaW5lU3RhcnRSZWdleCA9IC9eXFxyP1xcblxccj9cXG4vO1xuZnVuY3Rpb24gY2xlYW51cFNlbWFudGljTG9zc2xlc3MocmF3RGlmZnMpIHtcbiAgY29uc3QgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKTtcbiAgZnVuY3Rpb24gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFvbmUgfHwgIXR3bylcbiAgICAgIHJldHVybiA2O1xuICAgIGNvbnN0IGNoYXIxID0gb25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSksIGNoYXIyID0gdHdvLmNoYXJBdCgwKSwgbm9uQWxwaGFOdW1lcmljMSA9IGNoYXIxLm1hdGNoKG5vbkFscGhhTnVtZXJpY1JlZ2V4KSwgbm9uQWxwaGFOdW1lcmljMiA9IGNoYXIyLm1hdGNoKG5vbkFscGhhTnVtZXJpY1JlZ2V4KSwgd2hpdGVzcGFjZTEgPSBub25BbHBoYU51bWVyaWMxICYmIGNoYXIxLm1hdGNoKHdoaXRlc3BhY2VSZWdleCksIHdoaXRlc3BhY2UyID0gbm9uQWxwaGFOdW1lcmljMiAmJiBjaGFyMi5tYXRjaCh3aGl0ZXNwYWNlUmVnZXgpLCBsaW5lQnJlYWsxID0gd2hpdGVzcGFjZTEgJiYgY2hhcjEubWF0Y2gobGluZWJyZWFrUmVnZXgpLCBsaW5lQnJlYWsyID0gd2hpdGVzcGFjZTIgJiYgY2hhcjIubWF0Y2gobGluZWJyZWFrUmVnZXgpLCBibGFua0xpbmUxID0gbGluZUJyZWFrMSAmJiBvbmUubWF0Y2goYmxhbmtsaW5lRW5kUmVnZXgpLCBibGFua0xpbmUyID0gbGluZUJyZWFrMiAmJiB0d28ubWF0Y2goYmxhbmtsaW5lU3RhcnRSZWdleCk7XG4gICAgcmV0dXJuIGJsYW5rTGluZTEgfHwgYmxhbmtMaW5lMiA/IDUgOiBsaW5lQnJlYWsxIHx8IGxpbmVCcmVhazIgPyA0IDogbm9uQWxwaGFOdW1lcmljMSAmJiAhd2hpdGVzcGFjZTEgJiYgd2hpdGVzcGFjZTIgPyAzIDogd2hpdGVzcGFjZTEgfHwgd2hpdGVzcGFjZTIgPyAyIDogbm9uQWxwaGFOdW1lcmljMSB8fCBub25BbHBoYU51bWVyaWMyID8gMSA6IDA7XG4gIH1cbiAgbGV0IHBvaW50ZXIgPSAxO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDE7ICkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZnNbcG9pbnRlciArIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICBsZXQgZXF1YWxpdHkxID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLCBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV0sIGVxdWFsaXR5MiA9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgIGNvbnN0IGNvbW1vbk9mZnNldCA9IGdldENvbW1vblN1ZmZpeChlcXVhbGl0eTEsIGVkaXQpO1xuICAgICAgaWYgKGNvbW1vbk9mZnNldCkge1xuICAgICAgICBjb25zdCBjb21tb25TdHJpbmcgPSBlZGl0LnN1YnN0cmluZyhlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XG4gICAgICAgIGVxdWFsaXR5MSA9IGVxdWFsaXR5MS5zdWJzdHJpbmcoMCwgZXF1YWxpdHkxLmxlbmd0aCAtIGNvbW1vbk9mZnNldCksIGVkaXQgPSBjb21tb25TdHJpbmcgKyBlZGl0LnN1YnN0cmluZygwLCBlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCksIGVxdWFsaXR5MiA9IGNvbW1vblN0cmluZyArIGVxdWFsaXR5MjtcbiAgICAgIH1cbiAgICAgIGxldCBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxLCBiZXN0RWRpdCA9IGVkaXQsIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTIsIGJlc3RTY29yZSA9IGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlcXVhbGl0eTEsIGVkaXQpICsgZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICBmb3IgKDsgZWRpdC5jaGFyQXQoMCkgPT09IGVxdWFsaXR5Mi5jaGFyQXQoMCk7ICkge1xuICAgICAgICBlcXVhbGl0eTEgKz0gZWRpdC5jaGFyQXQoMCksIGVkaXQgPSBlZGl0LnN1YnN0cmluZygxKSArIGVxdWFsaXR5Mi5jaGFyQXQoMCksIGVxdWFsaXR5MiA9IGVxdWFsaXR5Mi5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgICAgc2NvcmUgPj0gYmVzdFNjb3JlICYmIChiZXN0U2NvcmUgPSBzY29yZSwgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MSwgYmVzdEVkaXQgPSBlZGl0LCBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyKTtcbiAgICAgIH1cbiAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSAhPT0gYmVzdEVxdWFsaXR5MSAmJiAoYmVzdEVxdWFsaXR5MSA/IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGJlc3RFcXVhbGl0eTEgOiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKSwgcG9pbnRlci0tKSwgZGlmZnNbcG9pbnRlcl1bMV0gPSBiZXN0RWRpdCwgYmVzdEVxdWFsaXR5MiA/IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGJlc3RFcXVhbGl0eTIgOiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKSwgcG9pbnRlci0tKSk7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICByZXR1cm4gZGlmZnM7XG59XG5mdW5jdGlvbiBjbGVhbnVwTWVyZ2UocmF3RGlmZnMpIHtcbiAgbGV0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSk7XG4gIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIFwiXCJdKTtcbiAgbGV0IHBvaW50ZXIgPSAwLCBjb3VudERlbGV0ZSA9IDAsIGNvdW50SW5zZXJ0ID0gMCwgdGV4dERlbGV0ZSA9IFwiXCIsIHRleHRJbnNlcnQgPSBcIlwiLCBjb21tb25sZW5ndGg7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApXG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgY291bnRJbnNlcnQrKywgdGV4dEluc2VydCArPSBkaWZmc1twb2ludGVyXVsxXSwgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50RGVsZXRlKyssIHRleHREZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV0sIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQgPiAxID8gKGNvdW50RGVsZXRlICE9PSAwICYmIGNvdW50SW5zZXJ0ICE9PSAwICYmIChjb21tb25sZW5ndGggPSBnZXRDb21tb25QcmVmaXgodGV4dEluc2VydCwgdGV4dERlbGV0ZSksIGNvbW1vbmxlbmd0aCAhPT0gMCAmJiAocG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgPiAwICYmIGRpZmZzW3BvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0IC0gMV1bMF0gPT09IERJRkZfRVFVQUwgPyBkaWZmc1twb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCAtIDFdWzFdICs9IHRleHRJbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCkgOiAoZGlmZnMuc3BsaWNlKDAsIDAsIFtESUZGX0VRVUFMLCB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpXSksIHBvaW50ZXIrKyksIHRleHRJbnNlcnQgPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZyhjb21tb25sZW5ndGgpLCB0ZXh0RGVsZXRlID0gdGV4dERlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSksIGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblN1ZmZpeCh0ZXh0SW5zZXJ0LCB0ZXh0RGVsZXRlKSwgY29tbW9ubGVuZ3RoICE9PSAwICYmIChkaWZmc1twb2ludGVyXVsxXSA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKHRleHRJbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXJdWzFdLCB0ZXh0SW5zZXJ0ID0gdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgdGV4dEluc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpLCB0ZXh0RGVsZXRlID0gdGV4dERlbGV0ZS5zdWJzdHJpbmcoMCwgdGV4dERlbGV0ZS5sZW5ndGggLSBjb21tb25sZW5ndGgpKSksIHBvaW50ZXIgLT0gY291bnREZWxldGUgKyBjb3VudEluc2VydCwgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQpLCB0ZXh0RGVsZXRlLmxlbmd0aCAmJiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIFtESUZGX0RFTEVURSwgdGV4dERlbGV0ZV0pLCBwb2ludGVyKyspLCB0ZXh0SW5zZXJ0Lmxlbmd0aCAmJiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIFtESUZGX0lOU0VSVCwgdGV4dEluc2VydF0pLCBwb2ludGVyKyspLCBwb2ludGVyKyspIDogcG9pbnRlciAhPT0gMCAmJiBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgPyAoZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXJdWzFdLCBkaWZmcy5zcGxpY2UocG9pbnRlciwgMSkpIDogcG9pbnRlcisrLCBjb3VudEluc2VydCA9IDAsIGNvdW50RGVsZXRlID0gMCwgdGV4dERlbGV0ZSA9IFwiXCIsIHRleHRJbnNlcnQgPSBcIlwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGlmZiBvcGVyYXRpb25cIik7XG4gICAgfVxuICBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gXCJcIiAmJiBkaWZmcy5wb3AoKTtcbiAgbGV0IGhhc0NoYW5nZXMgPSAhMTtcbiAgZm9yIChwb2ludGVyID0gMTsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDE7IClcbiAgICBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZnNbcG9pbnRlciArIDFdWzBdID09PSBESUZGX0VRVUFMICYmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCkgPT09IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA/IChkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdLCBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpLCBoYXNDaGFuZ2VzID0gITApIDogZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09PSBkaWZmc1twb2ludGVyICsgMV1bMV0gJiYgKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICsgZGlmZnNbcG9pbnRlciArIDFdWzFdLCBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICByZXR1cm4gaGFzQ2hhbmdlcyAmJiAoZGlmZnMgPSBjbGVhbnVwTWVyZ2UoZGlmZnMpKSwgZGlmZnM7XG59XG5mdW5jdGlvbiB0cnVlQ291bnQoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKylcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICByZXR1cm4gYXJncy5yZWR1Y2UoKG4sIGJvb2wpID0+IG4gKyAoYm9vbCA/IDEgOiAwKSwgMCk7XG59XG5mdW5jdGlvbiBjbGVhbnVwRWZmaWNpZW5jeShyYXdEaWZmcykge1xuICBsZXQgZWRpdENvc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDQsIGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksIGhhc0NoYW5nZXMgPSAhMTtcbiAgY29uc3QgZXF1YWxpdGllcyA9IFtdO1xuICBsZXQgZXF1YWxpdGllc0xlbmd0aCA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwsIHBvaW50ZXIgPSAwLCBwcmVJbnMgPSAhMSwgcHJlRGVsID0gITEsIHBvc3RJbnMgPSAhMSwgcG9zdERlbCA9ICExO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKVxuICAgIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMID8gKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IGVkaXRDb3N0ICYmIChwb3N0SW5zIHx8IHBvc3REZWwpID8gKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXIsIHByZUlucyA9IHBvc3RJbnMsIHByZURlbCA9IHBvc3REZWwsIGxhc3RFcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdKSA6IChlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCksIHBvc3RJbnMgPSAhMSwgcG9zdERlbCA9ICExKSA6IChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9ERUxFVEUgPyBwb3N0RGVsID0gITAgOiBwb3N0SW5zID0gITAsIGxhc3RFcXVhbGl0eSAmJiAocHJlSW5zICYmIHByZURlbCAmJiBwb3N0SW5zICYmIHBvc3REZWwgfHwgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8IGVkaXRDb3N0IC8gMiAmJiB0cnVlQ291bnQocHJlSW5zLCBwcmVEZWwsIHBvc3RJbnMsIHBvc3REZWwpID09PSAzKSAmJiAoZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eV0pLCBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQsIGVxdWFsaXRpZXNMZW5ndGgtLSwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcHJlSW5zICYmIHByZURlbCA/IChwb3N0SW5zID0gITAsIHBvc3REZWwgPSAhMCwgZXF1YWxpdGllc0xlbmd0aCA9IDApIDogKGVxdWFsaXRpZXNMZW5ndGgtLSwgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITEpLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICByZXR1cm4gaGFzQ2hhbmdlcyAmJiAoZGlmZnMgPSBjbGVhbnVwTWVyZ2UoZGlmZnMpKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBiaXNlY3QodGV4dDEsIHRleHQyLCBkZWFkbGluZSkge1xuICBjb25zdCB0ZXh0MUxlbmd0aCA9IHRleHQxLmxlbmd0aCwgdGV4dDJMZW5ndGggPSB0ZXh0Mi5sZW5ndGgsIG1heEQgPSBNYXRoLmNlaWwoKHRleHQxTGVuZ3RoICsgdGV4dDJMZW5ndGgpIC8gMiksIHZPZmZzZXQgPSBtYXhELCB2TGVuZ3RoID0gMiAqIG1heEQsIHYxID0gbmV3IEFycmF5KHZMZW5ndGgpLCB2MiA9IG5ldyBBcnJheSh2TGVuZ3RoKTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB2TGVuZ3RoOyB4KyspXG4gICAgdjFbeF0gPSAtMSwgdjJbeF0gPSAtMTtcbiAgdjFbdk9mZnNldCArIDFdID0gMCwgdjJbdk9mZnNldCArIDFdID0gMDtcbiAgY29uc3QgZGVsdGEgPSB0ZXh0MUxlbmd0aCAtIHRleHQyTGVuZ3RoLCBmcm9udCA9IGRlbHRhICUgMiAhPT0gMDtcbiAgbGV0IGsxc3RhcnQgPSAwLCBrMWVuZCA9IDAsIGsyc3RhcnQgPSAwLCBrMmVuZCA9IDA7XG4gIGZvciAobGV0IGQgPSAwOyBkIDwgbWF4RCAmJiAhKERhdGUubm93KCkgPiBkZWFkbGluZSk7IGQrKykge1xuICAgIGZvciAobGV0IGsxID0gLWQgKyBrMXN0YXJ0OyBrMSA8PSBkIC0gazFlbmQ7IGsxICs9IDIpIHtcbiAgICAgIGNvbnN0IGsxT2Zmc2V0ID0gdk9mZnNldCArIGsxO1xuICAgICAgbGV0IHgxO1xuICAgICAgazEgPT09IC1kIHx8IGsxICE9PSBkICYmIHYxW2sxT2Zmc2V0IC0gMV0gPCB2MVtrMU9mZnNldCArIDFdID8geDEgPSB2MVtrMU9mZnNldCArIDFdIDogeDEgPSB2MVtrMU9mZnNldCAtIDFdICsgMTtcbiAgICAgIGxldCB5MSA9IHgxIC0gazE7XG4gICAgICBmb3IgKDsgeDEgPCB0ZXh0MUxlbmd0aCAmJiB5MSA8IHRleHQyTGVuZ3RoICYmIHRleHQxLmNoYXJBdCh4MSkgPT09IHRleHQyLmNoYXJBdCh5MSk7IClcbiAgICAgICAgeDErKywgeTErKztcbiAgICAgIGlmICh2MVtrMU9mZnNldF0gPSB4MSwgeDEgPiB0ZXh0MUxlbmd0aClcbiAgICAgICAgazFlbmQgKz0gMjtcbiAgICAgIGVsc2UgaWYgKHkxID4gdGV4dDJMZW5ndGgpXG4gICAgICAgIGsxc3RhcnQgKz0gMjtcbiAgICAgIGVsc2UgaWYgKGZyb250KSB7XG4gICAgICAgIGNvbnN0IGsyT2Zmc2V0ID0gdk9mZnNldCArIGRlbHRhIC0gazE7XG4gICAgICAgIGlmIChrMk9mZnNldCA+PSAwICYmIGsyT2Zmc2V0IDwgdkxlbmd0aCAmJiB2MltrMk9mZnNldF0gIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgeDIgPSB0ZXh0MUxlbmd0aCAtIHYyW2syT2Zmc2V0XTtcbiAgICAgICAgICBpZiAoeDEgPj0geDIpXG4gICAgICAgICAgICByZXR1cm4gYmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCB4MSwgeTEsIGRlYWRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrMiA9IC1kICsgazJzdGFydDsgazIgPD0gZCAtIGsyZW5kOyBrMiArPSAyKSB7XG4gICAgICBjb25zdCBrMk9mZnNldCA9IHZPZmZzZXQgKyBrMjtcbiAgICAgIGxldCB4MjtcbiAgICAgIGsyID09PSAtZCB8fCBrMiAhPT0gZCAmJiB2MltrMk9mZnNldCAtIDFdIDwgdjJbazJPZmZzZXQgKyAxXSA/IHgyID0gdjJbazJPZmZzZXQgKyAxXSA6IHgyID0gdjJbazJPZmZzZXQgLSAxXSArIDE7XG4gICAgICBsZXQgeTIgPSB4MiAtIGsyO1xuICAgICAgZm9yICg7IHgyIDwgdGV4dDFMZW5ndGggJiYgeTIgPCB0ZXh0Mkxlbmd0aCAmJiB0ZXh0MS5jaGFyQXQodGV4dDFMZW5ndGggLSB4MiAtIDEpID09PSB0ZXh0Mi5jaGFyQXQodGV4dDJMZW5ndGggLSB5MiAtIDEpOyApXG4gICAgICAgIHgyKyssIHkyKys7XG4gICAgICBpZiAodjJbazJPZmZzZXRdID0geDIsIHgyID4gdGV4dDFMZW5ndGgpXG4gICAgICAgIGsyZW5kICs9IDI7XG4gICAgICBlbHNlIGlmICh5MiA+IHRleHQyTGVuZ3RoKVxuICAgICAgICBrMnN0YXJ0ICs9IDI7XG4gICAgICBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazFPZmZzZXQgPSB2T2Zmc2V0ICsgZGVsdGEgLSBrMjtcbiAgICAgICAgaWYgKGsxT2Zmc2V0ID49IDAgJiYgazFPZmZzZXQgPCB2TGVuZ3RoICYmIHYxW2sxT2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MSA9IHYxW2sxT2Zmc2V0XSwgeTEgPSB2T2Zmc2V0ICsgeDEgLSBrMU9mZnNldDtcbiAgICAgICAgICBpZiAoeDIgPSB0ZXh0MUxlbmd0aCAtIHgyLCB4MSA+PSB4MilcbiAgICAgICAgICAgIHJldHVybiBiaXNlY3RTcGxpdCh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV0sIFtESUZGX0lOU0VSVCwgdGV4dDJdXTtcbn1cbmZ1bmN0aW9uIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeCwgeSwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpLCB0ZXh0MmEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSksIHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KSwgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpLCBkaWZmcyA9IGRvRGlmZih0ZXh0MWEsIHRleHQyYSwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lXG4gIH0pLCBkaWZmc2IgPSBkb0RpZmYodGV4dDFiLCB0ZXh0MmIsIHtcbiAgICBjaGVja0xpbmVzOiAhMSxcbiAgICBkZWFkbGluZVxuICB9KTtcbiAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xufVxuZnVuY3Rpb24gZmluZEhhbGZNYXRjaCh0ZXh0MSwgdGV4dDIpIHtcbiAgaWYgKChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IDEpIDw9IDApXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGxvbmdUZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0Miwgc2hvcnRUZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgaWYgKGxvbmdUZXh0Lmxlbmd0aCA8IDQgfHwgc2hvcnRUZXh0Lmxlbmd0aCAqIDIgPCBsb25nVGV4dC5sZW5ndGgpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGhhbGZNYXRjaDEgPSBoYWxmTWF0Y2hJKGxvbmdUZXh0LCBzaG9ydFRleHQsIE1hdGguY2VpbChsb25nVGV4dC5sZW5ndGggLyA0KSksIGhhbGZNYXRjaDIgPSBoYWxmTWF0Y2hJKGxvbmdUZXh0LCBzaG9ydFRleHQsIE1hdGguY2VpbChsb25nVGV4dC5sZW5ndGggLyAyKSk7XG4gIGxldCBoYWxmTWF0Y2g7XG4gIGlmIChoYWxmTWF0Y2gxICYmIGhhbGZNYXRjaDIpXG4gICAgaGFsZk1hdGNoID0gaGFsZk1hdGNoMVs0XS5sZW5ndGggPiBoYWxmTWF0Y2gyWzRdLmxlbmd0aCA/IGhhbGZNYXRjaDEgOiBoYWxmTWF0Y2gyO1xuICBlbHNlIHtcbiAgICBpZiAoIWhhbGZNYXRjaDEgJiYgIWhhbGZNYXRjaDIpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBoYWxmTWF0Y2gyID8gaGFsZk1hdGNoMSB8fCAoaGFsZk1hdGNoID0gaGFsZk1hdGNoMikgOiBoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gxO1xuICB9XG4gIGlmICghaGFsZk1hdGNoKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGEgaGFsZiBtYXRjaC5cIik7XG4gIGxldCB0ZXh0MUEsIHRleHQxQiwgdGV4dDJBLCB0ZXh0MkI7XG4gIHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/ICh0ZXh0MUEgPSBoYWxmTWF0Y2hbMF0sIHRleHQxQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDJBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbM10pIDogKHRleHQyQSA9IGhhbGZNYXRjaFswXSwgdGV4dDJCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MUEgPSBoYWxmTWF0Y2hbMl0sIHRleHQxQiA9IGhhbGZNYXRjaFszXSk7XG4gIGNvbnN0IG1pZENvbW1vbiA9IGhhbGZNYXRjaFs0XTtcbiAgcmV0dXJuIFt0ZXh0MUEsIHRleHQxQiwgdGV4dDJBLCB0ZXh0MkIsIG1pZENvbW1vbl07XG59XG5mdW5jdGlvbiBoYWxmTWF0Y2hJKGxvbmdUZXh0LCBzaG9ydFRleHQsIGkpIHtcbiAgY29uc3Qgc2VlZCA9IGxvbmdUZXh0LnNsaWNlKGksIGkgKyBNYXRoLmZsb29yKGxvbmdUZXh0Lmxlbmd0aCAvIDQpKTtcbiAgbGV0IGogPSAtMSwgYmVzdENvbW1vbiA9IFwiXCIsIGJlc3RMb25nVGV4dEEsIGJlc3RMb25nVGV4dEIsIGJlc3RTaG9ydFRleHRBLCBiZXN0U2hvcnRUZXh0QjtcbiAgZm9yICg7IChqID0gc2hvcnRUZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPT0gLTE7ICkge1xuICAgIGNvbnN0IHByZWZpeExlbmd0aCA9IGdldENvbW1vblByZWZpeChsb25nVGV4dC5zbGljZShpKSwgc2hvcnRUZXh0LnNsaWNlKGopKSwgc3VmZml4TGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KGxvbmdUZXh0LnNsaWNlKDAsIGkpLCBzaG9ydFRleHQuc2xpY2UoMCwgaikpO1xuICAgIGJlc3RDb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoICYmIChiZXN0Q29tbW9uID0gc2hvcnRUZXh0LnNsaWNlKGogLSBzdWZmaXhMZW5ndGgsIGopICsgc2hvcnRUZXh0LnNsaWNlKGosIGogKyBwcmVmaXhMZW5ndGgpLCBiZXN0TG9uZ1RleHRBID0gbG9uZ1RleHQuc2xpY2UoMCwgaSAtIHN1ZmZpeExlbmd0aCksIGJlc3RMb25nVGV4dEIgPSBsb25nVGV4dC5zbGljZShpICsgcHJlZml4TGVuZ3RoKSwgYmVzdFNob3J0VGV4dEEgPSBzaG9ydFRleHQuc2xpY2UoMCwgaiAtIHN1ZmZpeExlbmd0aCksIGJlc3RTaG9ydFRleHRCID0gc2hvcnRUZXh0LnNsaWNlKGogKyBwcmVmaXhMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gYmVzdENvbW1vbi5sZW5ndGggKiAyID49IGxvbmdUZXh0Lmxlbmd0aCA/IFtiZXN0TG9uZ1RleHRBIHx8IFwiXCIsIGJlc3RMb25nVGV4dEIgfHwgXCJcIiwgYmVzdFNob3J0VGV4dEEgfHwgXCJcIiwgYmVzdFNob3J0VGV4dEIgfHwgXCJcIiwgYmVzdENvbW1vbiB8fCBcIlwiXSA6IG51bGw7XG59XG5mdW5jdGlvbiBjaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVBcnJheSkge1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgY2hhcnMgPSBkaWZmc1t4XVsxXSwgdGV4dCA9IFtdO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY2hhcnMubGVuZ3RoOyB5KyspXG4gICAgICB0ZXh0W3ldID0gbGluZUFycmF5W2NoYXJzLmNoYXJDb2RlQXQoeSldO1xuICAgIGRpZmZzW3hdWzFdID0gdGV4dC5qb2luKFwiXCIpO1xuICB9XG59XG5mdW5jdGlvbiBsaW5lc1RvQ2hhcnModGV4dEEsIHRleHRCKSB7XG4gIGNvbnN0IGxpbmVBcnJheSA9IFtdLCBsaW5lSGFzaCA9IHt9O1xuICBsaW5lQXJyYXlbMF0gPSBcIlwiO1xuICBmdW5jdGlvbiBkaWZmTGluZXNUb011bmdlKHRleHQpIHtcbiAgICBsZXQgY2hhcnMgPSBcIlwiLCBsaW5lU3RhcnQgPSAwLCBsaW5lRW5kID0gLTEsIGxpbmVBcnJheUxlbmd0aCA9IGxpbmVBcnJheS5sZW5ndGg7XG4gICAgZm9yICg7IGxpbmVFbmQgPCB0ZXh0Lmxlbmd0aCAtIDE7ICkge1xuICAgICAgbGluZUVuZCA9IHRleHQuaW5kZXhPZihgXG5gLCBsaW5lU3RhcnQpLCBsaW5lRW5kID09PSAtMSAmJiAobGluZUVuZCA9IHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICBsZXQgbGluZSA9IHRleHQuc2xpY2UobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XG4gICAgICAobGluZUhhc2guaGFzT3duUHJvcGVydHkgPyBsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eShsaW5lKSA6IGxpbmVIYXNoW2xpbmVdICE9PSB2b2lkIDApID8gY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lSGFzaFtsaW5lXSkgOiAobGluZUFycmF5TGVuZ3RoID09PSBtYXhMaW5lcyAmJiAobGluZSA9IHRleHQuc2xpY2UobGluZVN0YXJ0KSwgbGluZUVuZCA9IHRleHQubGVuZ3RoKSwgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lQXJyYXlMZW5ndGgpLCBsaW5lSGFzaFtsaW5lXSA9IGxpbmVBcnJheUxlbmd0aCwgbGluZUFycmF5W2xpbmVBcnJheUxlbmd0aCsrXSA9IGxpbmUpLCBsaW5lU3RhcnQgPSBsaW5lRW5kICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9XG4gIGxldCBtYXhMaW5lcyA9IDRlNDtcbiAgY29uc3QgY2hhcnMxID0gZGlmZkxpbmVzVG9NdW5nZSh0ZXh0QSk7XG4gIG1heExpbmVzID0gNjU1MzU7XG4gIGNvbnN0IGNoYXJzMiA9IGRpZmZMaW5lc1RvTXVuZ2UodGV4dEIpO1xuICByZXR1cm4ge1xuICAgIGNoYXJzMSxcbiAgICBjaGFyczIsXG4gICAgbGluZUFycmF5XG4gIH07XG59XG5mdW5jdGlvbiBkb0xpbmVNb2RlRGlmZih0ZXh0QSwgdGV4dEIsIG9wdHMpIHtcbiAgbGV0IHRleHQxID0gdGV4dEEsIHRleHQyID0gdGV4dEI7XG4gIGNvbnN0IGEgPSBsaW5lc1RvQ2hhcnModGV4dDEsIHRleHQyKTtcbiAgdGV4dDEgPSBhLmNoYXJzMSwgdGV4dDIgPSBhLmNoYXJzMjtcbiAgY29uc3QgbGluZWFycmF5ID0gYS5saW5lQXJyYXk7XG4gIGxldCBkaWZmcyA9IGRvRGlmZih0ZXh0MSwgdGV4dDIsIHtcbiAgICBjaGVja0xpbmVzOiAhMSxcbiAgICBkZWFkbGluZTogb3B0cy5kZWFkbGluZVxuICB9KTtcbiAgY2hhcnNUb0xpbmVzKGRpZmZzLCBsaW5lYXJyYXkpLCBkaWZmcyA9IGNsZWFudXBTZW1hbnRpYyhkaWZmcyksIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIFwiXCJdKTtcbiAgbGV0IHBvaW50ZXIgPSAwLCBjb3VudERlbGV0ZSA9IDAsIGNvdW50SW5zZXJ0ID0gMCwgdGV4dERlbGV0ZSA9IFwiXCIsIHRleHRJbnNlcnQgPSBcIlwiO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSB7XG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgY291bnRJbnNlcnQrKywgdGV4dEluc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudERlbGV0ZSsrLCB0ZXh0RGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgaWYgKGNvdW50RGVsZXRlID49IDEgJiYgY291bnRJbnNlcnQgPj0gMSkge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCwgY291bnREZWxldGUgKyBjb3VudEluc2VydCksIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydDtcbiAgICAgICAgICBjb25zdCBhYSA9IGRvRGlmZih0ZXh0RGVsZXRlLCB0ZXh0SW5zZXJ0LCB7XG4gICAgICAgICAgICBjaGVja0xpbmVzOiAhMSxcbiAgICAgICAgICAgIGRlYWRsaW5lOiBvcHRzLmRlYWRsaW5lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IGFhLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIGFhW2pdKTtcbiAgICAgICAgICBwb2ludGVyICs9IGFhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb3VudEluc2VydCA9IDAsIGNvdW50RGVsZXRlID0gMCwgdGV4dERlbGV0ZSA9IFwiXCIsIHRleHRJbnNlcnQgPSBcIlwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGlmZiBvcGVyYXRpb24uXCIpO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzLnBvcCgpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVEaWZmKHRleHQxLCB0ZXh0Miwgb3B0cykge1xuICBsZXQgZGlmZnM7XG4gIGlmICghdGV4dDEpXG4gICAgcmV0dXJuIFtbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIGlmICghdGV4dDIpXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXV07XG4gIGNvbnN0IGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0Miwgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MSwgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcbiAgaWYgKGkgIT09IC0xKVxuICAgIHJldHVybiBkaWZmcyA9IFtbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKV0sIFtESUZGX0VRVUFMLCBzaG9ydHRleHRdLCBbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCldXSwgdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoICYmIChkaWZmc1swXVswXSA9IERJRkZfREVMRVRFLCBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFKSwgZGlmZnM7XG4gIGlmIChzaG9ydHRleHQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV0sIFtESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgY29uc3QgaGFsZk1hdGNoID0gZmluZEhhbGZNYXRjaCh0ZXh0MSwgdGV4dDIpO1xuICBpZiAoaGFsZk1hdGNoKSB7XG4gICAgY29uc3QgdGV4dDFBID0gaGFsZk1hdGNoWzBdLCB0ZXh0MUIgPSBoYWxmTWF0Y2hbMV0sIHRleHQyQSA9IGhhbGZNYXRjaFsyXSwgdGV4dDJCID0gaGFsZk1hdGNoWzNdLCBtaWRDb21tb24gPSBoYWxmTWF0Y2hbNF0sIGRpZmZzQSA9IGRvRGlmZih0ZXh0MUEsIHRleHQyQSwgb3B0cyksIGRpZmZzQiA9IGRvRGlmZih0ZXh0MUIsIHRleHQyQiwgb3B0cyk7XG4gICAgcmV0dXJuIGRpZmZzQS5jb25jYXQoW1tESUZGX0VRVUFMLCBtaWRDb21tb25dXSwgZGlmZnNCKTtcbiAgfVxuICByZXR1cm4gb3B0cy5jaGVja0xpbmVzICYmIHRleHQxLmxlbmd0aCA+IDEwMCAmJiB0ZXh0Mi5sZW5ndGggPiAxMDAgPyBkb0xpbmVNb2RlRGlmZih0ZXh0MSwgdGV4dDIsIG9wdHMpIDogYmlzZWN0KHRleHQxLCB0ZXh0Miwgb3B0cy5kZWFkbGluZSk7XG59XG5jb25zdCBESUZGX0RFTEVURSA9IC0xLCBESUZGX0lOU0VSVCA9IDEsIERJRkZfRVFVQUwgPSAwO1xuZnVuY3Rpb24gZGlmZih0ZXh0QSwgdGV4dEIsIG9wdHMpIHtcbiAgaWYgKHRleHRBID09PSBudWxsIHx8IHRleHRCID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk51bGwgaW5wdXQuIChkaWZmKVwiKTtcbiAgY29uc3QgZGlmZnMgPSBkb0RpZmYodGV4dEEsIHRleHRCLCBjcmVhdGVJbnRlcm5hbE9wdHMob3B0cyB8fCB7fSkpO1xuICByZXR1cm4gYWRqdXN0RGlmZkZvclN1cnJvZ2F0ZVBhaXJzKGRpZmZzKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBkb0RpZmYodGV4dEEsIHRleHRCLCBvcHRpb25zKSB7XG4gIGxldCB0ZXh0MSA9IHRleHRBLCB0ZXh0MiA9IHRleHRCO1xuICBpZiAodGV4dDEgPT09IHRleHQyKVxuICAgIHJldHVybiB0ZXh0MSA/IFtbRElGRl9FUVVBTCwgdGV4dDFdXSA6IFtdO1xuICBsZXQgY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mik7XG4gIGNvbnN0IGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyhjb21tb25sZW5ndGgpLCB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpLCBjb21tb25sZW5ndGggPSBnZXRDb21tb25TdWZmaXgodGV4dDEsIHRleHQyKTtcbiAgY29uc3QgY29tbW9uc3VmZml4ID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKDAsIHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCksIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQyLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XG4gIGxldCBkaWZmcyA9IGNvbXB1dGVEaWZmKHRleHQxLCB0ZXh0Miwgb3B0aW9ucyk7XG4gIHJldHVybiBjb21tb25wcmVmaXggJiYgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgY29tbW9ucHJlZml4XSksIGNvbW1vbnN1ZmZpeCAmJiBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBjb21tb25zdWZmaXhdKSwgZGlmZnMgPSBjbGVhbnVwTWVyZ2UoZGlmZnMpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlYWRMaW5lKHRpbWVvdXQpIHtcbiAgbGV0IHQgPSAxO1xuICByZXR1cm4gdHlwZW9mIHRpbWVvdXQgPCBcInVcIiAmJiAodCA9IHRpbWVvdXQgPD0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiB0aW1lb3V0KSwgRGF0ZS5ub3coKSArIHQgKiAxZTM7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbE9wdHMob3B0cykge1xuICByZXR1cm4ge1xuICAgIGNoZWNrTGluZXM6ICEwLFxuICAgIGRlYWRsaW5lOiBjcmVhdGVEZWFkTGluZShvcHRzLnRpbWVvdXQgfHwgMSksXG4gICAgLi4ub3B0c1xuICB9O1xufVxuZnVuY3Rpb24gY29tYmluZUNoYXIoZGF0YSwgY2hhciwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBkYXRhICsgY2hhciA6IGNoYXIgKyBkYXRhO1xufVxuZnVuY3Rpb24gc3BsaXRDaGFyKGRhdGEsIGRpcikge1xuICByZXR1cm4gZGlyID09PSAxID8gW2RhdGEuc3Vic3RyaW5nKDAsIGRhdGEubGVuZ3RoIC0gMSksIGRhdGFbZGF0YS5sZW5ndGggLSAxXV0gOiBbZGF0YS5zdWJzdHJpbmcoMSksIGRhdGFbMF1dO1xufVxuZnVuY3Rpb24gaGFzU2hhcmVkQ2hhcihkaWZmcywgaSwgaiwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBkaWZmc1tpXVsxXVtkaWZmc1tpXVsxXS5sZW5ndGggLSAxXSA9PT0gZGlmZnNbal1bMV1bZGlmZnNbal1bMV0ubGVuZ3RoIC0gMV0gOiBkaWZmc1tpXVsxXVswXSA9PT0gZGlmZnNbal1bMV1bMF07XG59XG5mdW5jdGlvbiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCBkaXIpIHtcbiAgY29uc3QgaW52ID0gZGlyID09PSAxID8gLTEgOiAxO1xuICBsZXQgaW5zZXJ0SWR4ID0gbnVsbCwgZGVsZXRlSWR4ID0gbnVsbCwgaiA9IGkgKyBkaXI7XG4gIGZvciAoOyBqID49IDAgJiYgaiA8IGRpZmZzLmxlbmd0aCAmJiAoaW5zZXJ0SWR4ID09PSBudWxsIHx8IGRlbGV0ZUlkeCA9PT0gbnVsbCk7IGogKz0gZGlyKSB7XG4gICAgY29uc3QgW29wLCB0ZXh0Ml0gPSBkaWZmc1tqXTtcbiAgICBpZiAodGV4dDIubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpZiAob3AgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgIGluc2VydElkeCA9PT0gbnVsbCAmJiAoaW5zZXJ0SWR4ID0gaik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChvcCA9PT0gRElGRl9ERUxFVEUpIHtcbiAgICAgICAgZGVsZXRlSWR4ID09PSBudWxsICYmIChkZWxldGVJZHggPSBqKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG9wID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgIGlmIChpbnNlcnRJZHggPT09IG51bGwgJiYgZGVsZXRlSWR4ID09PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgW3Jlc3QsIGNoYXIyXSA9IHNwbGl0Q2hhcihkaWZmc1tpXVsxXSwgZGlyKTtcbiAgICAgICAgICBkaWZmc1tpXVsxXSA9IHJlc3QsIGRpZmZzW2pdWzFdID0gY29tYmluZUNoYXIoZGlmZnNbal1bMV0sIGNoYXIyLCBpbnYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGluc2VydElkeCAhPT0gbnVsbCAmJiBkZWxldGVJZHggIT09IG51bGwgJiYgaGFzU2hhcmVkQ2hhcihkaWZmcywgaW5zZXJ0SWR4LCBkZWxldGVJZHgsIGRpcikpIHtcbiAgICBjb25zdCBbaW5zZXJ0VGV4dDIsIGluc2VydENoYXJdID0gc3BsaXRDaGFyKGRpZmZzW2luc2VydElkeF1bMV0sIGludiksIFtkZWxldGVUZXh0XSA9IHNwbGl0Q2hhcihkaWZmc1tkZWxldGVJZHhdWzFdLCBpbnYpO1xuICAgIGRpZmZzW2luc2VydElkeF1bMV0gPSBpbnNlcnRUZXh0MiwgZGlmZnNbZGVsZXRlSWR4XVsxXSA9IGRlbGV0ZVRleHQsIGRpZmZzW2ldWzFdID0gY29tYmluZUNoYXIoZGlmZnNbaV1bMV0sIGluc2VydENoYXIsIGRpcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFt0ZXh0LCBjaGFyXSA9IHNwbGl0Q2hhcihkaWZmc1tpXVsxXSwgZGlyKTtcbiAgZGlmZnNbaV1bMV0gPSB0ZXh0LCBpbnNlcnRJZHggPT09IG51bGwgPyAoZGlmZnMuc3BsaWNlKGosIDAsIFtESUZGX0lOU0VSVCwgY2hhcl0pLCBkZWxldGVJZHggIT09IG51bGwgJiYgZGVsZXRlSWR4ID49IGogJiYgZGVsZXRlSWR4KyspIDogZGlmZnNbaW5zZXJ0SWR4XVsxXSA9IGNvbWJpbmVDaGFyKGRpZmZzW2luc2VydElkeF1bMV0sIGNoYXIsIGludiksIGRlbGV0ZUlkeCA9PT0gbnVsbCA/IGRpZmZzLnNwbGljZShqLCAwLCBbRElGRl9ERUxFVEUsIGNoYXJdKSA6IGRpZmZzW2RlbGV0ZUlkeF1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tkZWxldGVJZHhdWzFdLCBjaGFyLCBpbnYpO1xufVxuZnVuY3Rpb24gYWRqdXN0RGlmZkZvclN1cnJvZ2F0ZVBhaXJzKGRpZmZzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbZGlmZlR5cGUsIGRpZmZUZXh0XSA9IGRpZmZzW2ldO1xuICAgIGlmIChkaWZmVGV4dC5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgIGNvbnN0IGZpcnN0Q2hhciA9IGRpZmZUZXh0WzBdLCBsYXN0Q2hhciA9IGRpZmZUZXh0W2RpZmZUZXh0Lmxlbmd0aCAtIDFdO1xuICAgIGlzSGlnaFN1cnJvZ2F0ZShsYXN0Q2hhcikgJiYgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgZGVpc29sYXRlQ2hhcihkaWZmcywgaSwgMSksIGlzTG93U3Vycm9nYXRlKGZpcnN0Q2hhcikgJiYgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgZGVpc29sYXRlQ2hhcihkaWZmcywgaSwgLTEpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspXG4gICAgZGlmZnNbaV1bMV0ubGVuZ3RoID09PSAwICYmIGRpZmZzLnNwbGljZShpLCAxKTtcbn1cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgLyoqXG4gICAqIEF0IHdoYXQgcG9pbnQgaXMgbm8gbWF0Y2ggZGVjbGFyZWQgKDAuMCA9IHBlcmZlY3Rpb24sIDEuMCA9IHZlcnkgbG9vc2UpLlxuICAgKi9cbiAgdGhyZXNob2xkOiAwLjUsXG4gIC8qKlxuICAgKiBIb3cgZmFyIHRvIHNlYXJjaCBmb3IgYSBtYXRjaCAoMCA9IGV4YWN0IGxvY2F0aW9uLCAxMDAwKyA9IGJyb2FkIG1hdGNoKS5cbiAgICogQSBtYXRjaCB0aGlzIG1hbnkgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGV4cGVjdGVkIGxvY2F0aW9uIHdpbGwgYWRkXG4gICAqIDEuMCB0byB0aGUgc2NvcmUgKDAuMCBpcyBhIHBlcmZlY3QgbWF0Y2gpLlxuICAgKi9cbiAgZGlzdGFuY2U6IDFlM1xufTtcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIC4uLkRFRkFVTFRfT1BUSU9OUyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG59XG5jb25zdCBNQVhfQklUUyQxID0gMzI7XG5mdW5jdGlvbiBiaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfQklUUyQxKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhdHRlcm4gdG9vIGxvbmcgZm9yIHRoaXMgYnJvd3Nlci5cIik7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRzKG9wdHMpLCBzID0gZ2V0QWxwaGFiZXRGcm9tUGF0dGVybihwYXR0ZXJuKTtcbiAgZnVuY3Rpb24gZ2V0Qml0YXBTY29yZShlLCB4KSB7XG4gICAgY29uc3QgYWNjdXJhY3kgPSBlIC8gcGF0dGVybi5sZW5ndGgsIHByb3hpbWl0eSA9IE1hdGguYWJzKGxvYyAtIHgpO1xuICAgIHJldHVybiBvcHRpb25zLmRpc3RhbmNlID8gYWNjdXJhY3kgKyBwcm94aW1pdHkgLyBvcHRpb25zLmRpc3RhbmNlIDogcHJveGltaXR5ID8gMSA6IGFjY3VyYWN5O1xuICB9XG4gIGxldCBzY29yZVRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkLCBiZXN0TG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGxvYyk7XG4gIGJlc3RMb2MgIT09IC0xICYmIChzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKGdldEJpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKSwgYmVzdExvYyA9IHRleHQubGFzdEluZGV4T2YocGF0dGVybiwgbG9jICsgcGF0dGVybi5sZW5ndGgpLCBiZXN0TG9jICE9PSAtMSAmJiAoc2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihnZXRCaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCkpKTtcbiAgY29uc3QgbWF0Y2htYXNrID0gMSA8PCBwYXR0ZXJuLmxlbmd0aCAtIDE7XG4gIGJlc3RMb2MgPSAtMTtcbiAgbGV0IGJpbk1pbiwgYmluTWlkLCBiaW5NYXggPSBwYXR0ZXJuLmxlbmd0aCArIHRleHQubGVuZ3RoLCBsYXN0UmQgPSBbXTtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBwYXR0ZXJuLmxlbmd0aDsgZCsrKSB7XG4gICAgZm9yIChiaW5NaW4gPSAwLCBiaW5NaWQgPSBiaW5NYXg7IGJpbk1pbiA8IGJpbk1pZDsgKVxuICAgICAgZ2V0Qml0YXBTY29yZShkLCBsb2MgKyBiaW5NaWQpIDw9IHNjb3JlVGhyZXNob2xkID8gYmluTWluID0gYmluTWlkIDogYmluTWF4ID0gYmluTWlkLCBiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XG4gICAgYmluTWF4ID0gYmluTWlkO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIGxvYyAtIGJpbk1pZCArIDEpO1xuICAgIGNvbnN0IGZpbmlzaCA9IE1hdGgubWluKGxvYyArIGJpbk1pZCwgdGV4dC5sZW5ndGgpICsgcGF0dGVybi5sZW5ndGgsIHJkID0gbmV3IEFycmF5KGZpbmlzaCArIDIpO1xuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xuICAgIGZvciAobGV0IGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgY29uc3QgY2hhck1hdGNoID0gc1t0ZXh0LmNoYXJBdChqIC0gMSldO1xuICAgICAgaWYgKGQgPT09IDAgPyByZFtqXSA9IChyZFtqICsgMV0gPDwgMSB8IDEpICYgY2hhck1hdGNoIDogcmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaCB8ICgobGFzdFJkW2ogKyAxXSB8IGxhc3RSZFtqXSkgPDwgMSB8IDEpIHwgbGFzdFJkW2ogKyAxXSwgcmRbal0gJiBtYXRjaG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBnZXRCaXRhcFNjb3JlKGQsIGogLSAxKTtcbiAgICAgICAgaWYgKHNjb3JlIDw9IHNjb3JlVGhyZXNob2xkKVxuICAgICAgICAgIGlmIChzY29yZVRocmVzaG9sZCA9IHNjb3JlLCBiZXN0TG9jID0gaiAtIDEsIGJlc3RMb2MgPiBsb2MpXG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBsb2MgLSBiZXN0TG9jKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdldEJpdGFwU2NvcmUoZCArIDEsIGxvYykgPiBzY29yZVRocmVzaG9sZClcbiAgICAgIGJyZWFrO1xuICAgIGxhc3RSZCA9IHJkO1xuICB9XG4gIHJldHVybiBiZXN0TG9jO1xufVxuZnVuY3Rpb24gZ2V0QWxwaGFiZXRGcm9tUGF0dGVybihwYXR0ZXJuKSB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKVxuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKVxuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgcGF0dGVybi5sZW5ndGggLSBpIC0gMTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBtYXRjaCh0ZXh0LCBwYXR0ZXJuLCBzZWFyY2hMb2NhdGlvbikge1xuICBpZiAodGV4dCA9PT0gbnVsbCB8fCBwYXR0ZXJuID09PSBudWxsIHx8IHNlYXJjaExvY2F0aW9uID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk51bGwgaW5wdXQuIChtYXRjaCgpKVwiKTtcbiAgY29uc3QgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VhcmNoTG9jYXRpb24sIHRleHQubGVuZ3RoKSk7XG4gIGlmICh0ZXh0ID09PSBwYXR0ZXJuKVxuICAgIHJldHVybiAwO1xuICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT09IHBhdHRlcm4pXG4gICAgICByZXR1cm4gbG9jO1xuICB9IGVsc2UgcmV0dXJuIC0xO1xuICByZXR1cm4gYml0YXAodGV4dCwgcGF0dGVybiwgbG9jKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoT2JqZWN0KHN0YXJ0MSwgc3RhcnQyKSB7XG4gIHJldHVybiB7XG4gICAgZGlmZnM6IFtdLFxuICAgIHN0YXJ0MSxcbiAgICBzdGFydDIsXG4gICAgdXRmOFN0YXJ0MTogc3RhcnQxLFxuICAgIHV0ZjhTdGFydDI6IHN0YXJ0MixcbiAgICBsZW5ndGgxOiAwLFxuICAgIGxlbmd0aDI6IDAsXG4gICAgdXRmOExlbmd0aDE6IDAsXG4gICAgdXRmOExlbmd0aDI6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZUZXh0MShkaWZmcykge1xuICBjb25zdCB0ZXh0ID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspXG4gICAgZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQyKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKylcbiAgICBkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUgJiYgKHRleHRbeF0gPSBkaWZmc1t4XVsxXSk7XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBjb3VudFV0ZjhCeXRlcyhzdHIpIHtcbiAgbGV0IGJ5dGVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgaWYgKHR5cGVvZiBjb2RlUG9pbnQgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgY29kZXBvaW50XCIpO1xuICAgIGJ5dGVzICs9IHV0ZjhsZW4oY29kZVBvaW50KTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCBiYXNlKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fSwgYnl0ZU9mZnNldCA9IDAsIGlkeCA9IDA7XG4gIGZ1bmN0aW9uIGFkdmFuY2VUbyh0YXJnZXQpIHtcbiAgICBmb3IgKDsgYnl0ZU9mZnNldCA8IHRhcmdldDsgKSB7XG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSBiYXNlLmNvZGVQb2ludEF0KGlkeCk7XG4gICAgICBpZiAodHlwZW9mIGNvZGVQb2ludCA+IFwidVwiKVxuICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgYnl0ZU9mZnNldCArPSB1dGY4bGVuKGNvZGVQb2ludCksIGNvZGVQb2ludCA+IDY1NTM1ID8gaWR4ICs9IDIgOiBpZHggKz0gMTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmFsbG93RXhjZWVkaW5nSW5kaWNlcyAmJiBieXRlT2Zmc2V0ICE9PSB0YXJnZXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGV0ZXJtaW5lIGJ5dGUgb2Zmc2V0XCIpO1xuICAgIHJldHVybiBpZHg7XG4gIH1cbiAgY29uc3QgYWRqdXN0ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKVxuICAgIGFkanVzdGVkLnB1c2goe1xuICAgICAgZGlmZnM6IHBhdGNoLmRpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpLFxuICAgICAgc3RhcnQxOiBhZHZhbmNlVG8ocGF0Y2guc3RhcnQxKSxcbiAgICAgIHN0YXJ0MjogYWR2YW5jZVRvKHBhdGNoLnN0YXJ0MiksXG4gICAgICB1dGY4U3RhcnQxOiBwYXRjaC51dGY4U3RhcnQxLFxuICAgICAgdXRmOFN0YXJ0MjogcGF0Y2gudXRmOFN0YXJ0MixcbiAgICAgIGxlbmd0aDE6IHBhdGNoLmxlbmd0aDEsXG4gICAgICBsZW5ndGgyOiBwYXRjaC5sZW5ndGgyLFxuICAgICAgdXRmOExlbmd0aDE6IHBhdGNoLnV0ZjhMZW5ndGgxLFxuICAgICAgdXRmOExlbmd0aDI6IHBhdGNoLnV0ZjhMZW5ndGgyXG4gICAgfSk7XG4gIHJldHVybiBhZGp1c3RlZDtcbn1cbmZ1bmN0aW9uIHV0ZjhsZW4oY29kZVBvaW50KSB7XG4gIHJldHVybiBjb2RlUG9pbnQgPD0gMTI3ID8gMSA6IGNvZGVQb2ludCA8PSAyMDQ3ID8gMiA6IGNvZGVQb2ludCA8PSA2NTUzNSA/IDMgOiA0O1xufVxuY29uc3QgTUFYX0JJVFMgPSAzMiwgREVGQVVMVF9NQVJHSU4gPSA0O1xuZnVuY3Rpb24gbGV2ZW5zaHRlaW4oZGlmZnMpIHtcbiAgbGV0IGxldmVuID0gMCwgaW5zZXJ0aW9ucyA9IDAsIGRlbGV0aW9ucyA9IDA7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBvcCA9IGRpZmZzW3hdWzBdLCBkYXRhID0gZGlmZnNbeF1bMV07XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaW5zZXJ0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBkZWxldGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBsZXZlbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpLCBpbnNlcnRpb25zID0gMCwgZGVsZXRpb25zID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVuICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyksIGxldmVuO1xufVxuZnVuY3Rpb24geEluZGV4KGRpZmZzLCBsb2MpIHtcbiAgbGV0IGNoYXJzMSA9IDAsIGNoYXJzMiA9IDAsIGxhc3RDaGFyczEgPSAwLCBsYXN0Q2hhcnMyID0gMCwgeDtcbiAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aCAmJiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmIChjaGFyczEgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoKSwgZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFICYmIChjaGFyczIgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoKSwgIShjaGFyczEgPiBsb2MpKTsgeCsrKVxuICAgIGxhc3RDaGFyczEgPSBjaGFyczEsIGxhc3RDaGFyczIgPSBjaGFyczI7XG4gIHJldHVybiBkaWZmcy5sZW5ndGggIT09IHggJiYgZGlmZnNbeF1bMF0gPT09IERJRkZfREVMRVRFID8gbGFzdENoYXJzMiA6IGxhc3RDaGFyczIgKyAobG9jIC0gbGFzdENoYXJzMSk7XG59XG5mdW5jdGlvbiBhZGRQYWRkaW5nKHBhdGNoZXMpIHtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9NQVJHSU47XG4gIGxldCBudWxsUGFkZGluZyA9IFwiXCI7XG4gIGZvciAobGV0IHggPSAxOyB4IDw9IHBhZGRpbmdMZW5ndGg7IHgrKylcbiAgICBudWxsUGFkZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICBmb3IgKGNvbnN0IHAgb2YgcGF0Y2hlcylcbiAgICBwLnN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoLCBwLnN0YXJ0MiArPSBwYWRkaW5nTGVuZ3RoLCBwLnV0ZjhTdGFydDEgKz0gcGFkZGluZ0xlbmd0aCwgcC51dGY4U3RhcnQyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGxldCBwYXRjaCA9IHBhdGNoZXNbMF0sIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbMF1bMF0gIT09IERJRkZfRVFVQUwpXG4gICAgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKSwgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDIgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1swXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBmaXJzdERpZmZMZW5ndGggPSBkaWZmc1swXVsxXS5sZW5ndGgsIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGZpcnN0RGlmZkxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhmaXJzdERpZmZMZW5ndGgpICsgZGlmZnNbMF1bMV0sIHBhdGNoLnN0YXJ0MSAtPSBleHRyYUxlbmd0aCwgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgaWYgKHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdLCBkaWZmcyA9IHBhdGNoLmRpZmZzLCBkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT09IERJRkZfRVFVQUwpXG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKSwgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGg7XG4gICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKSwgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICB9XG4gIHJldHVybiBudWxsUGFkZGluZztcbn1cbmZ1bmN0aW9uIHNwbGl0TWF4KHBhdGNoZXMpIHtcbiAgbGV0IG1hcmdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9NQVJHSU47XG4gIGNvbnN0IHBhdGNoU2l6ZSA9IE1BWF9CSVRTO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAocGF0Y2hlc1t4XS5sZW5ndGgxIDw9IHBhdGNoU2l6ZSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgIGxldCBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDEsIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MiwgcHJlQ29udGV4dCA9IFwiXCI7XG4gICAgZm9yICg7IGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMDsgKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoT2JqZWN0KHN0YXJ0MSAtIHByZUNvbnRleHQubGVuZ3RoLCBzdGFydDIgLSBwcmVDb250ZXh0Lmxlbmd0aCk7XG4gICAgICBsZXQgZW1wdHkgPSAhMDtcbiAgICAgIGlmIChwcmVDb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IHByZWNvbnRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhwcmVDb250ZXh0KTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSA9IHByZUNvbnRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSA9IHByZWNvbnRleHRCeXRlQ291bnQsIHBhdGNoLmxlbmd0aDIgPSBwcmVDb250ZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgPSBwcmVjb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwcmVDb250ZXh0XSk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmxlbmd0aDEgPCBwYXRjaFNpemUgLSBtYXJnaW47ICkge1xuICAgICAgICBjb25zdCBkaWZmVHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICBsZXQgZGlmZlRleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXSwgZGlmZlRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhkaWZmVGV4dCk7XG4gICAgICAgIGlmIChkaWZmVHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGlmZjIgPSBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIGRpZmYyICYmIHBhdGNoLmRpZmZzLnB1c2goZGlmZjIpLCBlbXB0eSA9ICExO1xuICAgICAgICB9IGVsc2UgZGlmZlR5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PT0gMSAmJiBwYXRjaC5kaWZmc1swXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmVGV4dC5sZW5ndGggPiAyICogcGF0Y2hTaXplID8gKHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQxICs9IGRpZmZUZXh0Lmxlbmd0aCwgZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpIDogKGRpZmZUZXh0ID0gZGlmZlRleHQuc3Vic3RyaW5nKDAsIHBhdGNoU2l6ZSAtIHBhdGNoLmxlbmd0aDEgLSBtYXJnaW4pLCBkaWZmVGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKGRpZmZUZXh0KSwgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDEgKz0gZGlmZlRleHQubGVuZ3RoLCBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCA/IChwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGgpIDogZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGRpZmZUZXh0ID09PSBiaWdwYXRjaC5kaWZmc1swXVsxXSA/IGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkgOiBiaWdwYXRjaC5kaWZmc1swXVsxXSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmVGV4dC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHByZUNvbnRleHQgPSBkaWZmVGV4dDIocGF0Y2guZGlmZnMpLCBwcmVDb250ZXh0ID0gcHJlQ29udGV4dC5zdWJzdHJpbmcocHJlQ29udGV4dC5sZW5ndGggLSBtYXJnaW4pO1xuICAgICAgY29uc3QgcG9zdENvbnRleHQgPSBkaWZmVGV4dDEoYmlncGF0Y2guZGlmZnMpLnN1YnN0cmluZygwLCBtYXJnaW4pLCBwb3N0Q29udGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKHBvc3RDb250ZXh0KTtcbiAgICAgIHBvc3RDb250ZXh0ICE9PSBcIlwiICYmIChwYXRjaC5sZW5ndGgxICs9IHBvc3RDb250ZXh0Lmxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Q29udGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBvc3RDb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwb3N0Q29udGV4dEJ5dGVDb3VudCwgcGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdENvbnRleHQgOiBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwb3N0Q29udGV4dF0pKSwgZW1wdHkgfHwgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBseShwYXRjaGVzLCBvcmlnaW5hbFRleHQpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpZiAodHlwZW9mIHBhdGNoZXMgPT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRjaGVzIG11c3QgYmUgYW4gYXJyYXkgLSBwYXNzIHRoZSBwYXRjaCB0byBgcGFyc2VQYXRjaCgpYCBmaXJzdFwiKTtcbiAgbGV0IHRleHQgPSBvcmlnaW5hbFRleHQ7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW3RleHQsIFtdXTtcbiAgY29uc3QgcGFyc2VkID0gYWRqdXN0SW5kaWNpZXNUb1VjczIocGF0Y2hlcywgdGV4dCwge1xuICAgIGFsbG93RXhjZWVkaW5nSW5kaWNlczogb3B0cy5hbGxvd0V4Y2VlZGluZ0luZGljZXNcbiAgfSksIG1hcmdpbiA9IG9wdHMubWFyZ2luIHx8IERFRkFVTFRfTUFSR0lOLCBkZWxldGVUaHJlc2hvbGQgPSBvcHRzLmRlbGV0ZVRocmVzaG9sZCB8fCAwLjQsIG51bGxQYWRkaW5nID0gYWRkUGFkZGluZyhwYXJzZWQsIG1hcmdpbik7XG4gIHRleHQgPSBudWxsUGFkZGluZyArIHRleHQgKyBudWxsUGFkZGluZywgc3BsaXRNYXgocGFyc2VkLCBtYXJnaW4pO1xuICBsZXQgZGVsdGEgPSAwO1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGFyc2VkLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgZXhwZWN0ZWRMb2MgPSBwYXJzZWRbeF0uc3RhcnQyICsgZGVsdGEsIHRleHQxID0gZGlmZlRleHQxKHBhcnNlZFt4XS5kaWZmcyk7XG4gICAgbGV0IHN0YXJ0TG9jLCBlbmRMb2MgPSAtMTtcbiAgICBpZiAodGV4dDEubGVuZ3RoID4gTUFYX0JJVFMgPyAoc3RhcnRMb2MgPSBtYXRjaCh0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcoMCwgTUFYX0JJVFMpLCBleHBlY3RlZExvYyksIHN0YXJ0TG9jICE9PSAtMSAmJiAoZW5kTG9jID0gbWF0Y2godGV4dCwgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIE1BWF9CSVRTKSwgZXhwZWN0ZWRMb2MgKyB0ZXh0MS5sZW5ndGggLSBNQVhfQklUUyksIChlbmRMb2MgPT09IC0xIHx8IHN0YXJ0TG9jID49IGVuZExvYykgJiYgKHN0YXJ0TG9jID0gLTEpKSkgOiBzdGFydExvYyA9IG1hdGNoKHRleHQsIHRleHQxLCBleHBlY3RlZExvYyksIHN0YXJ0TG9jID09PSAtMSlcbiAgICAgIHJlc3VsdHNbeF0gPSAhMSwgZGVsdGEgLT0gcGFyc2VkW3hdLmxlbmd0aDIgLSBwYXJzZWRbeF0ubGVuZ3RoMTtcbiAgICBlbHNlIHtcbiAgICAgIHJlc3VsdHNbeF0gPSAhMCwgZGVsdGEgPSBzdGFydExvYyAtIGV4cGVjdGVkTG9jO1xuICAgICAgbGV0IHRleHQyO1xuICAgICAgaWYgKGVuZExvYyA9PT0gLTEgPyB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jLCBzdGFydExvYyArIHRleHQxLmxlbmd0aCkgOiB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jLCBlbmRMb2MgKyBNQVhfQklUUyksIHRleHQxID09PSB0ZXh0MilcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jKSArIGRpZmZUZXh0MihwYXJzZWRbeF0uZGlmZnMpICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBkaWZmcyA9IGRpZmYodGV4dDEsIHRleHQyLCB7XG4gICAgICAgICAgY2hlY2tMaW5lczogITFcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0ZXh0MS5sZW5ndGggPiBNQVhfQklUUyAmJiBsZXZlbnNodGVpbihkaWZmcykgLyB0ZXh0MS5sZW5ndGggPiBkZWxldGVUaHJlc2hvbGQpXG4gICAgICAgICAgcmVzdWx0c1t4XSA9ICExO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkaWZmcyA9IGNsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgICBsZXQgaW5kZXgxID0gMCwgaW5kZXgyID0gMDtcbiAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHBhcnNlZFt4XS5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgY29uc3QgbW9kID0gcGFyc2VkW3hdLmRpZmZzW3ldO1xuICAgICAgICAgICAgbW9kWzBdICE9PSBESUZGX0VRVUFMICYmIChpbmRleDIgPSB4SW5kZXgoZGlmZnMsIGluZGV4MSkpLCBtb2RbMF0gPT09IERJRkZfSU5TRVJUID8gdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIG1vZFsxXSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgaW5kZXgyKSA6IG1vZFswXSA9PT0gRElGRl9ERUxFVEUgJiYgKHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydExvYyArIGluZGV4MikgKyB0ZXh0LnN1YnN0cmluZyhzdGFydExvYyArIHhJbmRleChkaWZmcywgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpKSwgbW9kWzBdICE9PSBESUZGX0RFTEVURSAmJiAoaW5kZXgxICs9IG1vZFsxXS5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpLCBbdGV4dCwgcmVzdWx0c107XG59XG5jb25zdCBwYXRjaEhlYWRlciA9IC9eQEAgLShcXGQrKSw/KFxcZCopIFxcKyhcXGQrKSw/KFxcZCopIEBAJC87XG5mdW5jdGlvbiBwYXJzZSh0ZXh0bGluZSkge1xuICBpZiAoIXRleHRsaW5lKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgcGF0Y2hlcyA9IFtdLCBsaW5lcyA9IHRleHRsaW5lLnNwbGl0KGBcbmApO1xuICBsZXQgdGV4dFBvaW50ZXIgPSAwO1xuICBmb3IgKDsgdGV4dFBvaW50ZXIgPCBsaW5lcy5sZW5ndGg7ICkge1xuICAgIGNvbnN0IG0gPSBsaW5lc1t0ZXh0UG9pbnRlcl0ubWF0Y2gocGF0Y2hIZWFkZXIpO1xuICAgIGlmICghbSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGF0Y2ggc3RyaW5nOiBcIi5jb25jYXQobGluZXNbdGV4dFBvaW50ZXJdKSk7XG4gICAgY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdCh0b0ludChtWzFdKSwgdG9JbnQobVszXSkpO1xuICAgIGZvciAocGF0Y2hlcy5wdXNoKHBhdGNoKSwgbVsyXSA9PT0gXCJcIiA/IChwYXRjaC5zdGFydDEtLSwgcGF0Y2gudXRmOFN0YXJ0MS0tLCBwYXRjaC5sZW5ndGgxID0gMSwgcGF0Y2gudXRmOExlbmd0aDEgPSAxKSA6IG1bMl0gPT09IFwiMFwiID8gKHBhdGNoLmxlbmd0aDEgPSAwLCBwYXRjaC51dGY4TGVuZ3RoMSA9IDApIDogKHBhdGNoLnN0YXJ0MS0tLCBwYXRjaC51dGY4U3RhcnQxLS0sIHBhdGNoLnV0ZjhMZW5ndGgxID0gdG9JbnQobVsyXSksIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC51dGY4TGVuZ3RoMSksIG1bNF0gPT09IFwiXCIgPyAocGF0Y2guc3RhcnQyLS0sIHBhdGNoLnV0ZjhTdGFydDItLSwgcGF0Y2gubGVuZ3RoMiA9IDEsIHBhdGNoLnV0ZjhMZW5ndGgyID0gMSkgOiBtWzRdID09PSBcIjBcIiA/IChwYXRjaC5sZW5ndGgyID0gMCwgcGF0Y2gudXRmOExlbmd0aDIgPSAwKSA6IChwYXRjaC5zdGFydDItLSwgcGF0Y2gudXRmOFN0YXJ0Mi0tLCBwYXRjaC51dGY4TGVuZ3RoMiA9IHRvSW50KG1bNF0pLCBwYXRjaC5sZW5ndGgyID0gcGF0Y2gudXRmOExlbmd0aDIpLCB0ZXh0UG9pbnRlcisrOyB0ZXh0UG9pbnRlciA8IGxpbmVzLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBjdXJyZW50TGluZSA9IGxpbmVzW3RleHRQb2ludGVyXSwgc2lnbiA9IGN1cnJlbnRMaW5lLmNoYXJBdCgwKTtcbiAgICAgIGlmIChzaWduID09PSBcIkBcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAoc2lnbiA9PT0gXCJcIikge1xuICAgICAgICB0ZXh0UG9pbnRlcisrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGluZSA9IGRlY29kZVVSSShjdXJyZW50TGluZS5zbGljZSgxKSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBlc2NhcGUgaW4gcGFyc2U6IFwiLmNvbmNhdChjdXJyZW50TGluZSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdXRmOERpZmYgPSBjb3VudFV0ZjhCeXRlcyhsaW5lKSAtIGxpbmUubGVuZ3RoO1xuICAgICAgaWYgKHNpZ24gPT09IFwiLVwiKVxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0RFTEVURSwgbGluZV0pLCBwYXRjaC5sZW5ndGgxIC09IHV0ZjhEaWZmO1xuICAgICAgZWxzZSBpZiAoc2lnbiA9PT0gXCIrXCIpXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfSU5TRVJULCBsaW5lXSksIHBhdGNoLmxlbmd0aDIgLT0gdXRmOERpZmY7XG4gICAgICBlbHNlIGlmIChzaWduID09PSBcIiBcIilcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbGluZV0pLCBwYXRjaC5sZW5ndGgxIC09IHV0ZjhEaWZmLCBwYXRjaC5sZW5ndGgyIC09IHV0ZjhEaWZmO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggbW9kZSBcIicuY29uY2F0KHNpZ24sICdcIiBpbjogJykuY29uY2F0KGxpbmUpKTtcbiAgICAgIHRleHRQb2ludGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gdG9JbnQobnVtKSB7XG4gIHJldHVybiBwYXJzZUludChudW0sIDEwKTtcbn1cbmNvbnN0IElTX1VET0lORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJU19SRURPSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB3aXRoVW5kb2luZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1VuZG9pbmcoZWRpdG9yKTtcbiAgSVNfVURPSU5HLnNldChlZGl0b3IsICEwKSwgZm4oKSwgSVNfVURPSU5HLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gaXNVbmRvaW5nKGVkaXRvcikge1xuICByZXR1cm4gSVNfVURPSU5HLmdldChlZGl0b3IpID8/ICExO1xufVxuZnVuY3Rpb24gc2V0SXNVbmRvaW5nKGVkaXRvciwgaXNVbmRvaW5nMikge1xuICBJU19VRE9JTkcuc2V0KGVkaXRvciwgaXNVbmRvaW5nMik7XG59XG5mdW5jdGlvbiB3aXRoUmVkb2luZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1JlZG9pbmcoZWRpdG9yKTtcbiAgSVNfUkVET0lORy5zZXQoZWRpdG9yLCAhMCksIGZuKCksIElTX1JFRE9JTkcuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc1JlZG9pbmcoZWRpdG9yKSB7XG4gIHJldHVybiBJU19SRURPSU5HLmdldChlZGl0b3IpID8/ICExO1xufVxuZnVuY3Rpb24gc2V0SXNSZWRvaW5nKGVkaXRvciwgaXNSZWRvaW5nMikge1xuICBJU19SRURPSU5HLnNldChlZGl0b3IsIGlzUmVkb2luZzIpO1xufVxuY29uc3QgZGVidWckayA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFVuZG9SZWRvXCIpLCBkZWJ1Z1ZlcmJvc2UkNCA9IGRlYnVnJGsuZW5hYmxlZCAmJiAhMSwgU0FWSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFJFTU9URV9QQVRDSEVTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFVORE9fU1RFUF9MSU1JVCA9IDFlMywgaXNTYXZpbmcgPSAoZWRpdG9yKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gU0FWSU5HLmdldChlZGl0b3IpO1xuICByZXR1cm4gc3RhdGUgPT09IHZvaWQgMCA/ICEwIDogc3RhdGU7XG59LCBnZXRSZW1vdGVQYXRjaGVzID0gKGVkaXRvcikgPT4gKFJFTU9URV9QQVRDSEVTLmdldChlZGl0b3IpIHx8IFJFTU9URV9QQVRDSEVTLnNldChlZGl0b3IsIFtdKSwgUkVNT1RFX1BBVENIRVMuZ2V0KGVkaXRvcikgfHwgW10pO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFVuZG9SZWRvKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIGJsb2NrU2NoZW1hVHlwZVxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIChlZGl0b3IpID0+IHtcbiAgICBsZXQgcHJldmlvdXNTbmFwc2hvdCA9IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgYmxvY2tTY2hlbWFUeXBlLm5hbWUpO1xuICAgIGNvbnN0IHJlbW90ZVBhdGNoZXMgPSBnZXRSZW1vdGVQYXRjaGVzKGVkaXRvcik7XG4gICAgb3B0aW9ucy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgZGVidWckayhcIlN1YnNjcmliaW5nIHRvIHBhdGNoZXNcIik7XG4gICAgICBjb25zdCBzdWIgPSBlZGl0b3JBY3Rvci5vbihcInBhdGNoZXNcIiwgKHtcbiAgICAgICAgcGF0Y2hlcyxcbiAgICAgICAgc25hcHNob3RcbiAgICAgIH0pID0+IHtcbiAgICAgICAgbGV0IHJlc2V0ID0gITE7XG4gICAgICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc2V0ICYmIHBhdGNoLm9yaWdpbiAhPT0gXCJsb2NhbFwiICYmIHJlbW90ZVBhdGNoZXMpIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZGVidWckayhcIlNvbWVvbmUgZWxzZSBjbGVhcmVkIHRoZSBjb250ZW50LCByZXNldHRpbmcgdW5kby9yZWRvIGhpc3RvcnlcIiksIGVkaXRvci5oaXN0b3J5ID0ge1xuICAgICAgICAgICAgICAgIHVuZG9zOiBbXSxcbiAgICAgICAgICAgICAgICByZWRvczogW11cbiAgICAgICAgICAgICAgfSwgcmVtb3RlUGF0Y2hlcy5zcGxpY2UoMCwgcmVtb3RlUGF0Y2hlcy5sZW5ndGgpLCBTQVZJTkcuc2V0KGVkaXRvciwgITApLCByZXNldCA9ICEwO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdGVQYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICBwYXRjaCxcbiAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIHNuYXBzaG90LFxuICAgICAgICAgICAgICBwcmV2aW91c1NuYXBzaG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBwcmV2aW91c1NuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlYnVnJGsoXCJVbnN1YnNjcmliaW5nIHRvIHBhdGNoZXNcIiksIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9KSwgZWRpdG9yLmhpc3RvcnkgPSB7XG4gICAgICB1bmRvczogW10sXG4gICAgICByZWRvczogW11cbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQucmVhZE9ubHkpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICAgIGhpc3RvcnlcbiAgICAgIH0gPSBlZGl0b3IsIHtcbiAgICAgICAgdW5kb3NcbiAgICAgIH0gPSBoaXN0b3J5LCBzdGVwID0gdW5kb3NbdW5kb3MubGVuZ3RoIC0gMV0sIGxhc3RPcCA9IHN0ZXAgJiYgc3RlcC5vcGVyYXRpb25zICYmIHN0ZXAub3BlcmF0aW9uc1tzdGVwLm9wZXJhdGlvbnMubGVuZ3RoIC0gMV0sIG92ZXJ3cml0ZSA9IHNob3VsZE92ZXJ3cml0ZShvcCwgbGFzdE9wKSwgc2F2ZSA9IGlzU2F2aW5nKGVkaXRvcik7XG4gICAgICBsZXQgbWVyZ2UgPSAhMDtcbiAgICAgIGlmIChzYXZlKSB7XG4gICAgICAgIGlmIChzdGVwID8gb3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgKG1lcmdlID0gc2hvdWxkTWVyZ2Uob3AsIGxhc3RPcCkgfHwgb3ZlcndyaXRlKSA6IG1lcmdlID0gITEsIHN0ZXAgJiYgbWVyZ2UpXG4gICAgICAgICAgc3RlcC5vcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXdTdGVwID0ge1xuICAgICAgICAgICAgb3BlcmF0aW9uczogWy4uLmVkaXRvci5zZWxlY3Rpb24gPT09IG51bGwgPyBbXSA6IFtjcmVhdGVTZWxlY3RPcGVyYXRpb24oZWRpdG9yKV0sIG9wXSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHVuZG9zLnB1c2gobmV3U3RlcCksIGRlYnVnJGsoXCJDcmVhdGVkIG5ldyB1bmRvIHN0ZXBcIiwgc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHVuZG9zLmxlbmd0aCA+IFVORE9fU1RFUF9MSU1JVDsgKVxuICAgICAgICAgIHVuZG9zLnNoaWZ0KCk7XG4gICAgICAgIHNob3VsZENsZWFyKG9wKSAmJiAoaGlzdG9yeS5yZWRvcyA9IFtdKTtcbiAgICAgIH1cbiAgICAgIGFwcGx5MihvcCk7XG4gICAgfSwgZWRpdG9yLnVuZG8gPSAoKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnJlYWRPbmx5KVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIHVuZG9zXG4gICAgICB9ID0gZWRpdG9yLmhpc3Rvcnk7XG4gICAgICBpZiAodW5kb3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzdGVwID0gdW5kb3NbdW5kb3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkZWJ1ZyRrKFwiVW5kb2luZ1wiLCBzdGVwKSwgc3RlcC5vcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBvdGhlclBhdGNoZXMgPSByZW1vdGVQYXRjaGVzLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50aW1lID49IHN0ZXAudGltZXN0YW1wKTtcbiAgICAgICAgICBsZXQgdHJhbnNmb3JtZWRPcGVyYXRpb25zID0gc3RlcC5vcGVyYXRpb25zO1xuICAgICAgICAgIG90aGVyUGF0Y2hlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBmbGF0dGVuKHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoKG9wKSA9PiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBpdGVtLnBhdGNoLCBvcCwgaXRlbS5zbmFwc2hvdCwgaXRlbS5wcmV2aW91c1NuYXBzaG90KSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJldmVyc2VkT3BlcmF0aW9ucyA9IHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoT3BlcmF0aW9uLmludmVyc2UpLnJldmVyc2UoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgd2l0aFVuZG9pbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2l0aG91dFNhdmluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJldmVyc2VkT3BlcmF0aW9ucy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuYXBwbHkob3ApO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIGVkaXRvci5ub3JtYWxpemUoKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZWJ1ZyRrKFwiQ291bGQgbm90IHBlcmZvcm0gdW5kbyBzdGVwXCIsIGVyciksIHJlbW90ZVBhdGNoZXMuc3BsaWNlKDAsIHJlbW90ZVBhdGNoZXMubGVuZ3RoKSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBlZGl0b3IuaGlzdG9yeSA9IHtcbiAgICAgICAgICAgICAgdW5kb3M6IFtdLFxuICAgICAgICAgICAgICByZWRvczogW11cbiAgICAgICAgICAgIH0sIFNBVklORy5zZXQoZWRpdG9yLCAhMCksIHNldElzVW5kb2luZyhlZGl0b3IsICExKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkaXRvci5oaXN0b3J5LnJlZG9zLnB1c2goc3RlcCksIGVkaXRvci5oaXN0b3J5LnVuZG9zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgZWRpdG9yLnJlZG8gPSAoKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnJlYWRPbmx5KVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlZG9zXG4gICAgICB9ID0gZWRpdG9yLmhpc3Rvcnk7XG4gICAgICBpZiAocmVkb3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzdGVwID0gcmVkb3NbcmVkb3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkZWJ1ZyRrKFwiUmVkb2luZ1wiLCBzdGVwKSwgc3RlcC5vcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBvdGhlclBhdGNoZXMgPSByZW1vdGVQYXRjaGVzLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50aW1lID49IHN0ZXAudGltZXN0YW1wKTtcbiAgICAgICAgICBsZXQgdHJhbnNmb3JtZWRPcGVyYXRpb25zID0gc3RlcC5vcGVyYXRpb25zO1xuICAgICAgICAgIG90aGVyUGF0Y2hlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBmbGF0dGVuKHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoKG9wKSA9PiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBpdGVtLnBhdGNoLCBvcCwgaXRlbS5zbmFwc2hvdCwgaXRlbS5wcmV2aW91c1NuYXBzaG90KSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICB3aXRoUmVkb2luZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICB3aXRob3V0U2F2aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRPcGVyYXRpb25zLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5hcHBseShvcCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSwgZWRpdG9yLm5vcm1hbGl6ZSgpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlYnVnJGsoXCJDb3VsZCBub3QgcGVyZm9ybSByZWRvIHN0ZXBcIiwgZXJyKSwgcmVtb3RlUGF0Y2hlcy5zcGxpY2UoMCwgcmVtb3RlUGF0Y2hlcy5sZW5ndGgpLCBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5oaXN0b3J5ID0ge1xuICAgICAgICAgICAgICB1bmRvczogW10sXG4gICAgICAgICAgICAgIHJlZG9zOiBbXVxuICAgICAgICAgICAgfSwgU0FWSU5HLnNldChlZGl0b3IsICEwKSwgc2V0SXNSZWRvaW5nKGVkaXRvciwgITEpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLmhpc3RvcnkudW5kb3MucHVzaChzdGVwKSwgZWRpdG9yLmhpc3RvcnkucmVkb3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBwYXRjaCwgb3BlcmF0aW9uLCBzbmFwc2hvdCwgcHJldmlvdXNTbmFwc2hvdCkge1xuICBkZWJ1Z1ZlcmJvc2UkNCAmJiAoZGVidWckayhgQWRqdXN0aW5nICcke29wZXJhdGlvbi50eXBlfScgb3BlcmF0aW9uIHBhdGhzIGZvciAnJHtwYXRjaC50eXBlfScgcGF0Y2hgKSwgZGVidWckayhgT3BlcmF0aW9uICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uKX1gKSwgZGVidWckayhgUGF0Y2ggJHtKU09OLnN0cmluZ2lmeShwYXRjaCl9YCkpO1xuICBjb25zdCB0cmFuc2Zvcm1lZE9wZXJhdGlvbiA9IHtcbiAgICAuLi5vcGVyYXRpb25cbiAgfTtcbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwiaW5zZXJ0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBpbnNlcnRCbG9ja0luZGV4ID0gKHNuYXBzaG90IHx8IFtdKS5maW5kSW5kZXgoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgICBfa2V5OiBibGsuX2tleVxuICAgIH0sIHBhdGNoLnBhdGhbMF0pKTtcbiAgICByZXR1cm4gZGVidWckayhgQWRqdXN0aW5nIGJsb2NrIHBhdGggKCske3BhdGNoLml0ZW1zLmxlbmd0aH0pIGZvciAnJHt0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlfScgb3BlcmF0aW9uIGFuZCBwYXRjaCAnJHtwYXRjaC50eXBlfSdgKSwgW2FkanVzdEJsb2NrUGF0aCh0cmFuc2Zvcm1lZE9wZXJhdGlvbiwgcGF0Y2guaXRlbXMubGVuZ3RoLCBpbnNlcnRCbG9ja0luZGV4KV07XG4gIH1cbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHVuc2V0QmxvY2tJbmRleCA9IChwcmV2aW91c1NuYXBzaG90IHx8IFtdKS5maW5kSW5kZXgoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgICBfa2V5OiBibGsuX2tleVxuICAgIH0sIHBhdGNoLnBhdGhbMF0pKTtcbiAgICByZXR1cm4gXCJwYXRoXCIgaW4gdHJhbnNmb3JtZWRPcGVyYXRpb24gJiYgQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoKSAmJiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoWzBdID09PSB1bnNldEJsb2NrSW5kZXggPyAoZGVidWckayhcIlNraXBwaW5nIHRyYW5zZm9ybWF0aW9uIHRoYXQgdGFyZ2V0ZWQgcmVtb3ZlZCBibG9ja1wiKSwgW10pIDogKGRlYnVnVmVyYm9zZSQ0ICYmIChkZWJ1ZyRrKGBTZWxlY3Rpb24gJHtKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uKX1gKSwgZGVidWckayhgQWRqdXN0aW5nIGJsb2NrIHBhdGggKC0xKSBmb3IgJyR7dHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZX0nIG9wZXJhdGlvbiBhbmQgcGF0Y2ggJyR7cGF0Y2gudHlwZX0nYCkpLCBbYWRqdXN0QmxvY2tQYXRoKHRyYW5zZm9ybWVkT3BlcmF0aW9uLCAtMSwgdW5zZXRCbG9ja0luZGV4KV0pO1xuICB9XG4gIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGRlYnVnJGsoYEFkanVzdGluZyBzZWxlY3Rpb24gZm9yIHVuc2V0IGV2ZXJ5dGhpbmcgcGF0Y2ggYW5kICR7b3BlcmF0aW9uLnR5cGV9IG9wZXJhdGlvbmApLCBbXTtcbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwiZGlmZk1hdGNoUGF0Y2hcIikge1xuICAgIGNvbnN0IG9wZXJhdGlvblRhcmdldEJsb2NrID0gZmluZE9wZXJhdGlvblRhcmdldEJsb2NrKGVkaXRvciwgdHJhbnNmb3JtZWRPcGVyYXRpb24pO1xuICAgIHJldHVybiAhb3BlcmF0aW9uVGFyZ2V0QmxvY2sgfHwgIWlzRXF1YWwoe1xuICAgICAgX2tleTogb3BlcmF0aW9uVGFyZ2V0QmxvY2suX2tleVxuICAgIH0sIHBhdGNoLnBhdGhbMF0pID8gW3RyYW5zZm9ybWVkT3BlcmF0aW9uXSA6IChwYXJzZShwYXRjaC52YWx1ZSkuZm9yRWFjaCgoZGlmZlBhdGNoKSA9PiB7XG4gICAgICBsZXQgYWRqdXN0T2Zmc2V0QnkgPSAwLCBjaGFuZ2VkT2Zmc2V0ID0gZGlmZlBhdGNoLnV0ZjhTdGFydDE7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpZmZzXG4gICAgICB9ID0gZGlmZlBhdGNoO1xuICAgICAgaWYgKGRpZmZzLmZvckVhY2goKGRpZmYyLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBbZGlmZlR5cGUsIHRleHRdID0gZGlmZjI7XG4gICAgICAgIGRpZmZUeXBlID09PSBESUZGX0lOU0VSVCA/IChhZGp1c3RPZmZzZXRCeSArPSB0ZXh0Lmxlbmd0aCwgY2hhbmdlZE9mZnNldCArPSB0ZXh0Lmxlbmd0aCkgOiBkaWZmVHlwZSA9PT0gRElGRl9ERUxFVEUgPyAoYWRqdXN0T2Zmc2V0QnkgLT0gdGV4dC5sZW5ndGgsIGNoYW5nZWRPZmZzZXQgLT0gdGV4dC5sZW5ndGgpIDogZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgKGRpZmZzLnNsaWNlKGluZGV4KS5ldmVyeSgoW2RUeXBlXSkgPT4gZFR5cGUgPT09IERJRkZfRVFVQUwpIHx8IChjaGFuZ2VkT2Zmc2V0ICs9IHRleHQubGVuZ3RoKSk7XG4gICAgICB9KSwgdHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiICYmIGNoYW5nZWRPZmZzZXQgPCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCArPSBhZGp1c3RPZmZzZXRCeSksIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwicmVtb3ZlX3RleHRcIiAmJiBjaGFuZ2VkT2Zmc2V0IDw9IHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCAtIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnRleHQubGVuZ3RoICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgKz0gYWRqdXN0T2Zmc2V0QnkpLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIikge1xuICAgICAgICBjb25zdCBjdXJyZW50Rm9jdXMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzPy5mb2N1cyA/IHtcbiAgICAgICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0gOiB2b2lkIDAsIGN1cnJlbnRBbmNob3IgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ucHJvcGVydGllcz8uYW5jaG9yID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuYW5jaG9yXG4gICAgICAgIH0gOiB2b2lkIDAsIG5ld0ZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSA6IHZvaWQgMCwgbmV3QW5jaG9yID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmFuY2hvciA/IHtcbiAgICAgICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmFuY2hvclxuICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICAoY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgfHwgbmV3Rm9jdXMgJiYgbmV3QW5jaG9yKSAmJiAoW2N1cnJlbnRGb2N1cywgY3VycmVudEFuY2hvciwgbmV3Rm9jdXMsIG5ld0FuY2hvcl0uZm9yRWFjaCgocG9pbnQpID0+IHtcbiAgICAgICAgICBwb2ludCAmJiBjaGFuZ2VkT2Zmc2V0IDwgcG9pbnQub2Zmc2V0ICYmIChwb2ludC5vZmZzZXQgKz0gYWRqdXN0T2Zmc2V0QnkpO1xuICAgICAgICB9KSwgY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgZm9jdXM6IGN1cnJlbnRGb2N1cyxcbiAgICAgICAgICBhbmNob3I6IGN1cnJlbnRBbmNob3JcbiAgICAgICAgfSksIG5ld0ZvY3VzICYmIG5ld0FuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcyA9IHtcbiAgICAgICAgICBmb2N1czogbmV3Rm9jdXMsXG4gICAgICAgICAgYW5jaG9yOiBuZXdBbmNob3JcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pLCBbdHJhbnNmb3JtZWRPcGVyYXRpb25dKTtcbiAgfVxuICByZXR1cm4gW3RyYW5zZm9ybWVkT3BlcmF0aW9uXTtcbn1cbmZ1bmN0aW9uIGFkanVzdEJsb2NrUGF0aChvcGVyYXRpb24sIGxldmVsLCBibG9ja0luZGV4KSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVkT3BlcmF0aW9uID0ge1xuICAgIC4uLm9wZXJhdGlvblxuICB9O1xuICBpZiAoYmxvY2tJbmRleCA+PSAwICYmIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgIT09IFwic2V0X3NlbGVjdGlvblwiICYmIEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aCkgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSA+PSBibG9ja0luZGV4ICsgbGV2ZWwgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSArIGxldmVsID4gLTEpIHtcbiAgICBjb25zdCBuZXdQYXRoID0gW3RyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGhbMF0gKyBsZXZlbCwgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aC5zbGljZSgxKV07XG4gICAgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aCA9IG5ld1BhdGg7XG4gIH1cbiAgaWYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSB7XG4gICAgY29uc3QgY3VycmVudEZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcz8uZm9jdXMgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgfSA6IHZvaWQgMCwgY3VycmVudEFuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5wcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmFuY2hvclxuICAgIH0gOiB2b2lkIDAsIG5ld0ZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcy5mb2N1c1xuICAgIH0gOiB2b2lkIDAsIG5ld0FuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5uZXdQcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmFuY2hvclxuICAgIH0gOiB2b2lkIDA7XG4gICAgKGN1cnJlbnRGb2N1cyAmJiBjdXJyZW50QW5jaG9yIHx8IG5ld0ZvY3VzICYmIG5ld0FuY2hvcikgJiYgKFtjdXJyZW50Rm9jdXMsIGN1cnJlbnRBbmNob3IsIG5ld0ZvY3VzLCBuZXdBbmNob3JdLmZvckVhY2goKHBvaW50KSA9PiB7XG4gICAgICBwb2ludCAmJiBwb2ludC5wYXRoWzBdID49IGJsb2NrSW5kZXggKyBsZXZlbCAmJiBwb2ludC5wYXRoWzBdICsgbGV2ZWwgPiAtMSAmJiAocG9pbnQucGF0aCA9IFtwb2ludC5wYXRoWzBdICsgbGV2ZWwsIC4uLnBvaW50LnBhdGguc2xpY2UoMSldKTtcbiAgICB9KSwgY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMgPSB7XG4gICAgICBmb2N1czogY3VycmVudEZvY3VzLFxuICAgICAgYW5jaG9yOiBjdXJyZW50QW5jaG9yXG4gICAgfSksIG5ld0ZvY3VzICYmIG5ld0FuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcyA9IHtcbiAgICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICAgIGFuY2hvcjogbmV3QW5jaG9yXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1lZE9wZXJhdGlvbjtcbn1cbmNvbnN0IHNob3VsZE1lcmdlID0gKG9wLCBwcmV2KSA9PiAhIShvcC50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiB8fCBwcmV2ICYmIG9wLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBwcmV2LnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBvcC5vZmZzZXQgPT09IHByZXYub2Zmc2V0ICsgcHJldi50ZXh0Lmxlbmd0aCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpICYmIG9wLnRleHQgIT09IFwiIFwiIHx8IHByZXYgJiYgb3AudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIHByZXYudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoID09PSBwcmV2Lm9mZnNldCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpKSwgc2hvdWxkT3ZlcndyaXRlID0gKG9wLCBwcmV2KSA9PiAhIShwcmV2ICYmIG9wLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiICYmIHByZXYudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpLCBzaG91bGRDbGVhciA9IChvcCkgPT4gb3AudHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCI7XG5mdW5jdGlvbiB3aXRob3V0U2F2aW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzU2F2aW5nKGVkaXRvcik7XG4gIFNBVklORy5zZXQoZWRpdG9yLCAhMSksIGZuKCksIFNBVklORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdE9wZXJhdGlvbihlZGl0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNldF9zZWxlY3Rpb25cIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAuLi5lZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSxcbiAgICBuZXdQcm9wZXJ0aWVzOiB7XG4gICAgICAuLi5lZGl0b3Iuc2VsZWN0aW9uXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZE9wZXJhdGlvblRhcmdldEJsb2NrKGVkaXRvciwgb3BlcmF0aW9uKSB7XG4gIGxldCBibG9jaztcbiAgcmV0dXJuIG9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiAmJiBlZGl0b3Iuc2VsZWN0aW9uID8gYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdXSA6IFwicGF0aFwiIGluIG9wZXJhdGlvbiAmJiAoYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dKSwgYmxvY2s7XG59XG5jb25zdCBkZWJ1ZyRqID0gZGVidWdXaXRoTmFtZShcImhvb2s6dXNlU3luY1ZhbHVlXCIpLCBDVVJSRU5UX1ZBTFVFID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB1c2VTeW5jVmFsdWUocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHBvcnRhYmxlVGV4dEVkaXRvcixcbiAgICByZWFkT25seSxcbiAgICBzbGF0ZUVkaXRvclxuICB9ID0gcHJvcHMsIHNjaGVtYVR5cGVzID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSwgcHJldmlvdXNWYWx1ZSA9IHVzZVJlZigpLCB1cGRhdGVWYWx1ZUZ1bmN0aW9uUmVmID0gdXNlUmVmKCksIHVwZGF0ZUZyb21DdXJyZW50VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gQ1VSUkVOVF9WQUxVRS5nZXQocG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICBpZiAocHJldmlvdXNWYWx1ZS5jdXJyZW50ID09PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgIGRlYnVnJGooXCJWYWx1ZSBpcyB0aGUgc2FtZSBvYmplY3QgYXMgcHJldmlvdXMsIG5vdCBuZWVkIHRvIHN5bmNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVwZGF0ZVZhbHVlRnVuY3Rpb25SZWYuY3VycmVudCAmJiBjdXJyZW50VmFsdWUgJiYgKGRlYnVnJGooXCJVcGRhdGluZyB0aGUgdmFsdWUgZGVib3VuY2VkXCIpLCB1cGRhdGVWYWx1ZUZ1bmN0aW9uUmVmLmN1cnJlbnQoY3VycmVudFZhbHVlKSk7XG4gIH0sIFtwb3J0YWJsZVRleHRFZGl0b3JdKSwgdXBkYXRlVmFsdWVEZWJvdW5jZWQgPSB1c2VNZW1vKCgpID0+IGRlYm91bmNlKHVwZGF0ZUZyb21DdXJyZW50VmFsdWUsIDFlMywge1xuICAgIHRyYWlsaW5nOiAhMCxcbiAgICBsZWFkaW5nOiAhMVxuICB9KSwgW3VwZGF0ZUZyb21DdXJyZW50VmFsdWVdKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZUZ1bmN0aW9uID0gKHZhbHVlKSA9PiB7XG4gICAgICBDVVJSRU5UX1ZBTFVFLnNldChwb3J0YWJsZVRleHRFZGl0b3IsIHZhbHVlKTtcbiAgICAgIGNvbnN0IGlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlcyA9IGlzQ2hhbmdpbmdMb2NhbGx5KHNsYXRlRWRpdG9yKSwgaXNQcm9jZXNzaW5nUmVtb3RlQ2hhbmdlcyA9IGlzQ2hhbmdpbmdSZW1vdGVseShzbGF0ZUVkaXRvcik7XG4gICAgICBpZiAoIXJlYWRPbmx5KSB7XG4gICAgICAgIGlmIChpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXMpIHtcbiAgICAgICAgICBkZWJ1ZyRqKFwiSGFzIGxvY2FsIGNoYW5nZXMsIG5vdCBzeW5jaW5nIHZhbHVlIHJpZ2h0IG5vd1wiKSwgdXBkYXRlVmFsdWVEZWJvdW5jZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvY2Vzc2luZ1JlbW90ZUNoYW5nZXMpIHtcbiAgICAgICAgICBkZWJ1ZyRqKFwiSGFzIHJlbW90ZSBjaGFuZ2VzLCBub3Qgc3luY2luZyB2YWx1ZSByaWdodCBub3dcIiksIHVwZGF0ZVZhbHVlRGVib3VuY2VkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaXNDaGFuZ2VkID0gITEsIGlzVmFsaWQgPSAhMDtcbiAgICAgIGNvbnN0IGhhZFNlbGVjdGlvbiA9ICEhc2xhdGVFZGl0b3Iuc2VsZWN0aW9uO1xuICAgICAgaWYgKCghdmFsdWUgfHwgdmFsdWUubGVuZ3RoID09PSAwKSAmJiAoZGVidWckaihcIlZhbHVlIGlzIGVtcHR5XCIpLCBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIHdpdGhvdXRTYXZpbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICB3aXRob3V0UGF0Y2hpbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIGhhZFNlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLmRlc2VsZWN0KHNsYXRlRWRpdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gc2xhdGVFZGl0b3IuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgc2xhdGVFZGl0b3IuY2hpbGRyZW4uZm9yRWFjaCgoXywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBbY2hpbGRyZW5MZW5ndGggLSAxIC0gaW5kZXhdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIHNsYXRlRWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICAgICAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgICBhdDogWzBdXG4gICAgICAgICAgICB9KSwgaGFkU2VsZWN0aW9uICYmIFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBbMCwgMF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pLCBpc0NoYW5nZWQgPSAhMCksIHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc2xhdGVWYWx1ZUZyb21Qcm9wcyA9IHRvU2xhdGVWYWx1ZSh2YWx1ZSwge1xuICAgICAgICAgIHNjaGVtYVR5cGVzXG4gICAgICAgIH0pO1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgd2l0aFJlbW90ZUNoYW5nZXMoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgd2l0aG91dFBhdGNoaW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5MZW5ndGhfMCA9IHNsYXRlRWRpdG9yLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoc2xhdGVWYWx1ZUZyb21Qcm9wcy5sZW5ndGggPCBjaGlsZHJlbkxlbmd0aF8wKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW5MZW5ndGhfMCAtIDE7IGkgPiBzbGF0ZVZhbHVlRnJvbVByb3BzLmxlbmd0aCAtIDE7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgIGF0OiBbaV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpc0NoYW5nZWQgPSAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2xhdGVWYWx1ZUZyb21Qcm9wcy5mb3JFYWNoKChjdXJyZW50QmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvbGRCbG9jayA9IHNsYXRlRWRpdG9yLmNoaWxkcmVuW2N1cnJlbnRCbG9ja0luZGV4XTtcbiAgICAgICAgICAgICAgICAgIGlmIChvbGRCbG9jayAmJiAhaXNFcXVhbChjdXJyZW50QmxvY2ssIG9sZEJsb2NrKSAmJiBpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25WYWx1ZSA9IFt2YWx1ZVtjdXJyZW50QmxvY2tJbmRleF1dLCB2YWxpZGF0aW9uID0gdmFsaWRhdGVWYWx1ZSh2YWxpZGF0aW9uVmFsdWUsIHNjaGVtYVR5cGVzLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgIXZhbGlkYXRpb24udmFsaWQgJiYgdmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5hdXRvUmVzb2x2ZSAmJiB2YWxpZGF0aW9uLnJlc29sdXRpb24/LnBhdGNoZXMubGVuZ3RoID4gMCAmJiAhcmVhZE9ubHkgJiYgcHJldmlvdXNWYWx1ZS5jdXJyZW50ICYmIHByZXZpb3VzVmFsdWUuY3VycmVudCAhPT0gdmFsdWUgJiYgKGNvbnNvbGUud2FybihgJHt2YWxpZGF0aW9uLnJlc29sdXRpb24uYWN0aW9ufSBmb3IgYmxvY2sgd2l0aCBfa2V5ICcke3ZhbGlkYXRpb25WYWx1ZVswXS5fa2V5fScuICR7dmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5kZXNjcmlwdGlvbn1gKSwgdmFsaWRhdGlvbi5yZXNvbHV0aW9uLnBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicGF0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKSwgdmFsaWRhdGlvbi52YWxpZCB8fCB2YWxpZGF0aW9uLnJlc29sdXRpb24/LmF1dG9SZXNvbHZlID8gKG9sZEJsb2NrLl9rZXkgPT09IGN1cnJlbnRCbG9jay5fa2V5ID8gKGRlYnVnJGouZW5hYmxlZCAmJiBkZWJ1ZyRqKFwiVXBkYXRpbmcgYmxvY2tcIiwgb2xkQmxvY2ssIGN1cnJlbnRCbG9jayksIF91cGRhdGVCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBvbGRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpKSA6IChkZWJ1ZyRqLmVuYWJsZWQgJiYgZGVidWckaihcIlJlcGxhY2luZyBibG9ja1wiLCBvbGRCbG9jaywgY3VycmVudEJsb2NrKSwgX3JlcGxhY2VCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkpLCBpc0NoYW5nZWQgPSAhMCkgOiAoZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkIHZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x1dGlvbjogdmFsaWRhdGlvbi5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pLCBpc1ZhbGlkID0gITEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCFvbGRCbG9jayAmJiBpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25WYWx1ZV8wID0gW3ZhbHVlW2N1cnJlbnRCbG9ja0luZGV4XV0sIHZhbGlkYXRpb25fMCA9IHZhbGlkYXRlVmFsdWUodmFsaWRhdGlvblZhbHVlXzAsIHNjaGVtYVR5cGVzLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWckai5lbmFibGVkICYmIGRlYnVnJGooXCJWYWxpZGF0aW5nIGFuZCBpbnNlcnRpbmcgbmV3IGJsb2NrIGluIHRoZSBlbmQgb2YgdGhlIHZhbHVlXCIsIGN1cnJlbnRCbG9jayksIHZhbGlkYXRpb25fMC52YWxpZCB8fCB2YWxpZGF0aW9uXzAucmVzb2x1dGlvbj8uYXV0b1Jlc29sdmUgPyBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4XVxuICAgICAgICAgICAgICAgICAgICB9KSA6IChkZWJ1ZyRqKFwiSW52YWxpZFwiLCB2YWxpZGF0aW9uXzApLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWQgdmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHV0aW9uOiB2YWxpZGF0aW9uXzAucmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KSwgaXNWYWxpZCA9ICExKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgZGVidWckaihcIkludmFsaWQgdmFsdWUsIHJldHVybmluZ1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICBkZWJ1ZyRqKFwiU2VydmVyIHZhbHVlIGNoYW5nZWQsIHN5bmNpbmcgZWRpdG9yXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWQgdmFsdWVcIixcbiAgICAgICAgICAgIHJlc29sdXRpb246IG51bGwsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYWRTZWxlY3Rpb24gJiYgIXNsYXRlRWRpdG9yLnNlbGVjdGlvbiAmJiAoVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInZhbHVlIGNoYW5nZWRcIixcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBkZWJ1ZyRqKFwiU2VydmVyIHZhbHVlIGFuZCBlZGl0b3IgdmFsdWUgaXMgZXF1YWwsIG5vIG5lZWQgdG8gc3luYy5cIik7XG4gICAgICBwcmV2aW91c1ZhbHVlLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGVWYWx1ZUZ1bmN0aW9uUmVmLmN1cnJlbnQgPSB1cGRhdGVGdW5jdGlvbiwgdXBkYXRlRnVuY3Rpb247XG4gIH0sIFtlZGl0b3JBY3RvciwgcG9ydGFibGVUZXh0RWRpdG9yLCByZWFkT25seSwgc2NoZW1hVHlwZXMsIHNsYXRlRWRpdG9yLCB1cGRhdGVWYWx1ZURlYm91bmNlZF0pO1xufVxuZnVuY3Rpb24gX3JlcGxhY2VCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkge1xuICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gc2xhdGVFZGl0b3Iuc2VsZWN0aW9uLCBzZWxlY3Rpb25Gb2N1c09uQmxvY2sgPSBjdXJyZW50U2VsZWN0aW9uICYmIGN1cnJlbnRTZWxlY3Rpb24uZm9jdXMucGF0aFswXSA9PT0gY3VycmVudEJsb2NrSW5kZXg7XG4gIHNlbGVjdGlvbkZvY3VzT25CbG9jayAmJiBUcmFuc2Zvcm1zLmRlc2VsZWN0KHNsYXRlRWRpdG9yKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIHtcbiAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4XVxuICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSwgc2VsZWN0aW9uRm9jdXNPbkJsb2NrICYmIFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBjdXJyZW50U2VsZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBvbGRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpIHtcbiAgaWYgKFRyYW5zZm9ybXMuc2V0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywge1xuICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gIH0pLCBzbGF0ZUVkaXRvci5pc1RleHRCbG9jayhjdXJyZW50QmxvY2spICYmIHNsYXRlRWRpdG9yLmlzVGV4dEJsb2NrKG9sZEJsb2NrKSkge1xuICAgIGNvbnN0IG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggPSBvbGRCbG9jay5jaGlsZHJlbi5sZW5ndGg7XG4gICAgY3VycmVudEJsb2NrLmNoaWxkcmVuLmxlbmd0aCA8IG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggJiYgQXJyYXkuZnJvbShBcnJheShvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoIC0gY3VycmVudEJsb2NrLmNoaWxkcmVuLmxlbmd0aCkpLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjaGlsZEluZGV4ID0gb2xkQmxvY2tDaGlsZHJlbkxlbmd0aCAtIDEgLSBpbmRleDtcbiAgICAgIGNoaWxkSW5kZXggPiAwICYmIChkZWJ1ZyRqKFwiUmVtb3ZpbmcgY2hpbGRcIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY2hpbGRJbmRleF1cbiAgICAgIH0pKTtcbiAgICB9KSwgY3VycmVudEJsb2NrLmNoaWxkcmVuLmZvckVhY2goKGN1cnJlbnRCbG9ja0NoaWxkLCBjdXJyZW50QmxvY2tDaGlsZEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBvbGRCbG9ja0NoaWxkID0gb2xkQmxvY2suY2hpbGRyZW5bY3VycmVudEJsb2NrQ2hpbGRJbmRleF0sIGlzQ2hpbGRDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEJsb2NrQ2hpbGQsIG9sZEJsb2NrQ2hpbGQpLCBpc1RleHRDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEJsb2NrQ2hpbGQudGV4dCwgb2xkQmxvY2tDaGlsZD8udGV4dCksIHBhdGggPSBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdO1xuICAgICAgaWYgKGlzQ2hpbGRDaGFuZ2VkKVxuICAgICAgICBpZiAoY3VycmVudEJsb2NrQ2hpbGQuX2tleSA9PT0gb2xkQmxvY2tDaGlsZD8uX2tleSkge1xuICAgICAgICAgIGRlYnVnJGooXCJVcGRhdGluZyBjaGFuZ2VkIGNoaWxkXCIsIGN1cnJlbnRCbG9ja0NoaWxkLCBvbGRCbG9ja0NoaWxkKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaXNTcGFuTm9kZSA9IFRleHQuaXNUZXh0KGN1cnJlbnRCbG9ja0NoaWxkKSAmJiBjdXJyZW50QmxvY2tDaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgVGV4dC5pc1RleHQob2xkQmxvY2tDaGlsZCkgJiYgb2xkQmxvY2tDaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCI7XG4gICAgICAgICAgaXNTcGFuTm9kZSAmJiBpc1RleHRDaGFuZ2VkID8gKFRyYW5zZm9ybXMuZGVsZXRlKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgICBhdDoge1xuICAgICAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvbGRCbG9ja0NoaWxkLnRleHQubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2tDaGlsZC50ZXh0LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSA6IGlzU3Bhbk5vZGUgfHwgKGRlYnVnJGooXCJVcGRhdGluZyBjaGFuZ2VkIGlubGluZSBvYmplY3QgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgICBfa2V5OiBWT0lEX0NISUxEX0tFWVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBbLi4ucGF0aCwgMF0sXG4gICAgICAgICAgICB2b2lkczogITBcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBvbGRCbG9ja0NoaWxkID8gKGRlYnVnJGooXCJSZXBsYWNpbmcgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF1cbiAgICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9ja0NoaWxkLCB7XG4gICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF1cbiAgICAgICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpIDogb2xkQmxvY2tDaGlsZCB8fCAoZGVidWckaihcIkluc2VydGluZyBuZXcgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2tDaGlsZCwge1xuICAgICAgICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdXG4gICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgZGVidWckaSA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yOlN5bmNocm9uaXplclwiKSwgZGVidWdWZXJib3NlJDMgPSBkZWJ1ZyRpLmVuYWJsZWQgJiYgITEsIEZMVVNIX1BBVENIRVNfVEhST1RUTEVEX01TID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwidGVzdFwiID8gNTAwIDogMWUzO1xuZnVuY3Rpb24gU3luY2hyb25pemVyKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDI2KSwgcmVhZE9ubHkgPSB1c2VTZWxlY3Rvcihwcm9wcy5lZGl0b3JBY3RvciwgX3RlbXApLCB2YWx1ZSA9IHVzZVNlbGVjdG9yKHByb3BzLmVkaXRvckFjdG9yLCBfdGVtcDIpLCB7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgZ2V0VmFsdWUsXG4gICAgcG9ydGFibGVUZXh0RWRpdG9yLFxuICAgIHNsYXRlRWRpdG9yXG4gIH0gPSBwcm9wcztcbiAgbGV0IHQwO1xuICAkWzBdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0MCA9IFtdLCAkWzBdID0gdDApIDogdDAgPSAkWzBdO1xuICBjb25zdCBwZW5kaW5nUGF0Y2hlcyA9IHVzZVJlZih0MCk7XG4gIGxldCB0MTtcbiAgJFsxXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsyXSAhPT0gcG9ydGFibGVUZXh0RWRpdG9yIHx8ICRbM10gIT09IHJlYWRPbmx5IHx8ICRbNF0gIT09IHNsYXRlRWRpdG9yID8gKHQxID0ge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHBvcnRhYmxlVGV4dEVkaXRvcixcbiAgICByZWFkT25seSxcbiAgICBzbGF0ZUVkaXRvclxuICB9LCAkWzFdID0gZWRpdG9yQWN0b3IsICRbMl0gPSBwb3J0YWJsZVRleHRFZGl0b3IsICRbM10gPSByZWFkT25seSwgJFs0XSA9IHNsYXRlRWRpdG9yLCAkWzVdID0gdDEpIDogdDEgPSAkWzVdO1xuICBjb25zdCBzeW5jVmFsdWUgPSB1c2VTeW5jVmFsdWUodDEpO1xuICBsZXQgdDIsIHQzO1xuICAkWzZdICE9PSBzbGF0ZUVkaXRvciA/ICh0MiA9ICgpID0+IHtcbiAgICBJU19QUk9DRVNTSU5HX0xPQ0FMX0NIQU5HRVMuc2V0KHNsYXRlRWRpdG9yLCAhMSk7XG4gIH0sIHQzID0gW3NsYXRlRWRpdG9yXSwgJFs2XSA9IHNsYXRlRWRpdG9yLCAkWzddID0gdDIsICRbOF0gPSB0MykgOiAodDIgPSAkWzddLCB0MyA9ICRbOF0pLCB1c2VFZmZlY3QodDIsIHQzKTtcbiAgbGV0IHQ0O1xuICAkWzldICE9PSBlZGl0b3JBY3RvciB8fCAkWzEwXSAhPT0gZ2V0VmFsdWUgfHwgJFsxMV0gIT09IHNsYXRlRWRpdG9yID8gKHQ0ID0gKCkgPT4ge1xuICAgIGlmIChwZW5kaW5nUGF0Y2hlcy5jdXJyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGRlYnVnJGkoXCJGbHVzaGluZyBwZW5kaW5nIHBhdGNoZXNcIiksIGRlYnVnVmVyYm9zZSQzICYmIGRlYnVnJGkoYFBhdGNoZXM6XG4ke0pTT04uc3RyaW5naWZ5KHBlbmRpbmdQYXRjaGVzLmN1cnJlbnQsIG51bGwsIDIpfWApO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSBnZXRWYWx1ZSgpO1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwibXV0YXRpb25cIixcbiAgICAgICAgcGF0Y2hlczogcGVuZGluZ1BhdGNoZXMuY3VycmVudCxcbiAgICAgICAgc25hcHNob3RcbiAgICAgIH0pLCBwZW5kaW5nUGF0Y2hlcy5jdXJyZW50ID0gW107XG4gICAgfVxuICAgIElTX1BST0NFU1NJTkdfTE9DQUxfQ0hBTkdFUy5zZXQoc2xhdGVFZGl0b3IsICExKTtcbiAgfSwgJFs5XSA9IGVkaXRvckFjdG9yLCAkWzEwXSA9IGdldFZhbHVlLCAkWzExXSA9IHNsYXRlRWRpdG9yLCAkWzEyXSA9IHQ0KSA6IHQ0ID0gJFsxMl07XG4gIGNvbnN0IG9uRmx1c2hQZW5kaW5nUGF0Y2hlcyA9IHQ0O1xuICBsZXQgdDUsIHQ2O1xuICAkWzEzXSAhPT0gb25GbHVzaFBlbmRpbmdQYXRjaGVzID8gKHQ1ID0gKCkgPT4gKCkgPT4ge1xuICAgIG9uRmx1c2hQZW5kaW5nUGF0Y2hlcygpO1xuICB9LCB0NiA9IFtvbkZsdXNoUGVuZGluZ1BhdGNoZXNdLCAkWzEzXSA9IG9uRmx1c2hQZW5kaW5nUGF0Y2hlcywgJFsxNF0gPSB0NSwgJFsxNV0gPSB0NikgOiAodDUgPSAkWzE0XSwgdDYgPSAkWzE1XSksIHVzZUVmZmVjdCh0NSwgdDYpO1xuICBsZXQgdDcsIHQ4O1xuICAkWzE2XSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxN10gIT09IG9uRmx1c2hQZW5kaW5nUGF0Y2hlcyB8fCAkWzE4XSAhPT0gc2xhdGVFZGl0b3IgPyAodDcgPSAoKSA9PiB7XG4gICAgY29uc3Qgb25GbHVzaFBlbmRpbmdQYXRjaGVzVGhyb3R0bGVkID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgaWYgKEVkaXRvci5pc05vcm1hbGl6aW5nKHNsYXRlRWRpdG9yKSkge1xuICAgICAgICBvbkZsdXNoUGVuZGluZ1BhdGNoZXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb25GbHVzaFBlbmRpbmdQYXRjaGVzVGhyb3R0bGVkKCk7XG4gICAgfSwgRkxVU0hfUEFUQ0hFU19USFJPVFRMRURfTVMsIHtcbiAgICAgIGxlYWRpbmc6ICExLFxuICAgICAgdHJhaWxpbmc6ICEwXG4gICAgfSk7XG4gICAgZGVidWckaShcIlN1YnNjcmliaW5nIHRvIHBhdGNoIGV2ZW50c1wiKTtcbiAgICBjb25zdCBzdWIgPSBlZGl0b3JBY3Rvci5vbihcInBhdGNoXCIsIChldmVudCkgPT4ge1xuICAgICAgSVNfUFJPQ0VTU0lOR19MT0NBTF9DSEFOR0VTLnNldChzbGF0ZUVkaXRvciwgITApLCBwZW5kaW5nUGF0Y2hlcy5jdXJyZW50LnB1c2goZXZlbnQucGF0Y2gpLCBvbkZsdXNoUGVuZGluZ1BhdGNoZXNUaHJvdHRsZWQoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVidWckaShcIlVuc3Vic2NyaWJpbmcgdG8gcGF0Y2ggZXZlbnRzXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0OCA9IFtlZGl0b3JBY3Rvciwgb25GbHVzaFBlbmRpbmdQYXRjaGVzLCBzbGF0ZUVkaXRvcl0sICRbMTZdID0gZWRpdG9yQWN0b3IsICRbMTddID0gb25GbHVzaFBlbmRpbmdQYXRjaGVzLCAkWzE4XSA9IHNsYXRlRWRpdG9yLCAkWzE5XSA9IHQ3LCAkWzIwXSA9IHQ4KSA6ICh0NyA9ICRbMTldLCB0OCA9ICRbMjBdKSwgdXNlRWZmZWN0KHQ3LCB0OCk7XG4gIGNvbnN0IGlzSW5pdGlhbFZhbHVlRnJvbVByb3BzID0gdXNlUmVmKCEwKTtcbiAgbGV0IHQxMCwgdDk7XG4gIHJldHVybiAkWzIxXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsyMl0gIT09IHN5bmNWYWx1ZSB8fCAkWzIzXSAhPT0gdmFsdWUgPyAodDkgPSAoKSA9PiB7XG4gICAgZGVidWckaShcIlZhbHVlIGZyb20gcHJvcHMgY2hhbmdlZCwgc3luY2luZyBuZXcgdmFsdWVcIiksIHN5bmNWYWx1ZSh2YWx1ZSksIGlzSW5pdGlhbFZhbHVlRnJvbVByb3BzLmN1cnJlbnQgJiYgKGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJyZWFkeVwiXG4gICAgfSksIGlzSW5pdGlhbFZhbHVlRnJvbVByb3BzLmN1cnJlbnQgPSAhMSk7XG4gIH0sIHQxMCA9IFtlZGl0b3JBY3Rvciwgc3luY1ZhbHVlLCB2YWx1ZV0sICRbMjFdID0gZWRpdG9yQWN0b3IsICRbMjJdID0gc3luY1ZhbHVlLCAkWzIzXSA9IHZhbHVlLCAkWzI0XSA9IHQxMCwgJFsyNV0gPSB0OSkgOiAodDEwID0gJFsyNF0sIHQ5ID0gJFsyNV0pLCB1c2VFZmZlY3QodDksIHQxMCksIG51bGw7XG59XG5mdW5jdGlvbiBfdGVtcDIoc18wKSB7XG4gIHJldHVybiBzXzAuY29udGV4dC52YWx1ZTtcbn1cbmZ1bmN0aW9uIF90ZW1wKHMpIHtcbiAgcmV0dXJuIHMuY29udGV4dC5yZWFkT25seTtcbn1cblN5bmNocm9uaXplci5kaXNwbGF5TmFtZSA9IFwiU3luY2hyb25pemVyXCI7XG5jb25zdCBFZGl0b3JBY3RvckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KSwgUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCksIHVzZVBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbiA9ICgpID0+IHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gdXNlQ29udGV4dChQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Db250ZXh0KTtcbiAgaWYgKHNlbGVjdGlvbiA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxQb3J0YWJsZVRleHRFZGl0b3I+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICByZXR1cm4gc2VsZWN0aW9uO1xufSwgZGVidWckaCA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yOlNlbGVjdGlvblByb3ZpZGVyXCIpLCBkZWJ1Z1ZlcmJvc2UkMiA9IGRlYnVnJGguZW5hYmxlZCAmJiAhMTtcbmZ1bmN0aW9uIFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvblByb3ZpZGVyKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDYpLCBbc2VsZWN0aW9uLCBzZXRTZWxlY3Rpb25dID0gdXNlU3RhdGUobnVsbCk7XG4gIGxldCB0MCwgdDE7XG4gICRbMF0gIT09IHByb3BzLmVkaXRvckFjdG9yID8gKHQwID0gKCkgPT4ge1xuICAgIGRlYnVnJGgoXCJTdWJzY3JpYmluZyB0byBzZWxlY3Rpb24gY2hhbmdlc1wiKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBwcm9wcy5lZGl0b3JBY3Rvci5vbihcInNlbGVjdGlvblwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGRlYnVnVmVyYm9zZSQyICYmIGRlYnVnJGgoXCJTZXR0aW5nIHNlbGVjdGlvblwiKSwgc2V0U2VsZWN0aW9uKGV2ZW50LnNlbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVidWckaChcIlVuc3Vic2NyaWJpbmcgdG8gc2VsZWN0aW9uIGNoYW5nZXNcIiksIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQxID0gW3Byb3BzLmVkaXRvckFjdG9yXSwgJFswXSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzFdID0gdDAsICRbMl0gPSB0MSkgOiAodDAgPSAkWzFdLCB0MSA9ICRbMl0pLCB1c2VFZmZlY3QodDAsIHQxKTtcbiAgbGV0IHQyO1xuICByZXR1cm4gJFszXSAhPT0gcHJvcHMuY2hpbGRyZW4gfHwgJFs0XSAhPT0gc2VsZWN0aW9uID8gKHQyID0gLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzZWxlY3Rpb24sIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFszXSA9IHByb3BzLmNoaWxkcmVuLCAkWzRdID0gc2VsZWN0aW9uLCAkWzVdID0gdDIpIDogdDIgPSAkWzVdLCB0Mjtcbn1cbmNvbnN0IGRlZmF1bHRLZXlHZW5lcmF0b3IgPSAoKSA9PiByYW5kb21LZXkoMTIpLCBnZXRCeXRlSGV4VGFibGUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgbGV0IHRhYmxlO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmICh0YWJsZSlcbiAgICAgIHJldHVybiB0YWJsZTtcbiAgICB0YWJsZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpXG4gICAgICB0YWJsZVtpXSA9IChpICsgMjU2KS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9O1xufSkoKTtcbmZ1bmN0aW9uIHdoYXR3Z1JORyhsZW5ndGggPSAxNikge1xuICBjb25zdCBybmRzOCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpLCBybmRzODtcbn1cbmZ1bmN0aW9uIHJhbmRvbUtleShsZW5ndGgpIHtcbiAgY29uc3QgdGFibGUgPSBnZXRCeXRlSGV4VGFibGUoKTtcbiAgcmV0dXJuIHdoYXR3Z1JORyhsZW5ndGgpLnJlZHVjZSgoc3RyLCBuKSA9PiBzdHIgKyB0YWJsZVtuXSwgXCJcIikuc2xpY2UoMCwgbGVuZ3RoKTtcbn1cbmNvbnN0IGRlYnVnJGcgPSBkZWJ1Z1dpdGhOYW1lKFwib3BlcmF0aW9uVG9QYXRjaGVzXCIpO1xuZnVuY3Rpb24gY3JlYXRlT3BlcmF0aW9uVG9QYXRjaGVzKHR5cGVzKSB7XG4gIGNvbnN0IHRleHRCbG9ja05hbWUgPSB0eXBlcy5ibG9jay5uYW1lO1xuICBmdW5jdGlvbiBpbnNlcnRUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgZGVidWckZy5lbmFibGVkICYmIGRlYnVnJGcoXCJPcGVyYXRpb25cIiwgSlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLCBudWxsLCAyKSk7XG4gICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuaXNUZXh0QmxvY2soZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSkgJiYgZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAoIWJsb2NrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYmxvY2tcIik7XG4gICAgY29uc3QgdGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0pICYmIGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICBpZiAoIXRleHRDaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGNoaWxkXCIpO1xuICAgIGNvbnN0IHBhdGggPSBbe1xuICAgICAgX2tleTogYmxvY2suX2tleVxuICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleTogdGV4dENoaWxkLl9rZXlcbiAgICB9LCBcInRleHRcIl0sIHByZXZCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgcHJldkNoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKHByZXZCbG9jaykgJiYgcHJldkJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBlZGl0b3IuaXNUZXh0U3BhbihwcmV2Q2hpbGQpID8gcHJldkNoaWxkLnRleHQgOiBcIlwiLCBwYXRjaCA9IGRpZmZNYXRjaFBhdGNoJDEocHJldlRleHQsIHRleHRDaGlsZC50ZXh0LCBwYXRoKTtcbiAgICByZXR1cm4gcGF0Y2gudmFsdWUubGVuZ3RoID8gW3BhdGNoXSA6IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRleHRQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGVkaXRvciAmJiBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmICghYmxvY2spXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBibG9ja1wiKTtcbiAgICBjb25zdCBjaGlsZCA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dIHx8IHZvaWQgMCwgdGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpID8gY2hpbGQgOiB2b2lkIDA7XG4gICAgaWYgKGNoaWxkICYmICF0ZXh0Q2hpbGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzcGFuXCIpO1xuICAgIGlmICghdGV4dENoaWxkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgY2hpbGRcIik7XG4gICAgY29uc3QgcGF0aCA9IFt7XG4gICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICBfa2V5OiB0ZXh0Q2hpbGQuX2tleVxuICAgIH0sIFwidGV4dFwiXSwgYmVmb3JlQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHByZXZUZXh0Q2hpbGQgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmVmb3JlQmxvY2spICYmIGJlZm9yZUJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBlZGl0b3IuaXNUZXh0U3BhbihwcmV2VGV4dENoaWxkKSAmJiBwcmV2VGV4dENoaWxkLnRleHQsIHBhdGNoID0gZGlmZk1hdGNoUGF0Y2gkMShwcmV2VGV4dCB8fCBcIlwiLCB0ZXh0Q2hpbGQudGV4dCwgcGF0aCk7XG4gICAgcmV0dXJuIHBhdGNoLnZhbHVlID8gW3BhdGNoXSA6IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHNldE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmICh0eXBlb2YgYmxvY2suX2tleSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBibG9jayB0byBoYXZlIGEgX2tleVwiKTtcbiAgICAgIGNvbnN0IHNldE5vZGUgPSBvbWl0Qnkoe1xuICAgICAgICAuLi5lZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dLFxuICAgICAgICAuLi5vcGVyYXRpb24ubmV3UHJvcGVydGllc1xuICAgICAgfSwgaXNVbmRlZmluZWQpO1xuICAgICAgcmV0dXJuIFtzZXQoZnJvbVNsYXRlVmFsdWUoW3NldE5vZGVdLCB0ZXh0QmxvY2tOYW1lKVswXSwgW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV0pXTtcbiAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGNvbnN0IGJsb2NrS2V5ID0gYmxvY2suX2tleSwgY2hpbGRLZXkgPSBjaGlsZC5fa2V5LCBwYXRjaGVzID0gW10sIGtleXMgPSBPYmplY3Qua2V5cyhvcGVyYXRpb24ubmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgcmV0dXJuIGtleXMuZm9yRWFjaCgoa2V5TmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleU5hbWUgPT09IFwiX2tleVwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGdldChvcGVyYXRpb24ubmV3UHJvcGVydGllcywga2V5TmFtZSk7XG4gICAgICAgICAgICAgIHBhdGNoZXMucHVzaChzZXQodmFsLCBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrS2V5XG4gICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgYmxvY2suY2hpbGRyZW4uaW5kZXhPZihjaGlsZCksIGtleU5hbWVdKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBnZXQob3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMsIGtleU5hbWUpO1xuICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goc2V0KHZhbCwgW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9ja0tleVxuICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZEtleVxuICAgICAgICAgICAgICB9LCBrZXlOYW1lXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBwYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgY2hpbGRcIik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIHZhbGlkIGJsb2NrXCIpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHBhdGggZW5jb3VudGVyZWQ6ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLnBhdGgpfWApO1xuICB9XG4gIGZ1bmN0aW9uIGluc2VydE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgaXNUZXh0QmxvY2sgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spO1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gb3BlcmF0aW9uLnBhdGhbMF0gPT09IDAgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiLCBiZWZvcmVCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdIC0gMV0sIHRhcmdldEtleSA9IG9wZXJhdGlvbi5wYXRoWzBdID09PSAwID8gYmxvY2s/Ll9rZXkgOiBiZWZvcmVCbG9jaz8uX2tleTtcbiAgICAgIHJldHVybiB0YXJnZXRLZXkgPyBbaW5zZXJ0KFtmcm9tU2xhdGVWYWx1ZShbb3BlcmF0aW9uLm5vZGVdLCB0ZXh0QmxvY2tOYW1lKVswXV0sIHBvc2l0aW9uLCBbe1xuICAgICAgICBfa2V5OiB0YXJnZXRLZXlcbiAgICAgIH1dKV0gOiBbc2V0SWZNaXNzaW5nKGJlZm9yZVZhbHVlLCBbXSksIGluc2VydChbZnJvbVNsYXRlVmFsdWUoW29wZXJhdGlvbi5ub2RlXSwgdGV4dEJsb2NrTmFtZSlbMF1dLCBcImJlZm9yZVwiLCBbb3BlcmF0aW9uLnBhdGhbMF1dKV07XG4gICAgfSBlbHNlIGlmIChpc1RleHRCbG9jayAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIgJiYgZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgIWJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gPyBcImJlZm9yZVwiIDogXCJhZnRlclwiLCBub2RlID0ge1xuICAgICAgICAuLi5vcGVyYXRpb24ubm9kZVxuICAgICAgfTtcbiAgICAgICFub2RlLl90eXBlICYmIFRleHQuaXNUZXh0KG5vZGUpICYmIChub2RlLl90eXBlID0gXCJzcGFuXCIsIG5vZGUubWFya3MgPSBbXSk7XG4gICAgICBjb25zdCBjaGlsZCA9IGZyb21TbGF0ZVZhbHVlKFt7XG4gICAgICAgIF9rZXk6IFwiYm9ndXNcIixcbiAgICAgICAgX3R5cGU6IHRleHRCbG9ja05hbWUsXG4gICAgICAgIGNoaWxkcmVuOiBbbm9kZV1cbiAgICAgIH1dLCB0ZXh0QmxvY2tOYW1lKVswXS5jaGlsZHJlblswXTtcbiAgICAgIHJldHVybiBbaW5zZXJ0KFtjaGlsZF0sIHBvc2l0aW9uLCBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA8PSAxIHx8ICFibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdID8gMCA6IHtcbiAgICAgICAgX2tleTogYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXS5fa2V5XG4gICAgICB9XSldO1xuICAgIH1cbiAgICByZXR1cm4gZGVidWckZyhcIlNvbWV0aGluZyB3YXMgaW5zZXJ0ZWQgaW50byBhIHZvaWQgYmxvY2suIE5vdCBwcm9kdWNpbmcgZWRpdG9yIHBhdGNoZXMuXCIpLCBbXTtcbiAgfVxuICBmdW5jdGlvbiBzcGxpdE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBwYXRjaGVzID0gW10sIHNwbGl0QmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmICghZWRpdG9yLmlzVGV4dEJsb2NrKHNwbGl0QmxvY2spKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayB3aXRoIHBhdGggJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24ucGF0aFswXSl9IGlzIG5vdCBhIHRleHQgYmxvY2sgYW5kIGNhbid0IGJlIHNwbGl0YCk7XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3Qgb2xkQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV07XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG9sZEJsb2NrKSkge1xuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IGZyb21TbGF0ZVZhbHVlKFtlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF0gKyAxXV0sIHRleHRCbG9ja05hbWUpWzBdO1xuICAgICAgICB0YXJnZXRWYWx1ZSAmJiAocGF0Y2hlcy5wdXNoKGluc2VydChbdGFyZ2V0VmFsdWVdLCBcImFmdGVyXCIsIFt7XG4gICAgICAgICAgX2tleTogc3BsaXRCbG9jay5fa2V5XG4gICAgICAgIH1dKSksIG9sZEJsb2NrLmNoaWxkcmVuLnNsaWNlKG9wZXJhdGlvbi5wb3NpdGlvbikuZm9yRWFjaCgoc3BhbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhdGggPSBbe1xuICAgICAgICAgICAgX2tleTogb2xkQmxvY2suX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogc3Bhbi5fa2V5XG4gICAgICAgICAgfV07XG4gICAgICAgICAgcGF0Y2hlcy5wdXNoKHVuc2V0KHBhdGgpKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgfVxuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHNwbGl0U3BhbiA9IHNwbGl0QmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKHNwbGl0U3BhbikpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3BhbnMgPSBmcm9tU2xhdGVWYWx1ZShbe1xuICAgICAgICAgIC4uLnNwbGl0QmxvY2ssXG4gICAgICAgICAgY2hpbGRyZW46IHNwbGl0QmxvY2suY2hpbGRyZW4uc2xpY2Uob3BlcmF0aW9uLnBhdGhbMV0gKyAxLCBvcGVyYXRpb24ucGF0aFsxXSArIDIpXG4gICAgICAgIH1dLCB0ZXh0QmxvY2tOYW1lKVswXS5jaGlsZHJlbjtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKGluc2VydCh0YXJnZXRTcGFucywgXCJhZnRlclwiLCBbe1xuICAgICAgICAgIF9rZXk6IHNwbGl0QmxvY2suX2tleVxuICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBfa2V5OiBzcGxpdFNwYW4uX2tleVxuICAgICAgICB9XSkpLCBwYXRjaGVzLnB1c2goc2V0KHNwbGl0U3Bhbi50ZXh0LCBbe1xuICAgICAgICAgIF9rZXk6IHNwbGl0QmxvY2suX2tleVxuICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBfa2V5OiBzcGxpdFNwYW4uX2tleVxuICAgICAgICB9LCBcInRleHRcIl0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRjaGVzO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgY29uc3QgYmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV07XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLl9rZXkpXG4gICAgICAgIHJldHVybiBbdW5zZXQoW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dKV07XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayBub3QgZm91bmRcIik7XG4gICAgfSBlbHNlIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qgc3BhblRvUmVtb3ZlID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgcmV0dXJuIHNwYW5Ub1JlbW92ZSA/IGJsb2NrLmNoaWxkcmVuLmZpbHRlcigoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSBvcGVyYXRpb24ubm9kZS5fa2V5KS5sZW5ndGggPiAxID8gKGNvbnNvbGUud2FybihgTXVsdGlwbGUgc3BhbnMgaGF2ZSBcXGBfa2V5XFxgICR7b3BlcmF0aW9uLm5vZGUuX2tleX0uIEl0J3MgYW1iaWd1b3VzIHdoaWNoIG9uZSB0byByZW1vdmUuYCwgSlNPTi5zdHJpbmdpZnkoYmxvY2ssIG51bGwsIDIpKSwgW10pIDogW3Vuc2V0KFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBzcGFuVG9SZW1vdmUuX2tleVxuICAgICAgfV0pXSA6IChkZWJ1ZyRnKFwiU3BhbiBub3QgZm91bmQgaW4gZWRpdG9yIHRyeWluZyB0byByZW1vdmUgbm9kZVwiKSwgW10pO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIGRlYnVnJGcoXCJOb3QgY3JlYXRpbmcgcGF0Y2ggaW5zaWRlIG9iamVjdCBibG9ja1wiKSwgW107XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgY29uc3QgcGF0Y2hlcyA9IFtdLCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgdXBkYXRlZEJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKVxuICAgICAgaWYgKGJsb2NrPy5fa2V5KSB7XG4gICAgICAgIGNvbnN0IG5ld0Jsb2NrID0gZnJvbVNsYXRlVmFsdWUoW2VkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXSAtIDFdXSwgdGV4dEJsb2NrTmFtZSlbMF07XG4gICAgICAgIHBhdGNoZXMucHVzaChzZXQobmV3QmxvY2ssIFt7XG4gICAgICAgICAgX2tleTogbmV3QmxvY2suX2tleVxuICAgICAgICB9XSkpLCBwYXRjaGVzLnB1c2godW5zZXQoW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dKSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IGtleSBub3QgZm91bmQhXCIpO1xuICAgIGVsc2UgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKHVwZGF0ZWRCbG9jaykgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCB1cGRhdGVkU3BhbiA9IHVwZGF0ZWRCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdICYmIGVkaXRvci5pc1RleHRTcGFuKHVwZGF0ZWRCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdKSA/IHVwZGF0ZWRCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdIDogdm9pZCAwLCByZW1vdmVkU3BhbiA9IGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0pID8gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dIDogdm9pZCAwO1xuICAgICAgdXBkYXRlZFNwYW4gJiYgKGJsb2NrLmNoaWxkcmVuLmZpbHRlcigoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSB1cGRhdGVkU3Bhbi5fa2V5KS5sZW5ndGggPT09IDEgPyBwYXRjaGVzLnB1c2goc2V0KHVwZGF0ZWRTcGFuLnRleHQsIFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiB1cGRhdGVkU3Bhbi5fa2V5XG4gICAgICB9LCBcInRleHRcIl0pKSA6IGNvbnNvbGUud2FybihgTXVsdGlwbGUgc3BhbnMgaGF2ZSBcXGBfa2V5XFxgICR7dXBkYXRlZFNwYW4uX2tleX0uIEl0J3MgYW1iaWd1b3VzIHdoaWNoIG9uZSB0byB1cGRhdGUuYCwgSlNPTi5zdHJpbmdpZnkoYmxvY2ssIG51bGwsIDIpKSksIHJlbW92ZWRTcGFuICYmIChibG9jay5jaGlsZHJlbi5maWx0ZXIoKHNwYW4pID0+IHNwYW4uX2tleSA9PT0gcmVtb3ZlZFNwYW4uX2tleSkubGVuZ3RoID09PSAxID8gcGF0Y2hlcy5wdXNoKHVuc2V0KFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiByZW1vdmVkU3Bhbi5fa2V5XG4gICAgICB9XSkpIDogY29uc29sZS53YXJuKGBNdWx0aXBsZSBzcGFucyBoYXZlIFxcYF9rZXlcXGAgJHtyZW1vdmVkU3Bhbi5fa2V5fS4gSXQncyBhbWJpZ3VvdXMgd2hpY2ggb25lIHRvIHJlbW92ZS5gLCBKU09OLnN0cmluZ2lmeShibG9jaywgbnVsbCwgMikpKTtcbiAgICB9IGVsc2VcbiAgICAgIGRlYnVnJGcoXCJWb2lkIG5vZGVzIGNhbid0IGJlIG1lcmdlZCwgbm90IGNyZWF0aW5nIGFueSBwYXRjaGVzXCIpO1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmVOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgY29uc3QgcGF0Y2hlcyA9IFtdLCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgdGFyZ2V0QmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ubmV3UGF0aFswXV07XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBvcGVyYXRpb24ucGF0aFswXSA+IG9wZXJhdGlvbi5uZXdQYXRoWzBdID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIjtcbiAgICAgIHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9XSkpLCBwYXRjaGVzLnB1c2goaW5zZXJ0KFtmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0ZXh0QmxvY2tOYW1lKVswXV0sIHBvc2l0aW9uLCBbe1xuICAgICAgICBfa2V5OiB0YXJnZXRCbG9jay5fa2V5XG4gICAgICB9XSkpO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyICYmIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKHRhcmdldEJsb2NrKSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0sIHRhcmdldENoaWxkID0gdGFyZ2V0QmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLm5ld1BhdGhbMV1dLCBwb3NpdGlvbiA9IG9wZXJhdGlvbi5uZXdQYXRoWzFdID09PSB0YXJnZXRCbG9jay5jaGlsZHJlbi5sZW5ndGggPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiLCBjaGlsZFRvSW5zZXJ0ID0gZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdGV4dEJsb2NrTmFtZSlbMF0uY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgcGF0Y2hlcy5wdXNoKHVuc2V0KFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBjaGlsZC5fa2V5XG4gICAgICB9XSkpLCBwYXRjaGVzLnB1c2goaW5zZXJ0KFtjaGlsZFRvSW5zZXJ0XSwgcG9zaXRpb24sIFt7XG4gICAgICAgIF9rZXk6IHRhcmdldEJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiB0YXJnZXRDaGlsZC5fa2V5XG4gICAgICB9XSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICByZXR1cm4ge1xuICAgIGluc2VydE5vZGVQYXRjaCxcbiAgICBpbnNlcnRUZXh0UGF0Y2gsXG4gICAgbWVyZ2VOb2RlUGF0Y2gsXG4gICAgbW92ZU5vZGVQYXRjaCxcbiAgICByZW1vdmVOb2RlUGF0Y2gsXG4gICAgcmVtb3ZlVGV4dFBhdGNoLFxuICAgIHNldE5vZGVQYXRjaCxcbiAgICBzcGxpdE5vZGVQYXRjaFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlV2l0aEV2ZW50TGlzdGVuZXJzKGVkaXRvckFjdG9yLCBzdWJzY3JpcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0Lm1heEJsb2NrcyAhPT0gdm9pZCAwIHx8IChzdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gZWRpdG9yQWN0b3Iub24oXCIqXCIsIChldmVudCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi5hZGRcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5hZGRcIixcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uOiBldmVudC5hbm5vdGF0aW9uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImFubm90YXRpb24ucmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFubm90YXRpb24ucmVtb3ZlXCIsXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbjogZXZlbnQuYW5ub3RhdGlvblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLnRvZ2dsZVwiOiB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhbm5vdGF0aW9uLnRvZ2dsZVwiLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb246IGV2ZW50LmFubm90YXRpb25cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZm9jdXNcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZm9jdXNcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9KSwgZWRpdG9yLmFkZE1hcmsgPSAobWFyaykgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLmFkZFwiLFxuICAgICAgICAgIGRlY29yYXRvcjogbWFya1xuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5yZW1vdmVNYXJrID0gKG1hcmspID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci5yZW1vdmVcIixcbiAgICAgICAgICBkZWNvcmF0b3I6IG1hcmtcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IuZGVsZXRlQmFja3dhcmQgPSAodW5pdCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZGVsZXRlIGJhY2t3YXJkXCIsXG4gICAgICAgICAgdW5pdFxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5kZWxldGVGb3J3YXJkID0gKHVuaXQpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlbGV0ZSBmb3J3YXJkXCIsXG4gICAgICAgICAgdW5pdFxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5pbnNlcnRCcmVhayA9ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImluc2VydCBicmVha1wiXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmluc2VydFNvZnRCcmVhayA9ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImluc2VydCBzb2Z0IGJyZWFrXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0VGV4dCA9ICh0ZXh0LCBvcHRpb25zKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJpbnNlcnQgdGV4dFwiLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0pLCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVXaXRoTWF4QmxvY2tzKGVkaXRvckFjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLmFwcGx5ID0gKG9wZXJhdGlvbikgPT4ge1xuICAgICAgaWYgKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5yZWFkT25seSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRvaW5nKGVkaXRvcikgfHwgaXNSZWRvaW5nKGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvd3MgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQubWF4QmxvY2tzID8/IC0xO1xuICAgICAgcm93cyA+IDAgJiYgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+PSByb3dzICYmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiIHx8IG9wZXJhdGlvbi50eXBlID09PSBcInNwbGl0X25vZGVcIikgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxIHx8IGFwcGx5MihvcGVyYXRpb24pO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhPYmplY3RLZXlzKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcykge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MixcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAoaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBcInNwbGl0X25vZGVcIikge1xuICAgICAgICBhcHBseTIoe1xuICAgICAgICAgIC4uLm9wZXJhdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAuLi5vcGVyYXRpb24ucHJvcGVydGllcyxcbiAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiICYmICFFZGl0b3IuaXNFZGl0b3Iob3BlcmF0aW9uLm5vZGUpKSB7XG4gICAgICAgIGFwcGx5Mih7XG4gICAgICAgICAgLi4ub3BlcmF0aW9uLFxuICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgIC4uLm9wZXJhdGlvbi5ub2RlLFxuICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgfSwgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSkge1xuICAgICAgICBpZiAoIW5vZGUuX2tleSkge1xuICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKClcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICBpZiAoIWNoaWxkLl9rZXkpIHtcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKClcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckZiA9IGRlYnVnV2l0aE5hbWUoXCJhcHBseVBhdGNoZXNcIiksIGRlYnVnVmVyYm9zZSQxID0gZGVidWckZi5lbmFibGVkICYmICEwO1xuZnVuY3Rpb24gY3JlYXRlQXBwbHlQYXRjaChzY2hlbWFUeXBlcykge1xuICByZXR1cm4gKGVkaXRvciwgcGF0Y2gpID0+IHtcbiAgICBsZXQgY2hhbmdlZCA9ICExO1xuICAgIGRlYnVnVmVyYm9zZSQxICYmIChkZWJ1ZyRmKGBcblxuTkVXIFBBVENIID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1gKSwgZGVidWckZihKU09OLnN0cmluZ2lmeShwYXRjaCwgbnVsbCwgMikpKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChwYXRjaC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gaW5zZXJ0UGF0Y2goZWRpdG9yLCBwYXRjaCwgc2NoZW1hVHlwZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidW5zZXRcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gdW5zZXRQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIGNoYW5nZWQgPSBzZXRQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpZmZNYXRjaFBhdGNoXCI6XG4gICAgICAgICAgY2hhbmdlZCA9IGRpZmZNYXRjaFBhdGNoKGVkaXRvciwgcGF0Y2gpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlYnVnJGYoXCJVbmhhbmRsZWQgcGF0Y2hcIiwgcGF0Y2gudHlwZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9O1xufVxuZnVuY3Rpb24gZGlmZk1hdGNoUGF0Y2goZWRpdG9yLCBwYXRjaCkge1xuICBjb25zdCB7XG4gICAgYmxvY2ssXG4gICAgY2hpbGQsXG4gICAgY2hpbGRQYXRoXG4gIH0gPSBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0Y2gucGF0aCk7XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIGRlYnVnJGYoXCJCbG9jayBub3QgZm91bmRcIiksICExO1xuICBpZiAoIWNoaWxkIHx8ICFjaGlsZFBhdGgpXG4gICAgcmV0dXJuIGRlYnVnJGYoXCJDaGlsZCBub3QgZm91bmRcIiksICExO1xuICBpZiAoIShibG9jayAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSA0ICYmIHBhdGNoLnBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIiAmJiBwYXRjaC5wYXRoWzNdID09PSBcInRleHRcIikgfHwgIVRleHQuaXNUZXh0KGNoaWxkKSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHBhdGNoZXMgPSBwYXJzZShwYXRjaC52YWx1ZSksIFtuZXdWYWx1ZV0gPSBhcHBseShwYXRjaGVzLCBjaGlsZC50ZXh0LCB7XG4gICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiAhMFxuICB9KSwgZGlmZiQxID0gY2xlYW51cEVmZmljaWVuY3koZGlmZihjaGlsZC50ZXh0LCBuZXdWYWx1ZSksIDUpO1xuICBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIik7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IFtvcCwgdGV4dF0gb2YgZGlmZiQxKVxuICAgIG9wID09PSBESUZGX0lOU0VSVCA/IChlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogXCJpbnNlcnRfdGV4dFwiLFxuICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGV4dFxuICAgIH0pLCBvZmZzZXQgKz0gdGV4dC5sZW5ndGgpIDogb3AgPT09IERJRkZfREVMRVRFID8gZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6IFwicmVtb3ZlX3RleHRcIixcbiAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgIG9mZnNldCxcbiAgICAgIHRleHRcbiAgICB9KSA6IG9wID09PSBESUZGX0VRVUFMICYmIChvZmZzZXQgKz0gdGV4dC5sZW5ndGgpO1xuICByZXR1cm4gZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xufVxuZnVuY3Rpb24gaW5zZXJ0UGF0Y2goZWRpdG9yLCBwYXRjaCwgc2NoZW1hVHlwZXMpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrOiB0YXJnZXRCbG9jayxcbiAgICBjaGlsZDogdGFyZ2V0Q2hpbGQsXG4gICAgYmxvY2tQYXRoOiB0YXJnZXRCbG9ja1BhdGgsXG4gICAgY2hpbGRQYXRoOiB0YXJnZXRDaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKCF0YXJnZXRCbG9jayB8fCAhdGFyZ2V0QmxvY2tQYXRoKVxuICAgIHJldHVybiBkZWJ1ZyRmKFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID4gMSAmJiBwYXRjaC5wYXRoWzFdICE9PSBcImNoaWxkcmVuXCIpXG4gICAgcmV0dXJuIGRlYnVnJGYoXCJJZ25vcmluZyBwYXRjaCB0YXJnZXRpbmcgdm9pZCB2YWx1ZVwiKSwgITE7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW1zOiBpdGVtczIsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24yXG4gICAgfSA9IHBhdGNoLCBibG9ja3NUb0luc2VydCA9IHRvU2xhdGVWYWx1ZShpdGVtczIsIHtcbiAgICAgIHNjaGVtYVR5cGVzXG4gICAgfSwgS0VZX1RPX1NMQVRFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCB0YXJnZXRCbG9ja0luZGV4ID0gdGFyZ2V0QmxvY2tQYXRoWzBdLCBub3JtYWxpemVkSWR4MiA9IHBvc2l0aW9uMiA9PT0gXCJhZnRlclwiID8gdGFyZ2V0QmxvY2tJbmRleCArIDEgOiB0YXJnZXRCbG9ja0luZGV4O1xuICAgIHJldHVybiBkZWJ1ZyRmKGBJbnNlcnRpbmcgYmxvY2tzIGF0IHBhdGggWyR7bm9ybWFsaXplZElkeDJ9XWApLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBibG9ja3NUb0luc2VydCwge1xuICAgICAgYXQ6IFtub3JtYWxpemVkSWR4Ml1cbiAgICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpdGVtcyxcbiAgICBwb3NpdGlvblxuICB9ID0gcGF0Y2g7XG4gIGlmICghdGFyZ2V0Q2hpbGQgfHwgIXRhcmdldENoaWxkUGF0aClcbiAgICByZXR1cm4gZGVidWckZihcIkNoaWxkIG5vdCBmb3VuZFwiKSwgITE7XG4gIGNvbnN0IGNoaWxkcmVuVG9JbnNlcnQgPSB0YXJnZXRCbG9jayAmJiB0b1NsYXRlVmFsdWUoW3tcbiAgICAuLi50YXJnZXRCbG9jayxcbiAgICBjaGlsZHJlbjogaXRlbXNcbiAgfV0sIHtcbiAgICBzY2hlbWFUeXBlc1xuICB9LCBLRVlfVE9fU0xBVEVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIHRhcmdldENoaWxkSW5kZXggPSB0YXJnZXRDaGlsZFBhdGhbMV0sIG5vcm1hbGl6ZWRJZHggPSBwb3NpdGlvbiA9PT0gXCJhZnRlclwiID8gdGFyZ2V0Q2hpbGRJbmRleCArIDEgOiB0YXJnZXRDaGlsZEluZGV4LCBjaGlsZEluc2VydFBhdGggPSBbdGFyZ2V0Q2hpbGRQYXRoWzBdLCBub3JtYWxpemVkSWR4XTtcbiAgcmV0dXJuIGRlYnVnJGYoYEluc2VydGluZyBjaGlsZHJlbiBhdCBwYXRoICR7Y2hpbGRJbnNlcnRQYXRofWApLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIGNoaWxkcmVuVG9JbnNlcnQgJiYgRWxlbWVudCQxLmlzRWxlbWVudChjaGlsZHJlblRvSW5zZXJ0WzBdKSAmJiBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGRyZW5Ub0luc2VydFswXS5jaGlsZHJlbiwge1xuICAgIGF0OiBjaGlsZEluc2VydFBhdGhcbiAgfSksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbn1cbmZ1bmN0aW9uIHNldFBhdGNoKGVkaXRvciwgcGF0Y2gpIHtcbiAgbGV0IHZhbHVlID0gcGF0Y2gudmFsdWU7XG4gIHR5cGVvZiBwYXRjaC5wYXRoWzNdID09IFwic3RyaW5nXCIgJiYgKHZhbHVlID0ge30sIHZhbHVlW3BhdGNoLnBhdGhbM11dID0gcGF0Y2gudmFsdWUpO1xuICBjb25zdCB7XG4gICAgYmxvY2ssXG4gICAgYmxvY2tQYXRoLFxuICAgIGNoaWxkLFxuICAgIGNoaWxkUGF0aFxuICB9ID0gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGNoLnBhdGgpO1xuICBpZiAoIWJsb2NrKVxuICAgIHJldHVybiBkZWJ1ZyRmKFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgY29uc3QgaXNUZXh0QmxvY2sgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spO1xuICBpZiAoaXNUZXh0QmxvY2sgJiYgcGF0Y2gucGF0aC5sZW5ndGggPiAxICYmIHBhdGNoLnBhdGhbMV0gIT09IFwiY2hpbGRyZW5cIilcbiAgICByZXR1cm4gZGVidWckZihcIklnbm9yaW5nIHNldHRpbmcgdm9pZCB2YWx1ZVwiKSwgITE7XG4gIGlmIChkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIGlzVGV4dEJsb2NrICYmIGNoaWxkICYmIGNoaWxkUGF0aCkge1xuICAgIGlmIChUZXh0LmlzVGV4dCh2YWx1ZSkgJiYgVGV4dC5pc1RleHQoY2hpbGQpKSB7XG4gICAgICBjb25zdCBuZXdUZXh0ID0gY2hpbGQudGV4dDtcbiAgICAgIHZhbHVlLnRleHQgIT09IG5ld1RleHQgJiYgKGRlYnVnJGYoXCJTZXR0aW5nIHRleHQgcHJvcGVydHlcIiksIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwicmVtb3ZlX3RleHRcIixcbiAgICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIHRleHQ6IG5ld1RleHRcbiAgICAgIH0pLCBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcImluc2VydF90ZXh0XCIsXG4gICAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICB0ZXh0OiB2YWx1ZS50ZXh0XG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgIH0gZWxzZVxuICAgICAgZGVidWckZihcIlNldHRpbmcgbm9uLXRleHQgcHJvcGVydHlcIiksIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwic2V0X25vZGVcIixcbiAgICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgbmV3UHJvcGVydGllczogdmFsdWVcbiAgICAgIH0pO1xuICAgIHJldHVybiAhMDtcbiAgfSBlbHNlIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSAmJiBibG9ja1BhdGgpIHtcbiAgICBkZWJ1ZyRmKFwiU2V0dGluZyBibG9jayBwcm9wZXJ0eVwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLm5leHRSZXN0XG4gICAgfSA9IHZhbHVlLCB7XG4gICAgICBjaGlsZHJlbjogcHJldkNoaWxkcmVuLFxuICAgICAgLi4ucHJldlJlc3RcbiAgICB9ID0gYmxvY2sgfHwge1xuICAgICAgY2hpbGRyZW46IHZvaWQgMFxuICAgIH07XG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6IFwic2V0X25vZGVcIixcbiAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLi4ucHJldlJlc3RcbiAgICAgIH0sXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBuZXh0UmVzdFxuICAgIH0pLCBkZWJ1ZyRmKFwiU2V0dGluZyBjaGlsZHJlblwiKSwgYmxvY2suY2hpbGRyZW4uZm9yRWFjaCgoYzIsIGNJbmRleCkgPT4ge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmVfbm9kZVwiLFxuICAgICAgICBwYXRoOiBibG9ja1BhdGguY29uY2F0KGJsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDEgLSBjSW5kZXgpLFxuICAgICAgICBub2RlOiBjMlxuICAgICAgfSk7XG4gICAgfSksIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmZvckVhY2goKGMyLCBjSW5kZXgpID0+IHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwiaW5zZXJ0X25vZGVcIixcbiAgICAgICAgcGF0aDogYmxvY2tQYXRoLmNvbmNhdChjSW5kZXgpLFxuICAgICAgICBub2RlOiBjMlxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoYmxvY2sgJiYgXCJ2YWx1ZVwiIGluIGJsb2NrKSB7XG4gICAgY29uc3QgbmV3VmFsID0gYXBwbHlBbGwoW2Jsb2NrLnZhbHVlXSwgW3BhdGNoXSlbMF07XG4gICAgcmV0dXJuIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAuLi5ibG9jayxcbiAgICAgIHZhbHVlOiBuZXdWYWxcbiAgICB9LCB7XG4gICAgICBhdDogYmxvY2tQYXRoXG4gICAgfSksICEwO1xuICB9XG4gIHJldHVybiBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG59XG5mdW5jdGlvbiB1bnNldFBhdGNoKGVkaXRvciwgcGF0Y2gpIHtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgZGVidWckZihcIlJlbW92aW5nIGV2ZXJ5dGhpbmdcIiksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKTtcbiAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgcmV0dXJuIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKSwgZWRpdG9yLmNoaWxkcmVuLmZvckVhY2goKF9jaGlsZCwgaSkgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IFtpXVxuICAgICAgfSk7XG4gICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgfSkpLCBwcmV2aW91c1NlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfSksIGVkaXRvci5vbkNoYW5nZSgpLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG4gIH1cbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZCxcbiAgICBjaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKCFibG9jayB8fCAhYmxvY2tQYXRoKVxuICAgICAgcmV0dXJuIGRlYnVnJGYoXCJCbG9jayBub3QgZm91bmRcIiksICExO1xuICAgIGNvbnN0IGJsb2NrSW5kZXggPSBibG9ja1BhdGhbMF07XG4gICAgcmV0dXJuIGRlYnVnJGYoYFJlbW92aW5nIGJsb2NrIGF0IHBhdGggWyR7YmxvY2tJbmRleH1dYCksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBbYmxvY2tJbmRleF1cbiAgICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xuICB9XG4gIHJldHVybiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIHBhdGNoLnBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMyA/ICFjaGlsZCB8fCAhY2hpbGRQYXRoID8gKGRlYnVnJGYoXCJDaGlsZCBub3QgZm91bmRcIiksICExKSA6IChkZWJ1ZyRmKGBVbnNldHRpbmcgY2hpbGQgYXQgcGF0aCAke0pTT04uc3RyaW5naWZ5KGNoaWxkUGF0aCl9YCksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKSwgZGVidWdWZXJib3NlJDEgJiYgZGVidWckZihgUmVtb3ZpbmcgY2hpbGQgYXQgcGF0aCAke0pTT04uc3RyaW5naWZ5KGNoaWxkUGF0aCl9YCksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IGNoaWxkUGF0aFxuICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwKSA6ICExO1xufVxuZnVuY3Rpb24gaXNLZXllZFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJvYmplY3RcIiAmJiBcIl9rZXlcIiBpbiBzZWdtZW50O1xufVxuZnVuY3Rpb24gZGVidWdTdGF0ZShlZGl0b3IsIHN0YXRlTmFtZSkge1xuICBkZWJ1Z1ZlcmJvc2UkMSAmJiAoZGVidWckZihgQ2hpbGRyZW4gJHtzdGF0ZU5hbWV9OmAsIEpTT04uc3RyaW5naWZ5KGVkaXRvci5jaGlsZHJlbiwgbnVsbCwgMikpLCBkZWJ1ZyRmKGBTZWxlY3Rpb24gJHtzdGF0ZU5hbWV9OiBgLCBKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uLCBudWxsLCAyKSkpO1xufVxuZnVuY3Rpb24gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKSB7XG4gIGxldCBibG9ja0luZGV4ID0gLTE7XG4gIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaCA9IGlzS2V5ZWRTZWdtZW50KHBhdGhbMF0pID8gbm9kZS5fa2V5ID09PSBwYXRoWzBdLl9rZXkgOiBpbmRleCA9PT0gcGF0aFswXTtcbiAgICByZXR1cm4gaXNNYXRjaCAmJiAoYmxvY2tJbmRleCA9IGluZGV4KSwgaXNNYXRjaDtcbiAgfSk7XG4gIHJldHVybiBibG9jayA/IHtcbiAgICBibG9jayxcbiAgICBwYXRoOiBbYmxvY2tJbmRleF1cbiAgfSA6IHt9O1xufVxuZnVuY3Rpb24gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIHBhdGg6IGJsb2NrUGF0aFxuICB9ID0gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKCEoRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykgJiYgcGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiKSlcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2ssXG4gICAgICBibG9ja1BhdGgsXG4gICAgICBjaGlsZDogdm9pZCAwLFxuICAgICAgY2hpbGRQYXRoOiB2b2lkIDBcbiAgICB9O1xuICBsZXQgY2hpbGRJbmRleCA9IC0xO1xuICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaCA9IGlzS2V5ZWRTZWdtZW50KHBhdGhbMl0pID8gbm9kZS5fa2V5ID09PSBwYXRoWzJdLl9rZXkgOiBpbmRleCA9PT0gcGF0aFsyXTtcbiAgICByZXR1cm4gaXNNYXRjaCAmJiAoY2hpbGRJbmRleCA9IGluZGV4KSwgaXNNYXRjaDtcbiAgfSk7XG4gIHJldHVybiBjaGlsZCA/IHtcbiAgICBibG9jayxcbiAgICBjaGlsZCxcbiAgICBibG9ja1BhdGgsXG4gICAgY2hpbGRQYXRoOiBibG9ja1BhdGg/LmNvbmNhdChjaGlsZEluZGV4KVxuICB9IDoge1xuICAgIGJsb2NrLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZDogdm9pZCAwLFxuICAgIGNoaWxkUGF0aDogdm9pZCAwXG4gIH07XG59XG5jb25zdCBkZWJ1ZyRlID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUGF0Y2hlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQYXRjaGVzKHtcbiAgZWRpdG9yQWN0b3IsXG4gIHBhdGNoRnVuY3Rpb25zLFxuICBzY2hlbWFUeXBlcyxcbiAgc3Vic2NyaXB0aW9uc1xufSkge1xuICBsZXQgcHJldmlvdXNDaGlsZHJlbjtcbiAgY29uc3QgYXBwbHlQYXRjaCA9IGNyZWF0ZUFwcGx5UGF0Y2goc2NoZW1hVHlwZXMpO1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5zZXQoZWRpdG9yLCAhMSksIFBBVENISU5HLnNldChlZGl0b3IsICEwKSwgcHJldmlvdXNDaGlsZHJlbiA9IFsuLi5lZGl0b3IuY2hpbGRyZW5dO1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIGxldCBidWZmZXJlZFBhdGNoZXMgPSBbXTtcbiAgICBjb25zdCBoYW5kbGVCdWZmZXJlZFJlbW90ZVBhdGNoZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoYnVmZmVyZWRQYXRjaGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcGF0Y2hlcyA9IGJ1ZmZlcmVkUGF0Y2hlcztcbiAgICAgIGJ1ZmZlcmVkUGF0Y2hlcyA9IFtdO1xuICAgICAgbGV0IGNoYW5nZWQgPSAhMTtcbiAgICAgIHdpdGhSZW1vdGVDaGFuZ2VzKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHdpdGhvdXRQYXRjaGluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyRlLmVuYWJsZWQgJiYgZGVidWckZShgSGFuZGxpbmcgcmVtb3RlIHBhdGNoICR7SlNPTi5zdHJpbmdpZnkocGF0Y2gpfWApLCBjaGFuZ2VkID0gYXBwbHlQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGNoYW5nZWQgJiYgKGVkaXRvci5ub3JtYWxpemUoKSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgfSk7XG4gICAgfSwgaGFuZGxlUGF0Y2hlcyA9ICh7XG4gICAgICBwYXRjaGVzXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgcmVtb3RlUGF0Y2hlcyA9IHBhdGNoZXMuZmlsdGVyKChwKSA9PiBwLm9yaWdpbiAhPT0gXCJsb2NhbFwiKTtcbiAgICAgIHJlbW90ZVBhdGNoZXMubGVuZ3RoICE9PSAwICYmIChidWZmZXJlZFBhdGNoZXMgPSBidWZmZXJlZFBhdGNoZXMuY29uY2F0KHJlbW90ZVBhdGNoZXMpLCBoYW5kbGVCdWZmZXJlZFJlbW90ZVBhdGNoZXMoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGRlYnVnJGUoXCJTdWJzY3JpYmluZyB0byByZW1vdGUgcGF0Y2hlc1wiKTtcbiAgICAgIGNvbnN0IHN1YiA9IGVkaXRvckFjdG9yLm9uKFwicGF0Y2hlc1wiLCBoYW5kbGVQYXRjaGVzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlYnVnJGUoXCJVbnN1YnNjcmliaW5nIHRvIHJlbW90ZSBwYXRjaGVzXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSksIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBhcHBseTIob3BlcmF0aW9uKSwgZWRpdG9yO1xuICAgICAgbGV0IHBhdGNoZXMgPSBbXTtcbiAgICAgIHByZXZpb3VzQ2hpbGRyZW4gPSBlZGl0b3IuY2hpbGRyZW47XG4gICAgICBjb25zdCBlZGl0b3JXYXNFbXB0eSA9IGlzRXF1YWxUb0VtcHR5RWRpdG9yKHByZXZpb3VzQ2hpbGRyZW4sIHNjaGVtYVR5cGVzKTtcbiAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgY29uc3QgZWRpdG9ySXNFbXB0eSA9IGlzRXF1YWxUb0VtcHR5RWRpdG9yKGVkaXRvci5jaGlsZHJlbiwgc2NoZW1hVHlwZXMpO1xuICAgICAgaWYgKCFpc1BhdGNoaW5nKGVkaXRvcikpXG4gICAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgICBzd2l0Y2ggKGVkaXRvcldhc0VtcHR5ICYmICFlZGl0b3JJc0VtcHR5ICYmIG9wZXJhdGlvbi50eXBlICE9PSBcInNldF9zZWxlY3Rpb25cIiAmJiBwYXRjaGVzLnB1c2goaW5zZXJ0KHByZXZpb3VzQ2hpbGRyZW4sIFwiYmVmb3JlXCIsIFswXSkpLCBvcGVyYXRpb24udHlwZSkge1xuICAgICAgICBjYXNlIFwiaW5zZXJ0X3RleHRcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLmluc2VydFRleHRQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVtb3ZlX3RleHRcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLnJlbW92ZVRleHRQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVtb3ZlX25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLnJlbW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3BsaXRfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMuc3BsaXROb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImluc2VydF9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5pbnNlcnROb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldF9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5zZXROb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lcmdlX25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLm1lcmdlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtb3ZlX25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLm1vdmVOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiAhZWRpdG9yV2FzRW1wdHkgJiYgZWRpdG9ySXNFbXB0eSAmJiBbXCJtZXJnZV9ub2RlXCIsIFwic2V0X25vZGVcIiwgXCJyZW1vdmVfdGV4dFwiLCBcInJlbW92ZV9ub2RlXCJdLmluY2x1ZGVzKG9wZXJhdGlvbi50eXBlKSAmJiAocGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCB1bnNldChbXSldLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJ1bnNldFwiLFxuICAgICAgICBwcmV2aW91c1ZhbHVlOiBmcm9tU2xhdGVWYWx1ZShwcmV2aW91c0NoaWxkcmVuLCBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlcbiAgICAgIH0pKSwgZWRpdG9yV2FzRW1wdHkgJiYgcGF0Y2hlcy5sZW5ndGggPiAwICYmIChwYXRjaGVzID0gW3NldElmTWlzc2luZyhbXSwgW10pLCAuLi5wYXRjaGVzXSksIHBhdGNoZXMubGVuZ3RoID4gMCAmJiBwYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwicGF0Y2hcIixcbiAgICAgICAgICBwYXRjaDoge1xuICAgICAgICAgICAgLi4ucGF0Y2gsXG4gICAgICAgICAgICBvcmlnaW46IFwibG9jYWxcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSwgZWRpdG9yO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJGQgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQbGFjZWhvbGRlckJsb2NrXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBsYWNlaG9sZGVyQmxvY2soZWRpdG9yQWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQucmVhZE9ubHkpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJyZW1vdmVfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBvcC5ub2RlO1xuICAgICAgICBpZiAob3AucGF0aFswXSA9PT0gMCAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IFBhdGgubmV4dChvcC5wYXRoKTtcbiAgICAgICAgICBlZGl0b3IuY2hpbGRyZW5bbmV4dFBhdGhbMF1dIHx8IChkZWJ1ZyRkKFwiQWRkaW5nIHBsYWNlaG9sZGVyIGJsb2NrXCIpLCBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJGMgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGUoZWRpdG9yQWN0b3IsIHR5cGVzKSB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHR5cGVzLnN0eWxlc1swXS52YWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChub2RlRW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFssIHBhdGhdID0gbm9kZUVudHJ5O1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBlZGl0b3Iub3BlcmF0aW9ucylcbiAgICAgICAgaWYgKG9wLnR5cGUgPT09IFwic3BsaXRfbm9kZVwiICYmIG9wLnBhdGgubGVuZ3RoID09PSAxICYmIGVkaXRvci5pc1RleHRCbG9jayhvcC5wcm9wZXJ0aWVzKSAmJiBvcC5wcm9wZXJ0aWVzLnN0eWxlICE9PSBkZWZhdWx0U3R5bGUgJiYgb3AucGF0aFswXSA9PT0gcGF0aFswXSAmJiAhUGF0aC5lcXVhbHMocGF0aCwgb3AucGF0aCkpIHtcbiAgICAgICAgICBjb25zdCBbY2hpbGRdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXSArIDEsIDBdKTtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQoY2hpbGQpICYmIGNoaWxkLnRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGRlYnVnJGMoYE5vcm1hbGl6aW5nIHNwbGl0IG5vZGUgdG8gJHtkZWZhdWx0U3R5bGV9IHN0eWxlYCwgb3ApLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogW29wLnBhdGhbMF0gKyAxXSxcbiAgICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUobm9kZUVudHJ5KTtcbiAgICB9LCBlZGl0b3IucHRlSGFzQmxvY2tTdHlsZSA9IChzdHlsZSkgPT4gZWRpdG9yLnNlbGVjdGlvbiA/IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmIG5vZGUuc3R5bGUgPT09IHN0eWxlXG4gICAgfSldLmxlbmd0aCA+IDAgOiAhMSwgZWRpdG9yLnB0ZVRvZ2dsZUJsb2NrU3R5bGUgPSAoYmxvY2tTdHlsZSkgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiAmJiAoWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gICAgICB9KV0uZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgIGVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiBub2RlLnN0eWxlID09PSBibG9ja1N0eWxlID8gKGRlYnVnJGMoYFVuc2V0dGluZyBibG9jayBzdHlsZSAnJHtibG9ja1N0eWxlfSdgKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pKSA6IChibG9ja1N0eWxlID8gZGVidWckYyhgU2V0dGluZyBzdHlsZSAnJHtibG9ja1N0eWxlfSdgKSA6IGRlYnVnJGMoXCJTZXR0aW5nIGRlZmF1bHQgc3R5bGVcIiwgZGVmYXVsdFN0eWxlKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgIHN0eWxlOiBibG9ja1N0eWxlIHx8IGRlZmF1bHRTdHlsZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSkpO1xuICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyRiID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUG9ydGFibGVUZXh0TGlzdHNcIiksIE1BWF9MSVNUX0xFVkVMID0gMTA7XG5mdW5jdGlvbiBjcmVhdGVXaXRoUG9ydGFibGVUZXh0TGlzdHModHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucHRlVG9nZ2xlTGlzdEl0ZW0gPSAobGlzdEl0ZW1TdHlsZSkgPT4ge1xuICAgICAgZWRpdG9yLnB0ZUhhc0xpc3RTdHlsZShsaXN0SXRlbVN0eWxlKSA/IChkZWJ1ZyRiKGBSZW1vdmUgbGlzdCBpdGVtICcke2xpc3RJdGVtU3R5bGV9J2ApLCBlZGl0b3IucHRlVW5zZXRMaXN0SXRlbShsaXN0SXRlbVN0eWxlKSkgOiAoZGVidWckYihgQWRkIGxpc3QgaXRlbSAnJHtsaXN0SXRlbVN0eWxlfSdgKSwgZWRpdG9yLnB0ZVNldExpc3RJdGVtKGxpc3RJdGVtU3R5bGUpKTtcbiAgICB9LCBlZGl0b3IucHRlVW5zZXRMaXN0SXRlbSA9IChsaXN0SXRlbVN0eWxlKSA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uICYmIFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogKG5vZGUpID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZVxuICAgICAgfSldLmZvckVhY2goKFtub2RlLCBwYXRoXSkgPT4ge1xuICAgICAgICBpZiAoZWRpdG9yLmlzTGlzdEJsb2NrKG5vZGUpKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGlzdEl0ZW0sXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgICB9ID0gbm9kZSwgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBsaXN0SXRlbTogdm9pZCAwLFxuICAgICAgICAgICAgbGV2ZWw6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgZGVidWckYihgVW5zZXR0aW5nIGxpc3QgJyR7bGlzdEl0ZW1TdHlsZX0nYCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBuZXdOb2RlLCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IucHRlU2V0TGlzdEl0ZW0gPSAobGlzdEl0ZW1TdHlsZSkgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiAmJiBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgICAgIH0pXS5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgZGVidWckYihgU2V0dGluZyBsaXN0ICcke2xpc3RJdGVtU3R5bGV9J2ApLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgICAgbGlzdEl0ZW06IGxpc3RJdGVtU3R5bGUgfHwgdHlwZXMubGlzdHNbMF0gJiYgdHlwZXMubGlzdHNbMF0udmFsdWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLnB0ZUVuZExpc3QgPSAoKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBlZGl0b3IuaXNMaXN0QmxvY2sobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQobm9kZS5jaGlsZHJlblswXSkgJiYgbm9kZS5jaGlsZHJlblswXS50ZXh0ID09PSBcIlwiXG4gICAgICB9KV07XG4gICAgICByZXR1cm4gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID09PSAwID8gITEgOiAoc2VsZWN0ZWRCbG9ja3MuZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgIEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgKGRlYnVnJGIoXCJVbnNldCBsaXN0XCIpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgbGV2ZWw6IHZvaWQgMCxcbiAgICAgICAgICBsaXN0SXRlbTogdm9pZCAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSk7XG4gICAgICB9KSwgITApO1xuICAgIH0sIGVkaXRvci5wdGVJbmNyZW1lbnRCbG9ja0xldmVscyA9IChyZXZlcnNlKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gISFlZGl0b3IuaXNMaXN0QmxvY2sobm9kZSlcbiAgICAgIH0pXTtcbiAgICAgIHJldHVybiBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPT09IDAgPyAhMSA6IChzZWxlY3RlZEJsb2Nrcy5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgaWYgKGVkaXRvci5pc0xpc3RCbG9jayhub2RlKSkge1xuICAgICAgICAgIGxldCBsZXZlbCA9IG5vZGUubGV2ZWwgfHwgMTtcbiAgICAgICAgICByZXZlcnNlID8gKGxldmVsLS0sIGRlYnVnJGIoXCJEZWNyZW1lbnRpbmcgbGlzdCBsZXZlbFwiLCBNYXRoLm1pbihNQVhfTElTVF9MRVZFTCwgTWF0aC5tYXgoMSwgbGV2ZWwpKSkpIDogKGxldmVsKyssIGRlYnVnJGIoXCJJbmNyZW1lbnRpbmcgbGlzdCBsZXZlbFwiLCBNYXRoLm1pbihNQVhfTElTVF9MRVZFTCwgTWF0aC5tYXgoMSwgbGV2ZWwpKSkpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbGV2ZWw6IE1hdGgubWluKE1BWF9MSVNUX0xFVkVMLCBNYXRoLm1heCgxLCBsZXZlbCkpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksICEwKTtcbiAgICB9LCBlZGl0b3IucHRlSGFzTGlzdFN0eWxlID0gKGxpc3RTdHlsZSkgPT4ge1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICAgICAgfSldO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA+IDAgPyBzZWxlY3RlZEJsb2Nrcy5ldmVyeSgoW25vZGVdKSA9PiBlZGl0b3IuaXNMaXN0QmxvY2sobm9kZSkgJiYgbm9kZS5saXN0SXRlbSA9PT0gbGlzdFN0eWxlKSA6ICExO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcInNwYW5cIiAmJiBcInRleHRcIiBpbiBub2RlICYmIHR5cGVvZiBub2RlLnRleHQgPT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIG5vZGUubWFya3MgPiBcInVcIiB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya3MpICYmIG5vZGUubWFya3MuZXZlcnkoKG1hcmspID0+IHR5cGVvZiBtYXJrID09IFwic3RyaW5nXCIpKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkge1xuICByZXR1cm4gKFxuICAgIC8vIEEgYmxvY2sgZG9lc24ndCBfaGF2ZV8gdG8gYmUgbmFtZWQgJ2Jsb2NrJyAtIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlblxuICAgIC8vIGFsbG93ZWQgY2hpbGQgdHlwZXMgYW5kIG1hcmtzLCBvbmUgbWlnaHQgbmFtZSB0aGVtIGRpZmZlcmVudGx5XG4gICAgdHlwZW9mIG5vZGUuX3R5cGUgPT0gXCJzdHJpbmdcIiAmJiAvLyBUb29sa2l0LXR5cGVzIGxpa2UgbmVzdGVkIHNwYW5zIGFyZSBALXByZWZpeGVkXG4gICAgbm9kZS5fdHlwZVswXSAhPT0gXCJAXCIgJiYgLy8gYG1hcmtEZWZzYCBpc24ndCBfcmVxdWlyZWRfIHBlciBzYXksIGJ1dCBpZiBpdCdzIHRoZXJlLCBpdCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgICghKFwibWFya0RlZnNcIiBpbiBub2RlKSB8fCAhbm9kZS5tYXJrRGVmcyB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya0RlZnMpICYmIC8vIEV2ZXJ5IG1hcmsgZGVmaW5pdGlvbiBuZWVkcyB0byBoYXZlIGFuIGBfa2V5YCB0byBiZSBtYXBwYWJsZSBpbiBjaGlsZCBzcGFuc1xuICAgIG5vZGUubWFya0RlZnMuZXZlcnkoKGRlZikgPT4gdHlwZW9mIGRlZi5fa2V5ID09IFwic3RyaW5nXCIpKSAmJiAvLyBgY2hpbGRyZW5gIGlzIHJlcXVpcmVkIGFuZCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgIFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgJiYgLy8gQWxsIGNoaWxkcmVuIGFyZSBvYmplY3RzIHdpdGggYF90eXBlYCAodXN1YWxseSBzcGFucywgYnV0IGNhbiBjb250YWluIG90aGVyIHN0dWZmKVxuICAgIG5vZGUuY2hpbGRyZW4uZXZlcnkoKGNoaWxkKSA9PiB0eXBlb2YgY2hpbGQgPT0gXCJvYmplY3RcIiAmJiBcIl90eXBlXCIgaW4gY2hpbGQpXG4gICk7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1NwYW4oe1xuICBlZGl0b3IsXG4gIGJsb2NrUGF0aCxcbiAgc3BhblBhdGhcbn0pIHtcbiAgbGV0IHByZXZpb3VzU3BhbjtcbiAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgTm9kZS5jaGlsZHJlbihlZGl0b3IsIGJsb2NrUGF0aCwge1xuICAgIHJldmVyc2U6ICEwXG4gIH0pKVxuICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgJiYgUGF0aC5pc0JlZm9yZShjaGlsZFBhdGgsIHNwYW5QYXRoKSkge1xuICAgICAgcHJldmlvdXNTcGFuID0gY2hpbGQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBwcmV2aW91c1NwYW47XG59XG5mdW5jdGlvbiBnZXROZXh0U3Bhbih7XG4gIGVkaXRvcixcbiAgYmxvY2tQYXRoLFxuICBzcGFuUGF0aFxufSkge1xuICBsZXQgbmV4dFNwYW47XG4gIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpKVxuICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgJiYgUGF0aC5pc0FmdGVyKGNoaWxkUGF0aCwgc3BhblBhdGgpKSB7XG4gICAgICBuZXh0U3BhbiA9IGNoaWxkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gbmV4dFNwYW47XG59XG5jb25zdCBkZWJ1ZyRhID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbChlZGl0b3JBY3RvciwgdHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTIsXG4gICAgICBub3JtYWxpemVOb2RlXG4gICAgfSA9IGVkaXRvciwgZGVjb3JhdG9ycyA9IHR5cGVzLmRlY29yYXRvcnMubWFwKCh0KSA9PiB0LnZhbHVlKTtcbiAgICByZXR1cm4gZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAobm9kZUVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBub2RlRW50cnk7XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gTm9kZS5jaGlsZHJlbihlZGl0b3IsIHBhdGgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gbm9kZS5jaGlsZHJlbltjaGlsZFBhdGhbMV0gKyAxXTtcbiAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIGVkaXRvci5pc1RleHRTcGFuKG5leHROb2RlKSAmJiBjaGlsZC5tYXJrcz8uZXZlcnkoKG1hcmspID0+IG5leHROb2RlLm1hcmtzPy5pbmNsdWRlcyhtYXJrKSkgJiYgbmV4dE5vZGUubWFya3M/LmV2ZXJ5KChtYXJrKSA9PiBjaGlsZC5tYXJrcz8uaW5jbHVkZXMobWFyaykpKSB7XG4gICAgICAgICAgICBkZWJ1ZyRhKFwiTWVyZ2luZyBzcGFuc1wiLCBKU09OLnN0cmluZ2lmeShjaGlsZCwgbnVsbCwgMiksIEpTT04uc3RyaW5naWZ5KG5leHROb2RlLCBudWxsLCAyKSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBbY2hpbGRQYXRoWzBdLCBjaGlsZFBhdGhbMV0gKyAxXSxcbiAgICAgICAgICAgICAgdm9pZHM6ICEwXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgIUFycmF5LmlzQXJyYXkobm9kZS5tYXJrRGVmcykpIHtcbiAgICAgICAgZGVidWckYShcIkFkZGluZyAubWFya0RlZnMgdG8gYmxvY2sgbm9kZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtEZWZzOiBbXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4obm9kZSkgJiYgIUFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykpIHtcbiAgICAgICAgZGVidWckYShcIkFkZGluZyAubWFya3MgdG8gc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IFtdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSkge1xuICAgICAgICBjb25zdCBibG9ja1BhdGggPSBQYXRoLnBhcmVudChwYXRoKSwgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgYmxvY2tQYXRoKSwgZGVjb3JhdG9yczIgPSB0eXBlcy5kZWNvcmF0b3JzLm1hcCgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUpLCBhbm5vdGF0aW9ucyA9IG5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMyLmluY2x1ZGVzKG1hcmspKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgbm9kZS50ZXh0ID09PSBcIlwiICYmIGFubm90YXRpb25zICYmIGFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZyRhKFwiUmVtb3ZpbmcgYW5ub3RhdGlvbnMgZnJvbSBlbXB0eSBzcGFuIG5vZGVcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXJrczogbm9kZS5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzMi5pbmNsdWRlcyhtYXJrKSlcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGRlY29yYXRvcnMyID0gdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlKTtcbiAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgTm9kZS5jaGlsZHJlbihlZGl0b3IsIHBhdGgpKVxuICAgICAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gY2hpbGQubWFya3MgPz8gW10sIG9ycGhhbmVkQW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzMi5pbmNsdWRlcyhtYXJrKSAmJiAhbm9kZS5tYXJrRGVmcz8uZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgICAgICAgaWYgKG9ycGhhbmVkQW5ub3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBkZWJ1ZyRhKFwiUmVtb3Zpbmcgb3JwaGFuZWQgYW5ub3RhdGlvbnMgZnJvbSBzcGFuIG5vZGVcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBtYXJrczogbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhb3JwaGFuZWRBbm5vdGF0aW9ucy5pbmNsdWRlcyhtYXJrKSlcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrUGF0aCA9IFBhdGgucGFyZW50KHBhdGgpLCBbYmxvY2tdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSkge1xuICAgICAgICAgIGNvbnN0IGRlY29yYXRvcnMyID0gdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlKSwgbWFya3MgPSBub2RlLm1hcmtzID8/IFtdLCBvcnBoYW5lZEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykgJiYgIWJsb2NrLm1hcmtEZWZzPy5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrKSk7XG4gICAgICAgICAgaWYgKG9ycGhhbmVkQW5ub3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVidWckYShcIlJlbW92aW5nIG9ycGhhbmVkIGFubm90YXRpb25zIGZyb20gc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgbWFya3M6IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIW9ycGhhbmVkQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkpIHtcbiAgICAgICAgY29uc3QgbWFya0RlZnMgPSBub2RlLm1hcmtEZWZzID8/IFtdLCBtYXJrRGVmS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG5ld01hcmtEZWZzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWFya0RlZiBvZiBtYXJrRGVmcylcbiAgICAgICAgICBtYXJrRGVmS2V5cy5oYXMobWFya0RlZi5fa2V5KSB8fCAobWFya0RlZktleXMuYWRkKG1hcmtEZWYuX2tleSksIG5ld01hcmtEZWZzLnB1c2gobWFya0RlZikpO1xuICAgICAgICBpZiAobWFya0RlZnMubGVuZ3RoICE9PSBuZXdNYXJrRGVmcy5sZW5ndGgpIHtcbiAgICAgICAgICBkZWJ1ZyRhKFwiUmVtb3ZpbmcgZHVwbGljYXRlIG1hcmtEZWZzXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya0RlZnM6IG5ld01hcmtEZWZzXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiAhZWRpdG9yLm9wZXJhdGlvbnMuc29tZSgob3ApID0+IG9wLnR5cGUgPT09IFwibWVyZ2Vfbm9kZVwiICYmIFwibWFya0RlZnNcIiBpbiBvcC5wcm9wZXJ0aWVzICYmIG9wLnBhdGgubGVuZ3RoID09PSAxKSkge1xuICAgICAgICBjb25zdCBuZXdNYXJrRGVmcyA9IChub2RlLm1hcmtEZWZzIHx8IFtdKS5maWx0ZXIoKGRlZikgPT4gbm9kZS5jaGlsZHJlbi5maW5kKChjaGlsZCkgPT4gVGV4dC5pc1RleHQoY2hpbGQpICYmIEFycmF5LmlzQXJyYXkoY2hpbGQubWFya3MpICYmIGNoaWxkLm1hcmtzLmluY2x1ZGVzKGRlZi5fa2V5KSkpO1xuICAgICAgICBpZiAobm9kZS5tYXJrRGVmcyAmJiAhaXNFcXVhbChuZXdNYXJrRGVmcywgbm9kZS5tYXJrRGVmcykpIHtcbiAgICAgICAgICBkZWJ1ZyRhKFwiUmVtb3ZpbmcgbWFya0RlZiBub3QgaW4gdXNlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya0RlZnM6IG5ld01hcmtEZWZzXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShub2RlRW50cnkpO1xuICAgIH0sIGVkaXRvci5hcHBseSA9IChvcCkgPT4ge1xuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgRWRpdG9yLm1hcmtzKGVkaXRvcikgJiYgb3AucHJvcGVydGllcyAmJiBvcC5uZXdQcm9wZXJ0aWVzICYmIG9wLnByb3BlcnRpZXMuYW5jaG9yICYmIG9wLnByb3BlcnRpZXMuZm9jdXMgJiYgb3AubmV3UHJvcGVydGllcy5hbmNob3IgJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cykge1xuICAgICAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbklzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQoe1xuICAgICAgICAgIGFuY2hvcjogb3AucHJvcGVydGllcy5hbmNob3IsXG4gICAgICAgICAgZm9jdXM6IG9wLnByb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSksIG5ld1NlbGVjdGlvbklzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQoe1xuICAgICAgICAgIGFuY2hvcjogb3AubmV3UHJvcGVydGllcy5hbmNob3IsXG4gICAgICAgICAgZm9jdXM6IG9wLm5ld1Byb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmV2aW91c1NlbGVjdGlvbklzQ29sbGFwc2VkICYmIG5ld1NlbGVjdGlvbklzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgY29uc3QgZm9jdXNTcGFuID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgICAgICAgICAgYXQ6IG9wLnByb3BlcnRpZXMuZm9jdXMsXG4gICAgICAgICAgICBtYXRjaDogKG4pID0+IGVkaXRvci5pc1RleHRTcGFuKG4pLFxuICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgfSkpWzBdPy5bMF0sIG5ld0ZvY3VzU3BhbiA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgICAgIGF0OiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXT8uWzBdLCBtb3ZlZFRvTmV4dFNwYW4gPSBmb2N1c1NwYW4gJiYgbmV3Rm9jdXNTcGFuICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMucGF0aFswXSA9PT0gb3AucHJvcGVydGllcy5mb2N1cy5wYXRoWzBdICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMucGF0aFsxXSA9PT0gb3AucHJvcGVydGllcy5mb2N1cy5wYXRoWzFdICsgMSAmJiBmb2N1c1NwYW4udGV4dC5sZW5ndGggPT09IG9wLnByb3BlcnRpZXMuZm9jdXMub2Zmc2V0ICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMub2Zmc2V0ID09PSAwLCBtb3ZlZFRvUHJldmlvdXNTcGFuID0gZm9jdXNTcGFuICYmIG5ld0ZvY3VzU3BhbiAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMF0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFswXSAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMV0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFsxXSAtIDEgJiYgb3AucHJvcGVydGllcy5mb2N1cy5vZmZzZXQgPT09IDAgJiYgbmV3Rm9jdXNTcGFuLnRleHQubGVuZ3RoID09PSBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLm9mZnNldDtcbiAgICAgICAgICBpZiAobW92ZWRUb05leHRTcGFuIHx8IG1vdmVkVG9QcmV2aW91c1NwYW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcC50eXBlID09PSBcImluc2VydF9ub2RlXCIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgW19ibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgIH0pLCBwcmV2aW91c1NwYW4gPSBnZXRQcmV2aW91c1NwYW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgc3BhblBhdGg6IG9wLnBhdGhcbiAgICAgICAgICB9KSwgcHJldmlvdXNTcGFuQW5ub3RhdGlvbnMgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpIDogW10sIG5leHRTcGFuID0gZ2V0TmV4dFNwYW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgc3BhblBhdGg6IFtvcC5wYXRoWzBdLCBvcC5wYXRoWzFdIC0gMV1cbiAgICAgICAgICB9KSwgbmV4dFNwYW5Bbm5vdGF0aW9ucyA9IG5leHRTcGFuID8gbmV4dFNwYW4ubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpIDogW10sIGFubm90YXRpb25zRW5kaW5nID0gcHJldmlvdXNTcGFuQW5ub3RhdGlvbnM/LmZpbHRlcigoYW5ub3RhdGlvbikgPT4gIW5leHRTcGFuQW5ub3RhdGlvbnM/LmluY2x1ZGVzKGFubm90YXRpb24pKSA/PyBbXSwgYXRUaGVFbmRPZkFubm90YXRpb24gPSBhbm5vdGF0aW9uc0VuZGluZy5sZW5ndGggPiAwO1xuICAgICAgICAgIGlmIChhdFRoZUVuZE9mQW5ub3RhdGlvbiAmJiBpc1BvcnRhYmxlVGV4dFNwYW4ob3Aubm9kZSkgJiYgb3Aubm9kZS5tYXJrcz8uc29tZSgobWFyaykgPT4gYW5ub3RhdGlvbnNFbmRpbmcuaW5jbHVkZXMobWFyaykpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAuLi5vcC5ub2RlLFxuICAgICAgICAgICAgICBtYXJrczogb3Aubm9kZS5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhYW5ub3RhdGlvbnNFbmRpbmcuaW5jbHVkZXMobWFyaykpID8/IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnNTdGFydGluZyA9IG5leHRTcGFuQW5ub3RhdGlvbnM/LmZpbHRlcigoYW5ub3RhdGlvbikgPT4gIXByZXZpb3VzU3BhbkFubm90YXRpb25zPy5pbmNsdWRlcyhhbm5vdGF0aW9uKSkgPz8gW10sIGF0VGhlU3RhcnRPZkFubm90YXRpb24gPSBhbm5vdGF0aW9uc1N0YXJ0aW5nLmxlbmd0aCA+IDA7XG4gICAgICAgICAgaWYgKGF0VGhlU3RhcnRPZkFubm90YXRpb24gJiYgaXNQb3J0YWJsZVRleHRTcGFuKG9wLm5vZGUpICYmIG9wLm5vZGUubWFya3M/LnNvbWUoKG1hcmspID0+IGFubm90YXRpb25zU3RhcnRpbmcuaW5jbHVkZXMobWFyaykpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAuLi5vcC5ub2RlLFxuICAgICAgICAgICAgICBtYXJrczogb3Aubm9kZS5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhYW5ub3RhdGlvbnNTdGFydGluZy5pbmNsdWRlcyhtYXJrKSkgPz8gW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuZXh0U3BhbkRlY29yYXRvcnMgPSBuZXh0U3Bhbj8ubWFya3M/LmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkgPz8gW107XG4gICAgICAgICAgaWYgKG5leHRTcGFuRGVjb3JhdG9ycy5sZW5ndGggPiAwICYmIGF0VGhlRW5kT2ZBbm5vdGF0aW9uICYmICFhdFRoZVN0YXJ0T2ZBbm5vdGF0aW9uICYmIGlzUG9ydGFibGVUZXh0U3BhbihvcC5ub2RlKSAmJiBvcC5ub2RlLm1hcmtzPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIC4uLm9wLm5vZGUsXG4gICAgICAgICAgICAgIG1hcmtzOiBuZXh0U3BhbkRlY29yYXRvcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3IsIGNvbGxhcHNlZFNlbGVjdGlvbiA9IHNlbGVjdGlvbiA/IFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgOiAhMTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBjb2xsYXBzZWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICBjb25zdCBbX2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHtcbiAgICAgICAgICAgIGRlcHRoOiAxXG4gICAgICAgICAgfSksIFtzcGFuLCBzcGFuUGF0aF0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgICAgICBhdDogc2VsZWN0aW9uLmZvY3VzLFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXSA/PyBbdm9pZCAwLCB2b2lkIDBdLCBtYXJrcyA9IHNwYW4ubWFya3MgPz8gW10sIG1hcmtzV2l0aG91dEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSwgc3Bhbkhhc0Fubm90YXRpb25zID0gbWFya3MubGVuZ3RoID4gbWFya3NXaXRob3V0QW5ub3RhdGlvbnMubGVuZ3RoLCBzcGFuSXNFbXB0eSA9IHNwYW4udGV4dC5sZW5ndGggPT09IDAsIGF0VGhlQmVnaW5uaW5nT2ZTcGFuID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDAsIGF0VGhlRW5kT2ZTcGFuID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IHNwYW4udGV4dC5sZW5ndGgsIHByZXZpb3VzU3BhbiA9IGdldFByZXZpb3VzU3Bhbih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICBzcGFuUGF0aFxuICAgICAgICAgIH0pLCBuZXh0U3BhbiA9IGdldE5leHRTcGFuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgICAgfSksIG5leHRTcGFuQW5ub3RhdGlvbnMgPSBuZXh0U3Bhbj8ubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpID8/IFtdLCBzcGFuQW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSwgcHJldmlvdXNTcGFuSGFzQW5ub3RhdGlvbnMgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbnMgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpLmV2ZXJ5KChtYXJrKSA9PiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgcHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb24gPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspICYmIG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExLCBwcmV2aW91c1NwYW5IYXNTYW1lTWFya3MgPSBwcmV2aW91c1NwYW4gPyBwcmV2aW91c1NwYW4ubWFya3M/LmV2ZXJ5KChtYXJrKSA9PiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgbmV4dFNwYW5TaGFyZXNTb21lQW5ub3RhdGlvbnMgPSBzcGFuQW5ub3RhdGlvbnMuc29tZSgobWFyaykgPT4gbmV4dFNwYW5Bbm5vdGF0aW9ucz8uaW5jbHVkZXMobWFyaykpO1xuICAgICAgICAgIGlmIChzcGFuSGFzQW5ub3RhdGlvbnMgJiYgIXNwYW5Jc0VtcHR5KSB7XG4gICAgICAgICAgICBpZiAoYXRUaGVCZWdpbm5pbmdPZlNwYW4pIHtcbiAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU3Bhbkhhc1NhbWVNYXJrcykge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICAgICAgbWFya3M6IHByZXZpb3VzU3Bhbj8ubWFya3MgPz8gW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogcHJldmlvdXNTcGFuPy5tYXJrcyA/PyBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwcmV2aW91c1NwYW4pIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0VGhlRW5kT2ZTcGFuKSB7XG4gICAgICAgICAgICAgIGlmIChuZXh0U3BhbiAmJiBuZXh0U3BhblNoYXJlc1NvbWVBbm5vdGF0aW9ucyAmJiBuZXh0U3BhbkFubm90YXRpb25zLmxlbmd0aCA8IHNwYW5Bbm5vdGF0aW9ucy5sZW5ndGggfHwgIW5leHRTcGFuU2hhcmVzU29tZUFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogbmV4dFNwYW4/Lm1hcmtzID8/IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghbmV4dFNwYW4pIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXRUaGVCZWdpbm5pbmdPZlNwYW4gJiYgIXNwYW5Jc0VtcHR5ICYmIHByZXZpb3VzU3Bhbikge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgIG1hcmtzOiBwcmV2aW91c1NwYW5IYXNBbm5vdGF0aW9ucyA/IFtdIDogKHByZXZpb3VzU3Bhbi5tYXJrcyA/PyBbXSkuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiwge1xuICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICB9KSwgW3NwYW4sIHNwYW5QYXRoXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgICAgIGF0OiB7XG4gICAgICAgICAgICAgIHBhdGg6IG9wLnBhdGgsXG4gICAgICAgICAgICAgIG9mZnNldDogb3Aub2Zmc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXSA/PyBbdm9pZCAwLCB2b2lkIDBdO1xuICAgICAgICAgIGlmIChzcGFuICYmIGJsb2NrICYmIGlzUG9ydGFibGVUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrRGVmcyA9IGJsb2NrLm1hcmtEZWZzID8/IFtdLCBtYXJrcyA9IHNwYW4ubWFya3MgPz8gW10sIHNwYW5IYXNBbm5vdGF0aW9ucyA9IG1hcmtzLnNvbWUoKG1hcmspID0+IG1hcmtEZWZzLmZpbmQoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFyaykpLCBkZWxldGluZ0Zyb21UaGVFbmQgPSBvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA9PT0gc3Bhbi50ZXh0Lmxlbmd0aCwgZGVsZXRpbmdBbGxUZXh0ID0gb3Aub2Zmc2V0ID09PSAwICYmIGRlbGV0aW5nRnJvbVRoZUVuZCwgcHJldmlvdXNTcGFuID0gZ2V0UHJldmlvdXNTcGFuKHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICAgIHNwYW5QYXRoXG4gICAgICAgICAgICB9KSwgbmV4dFNwYW4gPSBnZXROZXh0U3Bhbih7XG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgICBzcGFuUGF0aFxuICAgICAgICAgICAgfSksIHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9uID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSAmJiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgbmV4dFNwYW5IYXNTYW1lQW5ub3RhdGlvbiA9IG5leHRTcGFuID8gbmV4dFNwYW4ubWFya3M/LnNvbWUoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspICYmIG1hcmtzLmluY2x1ZGVzKG1hcmspKSA6ICExO1xuICAgICAgICAgICAgaWYgKHNwYW5IYXNBbm5vdGF0aW9ucyAmJiBkZWxldGluZ0FsbFRleHQgJiYgIXByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9uICYmICFuZXh0U3Bhbkhhc1NhbWVBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtzV2l0aG91dEFubm90YXRpb25NYXJrcyA9ICh7XG4gICAgICAgICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICAgICAgICAgICAgfS5tYXJrcyB8fCBbXSkuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKTtcbiAgICAgICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICBhcHBseTIob3ApLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgbWFya3M6IG1hcmtzV2l0aG91dEFubm90YXRpb25NYXJrc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIGF0OiBvcC5wYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwibWVyZ2Vfbm9kZVwiICYmIG9wLnBhdGgubGVuZ3RoID09PSAxICYmIFwibWFya0RlZnNcIiBpbiBvcC5wcm9wZXJ0aWVzICYmIG9wLnByb3BlcnRpZXMuX3R5cGUgPT09IHR5cGVzLmJsb2NrLm5hbWUgJiYgQXJyYXkuaXNBcnJheShvcC5wcm9wZXJ0aWVzLm1hcmtEZWZzKSAmJiBvcC5wcm9wZXJ0aWVzLm1hcmtEZWZzLmxlbmd0aCA+IDAgJiYgb3AucGF0aFswXSAtIDEgPj0gMCkge1xuICAgICAgICBjb25zdCBbdGFyZ2V0QmxvY2ssIHRhcmdldFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXSAtIDFdKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayh0YXJnZXRCbG9jaykpIHtcbiAgICAgICAgICBjb25zdCBvbGREZWZzID0gQXJyYXkuaXNBcnJheSh0YXJnZXRCbG9jay5tYXJrRGVmcykgJiYgdGFyZ2V0QmxvY2subWFya0RlZnMgfHwgW10sIG5ld01hcmtEZWZzID0gdW5pcShbLi4ub2xkRGVmcywgLi4ub3AucHJvcGVydGllcy5tYXJrRGVmc10pO1xuICAgICAgICAgIGRlYnVnJGEoXCJDb3B5aW5nIG1hcmtEZWZzIG92ZXIgdG8gbWVyZ2VkIGJsb2NrXCIsIG9wKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRQYXRoLFxuICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgfSksIGFwcGx5MihvcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGFkZERlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IGFjdGlvbi5lZGl0b3IsIG1hcmsgPSBhY3Rpb24uZGVjb3JhdG9yO1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICBzcGxpdDogITAsXG4gICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNwbGl0VGV4dE5vZGVzID0gUmFuZ2UuaXNSYW5nZShlZGl0b3Iuc2VsZWN0aW9uKSA/IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICAgIH0pXSA6IFtdO1xuICAgICAgc3BsaXRUZXh0Tm9kZXMubGVuZ3RoID4gMSAmJiBzcGxpdFRleHROb2Rlcy5ldmVyeSgobm9kZSkgPT4gbm9kZVswXS5tYXJrcz8uaW5jbHVkZXMobWFyaykpID8gZWRpdG9yLnJlbW92ZU1hcmsobWFyaykgOiBzcGxpdFRleHROb2Rlcy5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgY29uc3QgbWFya3MgPSBbLi4uKEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgPyBub2RlLm1hcmtzIDogW10pLmZpbHRlcigoZU1hcmspID0+IGVNYXJrICE9PSBtYXJrKSwgbWFya107XG4gICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3NcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgICBzcGxpdDogITAsXG4gICAgICAgICAgaGFuZ2luZzogITBcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLCB7XG4gICAgICAgIGRlcHRoOiAxXG4gICAgICB9KSwgbG9uZWx5RW1wdHlTcGFuID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZWRpdG9yLmlzVGV4dFNwYW4oYmxvY2suY2hpbGRyZW5bMF0pICYmIGJsb2NrLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCIgPyBibG9jay5jaGlsZHJlblswXSA6IHZvaWQgMDtcbiAgICAgIGlmIChsb25lbHlFbXB0eVNwYW4pIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdNYXJrcyA9IGxvbmVseUVtcHR5U3Bhbi5tYXJrcyA/PyBbXSwgZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3IgPSBleGlzdGluZ01hcmtzLmZpbHRlcigoZXhpc3RpbmdNYXJrKSA9PiBleGlzdGluZ01hcmsgIT09IG1hcmspO1xuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBleGlzdGluZ01hcmtzLmxlbmd0aCA9PT0gZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3IubGVuZ3RoID8gWy4uLmV4aXN0aW5nTWFya3MsIG1hcmtdIDogZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3JcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSB7XG4gICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICAgICAgfS5tYXJrcyB8fCBbXSwgbWFya3MgPSB7XG4gICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30sXG4gICAgICAgICAgbWFya3M6IFsuLi5leGlzdGluZ01hcmtzLCBtYXJrXVxuICAgICAgICB9O1xuICAgICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcbiAgICAgIH1cbiAgICB9XG4gICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gIH1cbn0sIHJlbW92ZURlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IGFjdGlvbi5lZGl0b3IsIG1hcmsgPSBhY3Rpb24uZGVjb3JhdG9yLCB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmIChzZWxlY3Rpb24pXG4gICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSlcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSwge1xuICAgICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICAgIHNwbGl0OiAhMCxcbiAgICAgICAgaGFuZ2luZzogITBcbiAgICAgIH0pLCBlZGl0b3Iuc2VsZWN0aW9uICYmIFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICAgIH0pXS5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bcGF0aFswXV07XG4gICAgICAgIEVsZW1lbnQkMS5pc0VsZW1lbnQoYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuLmluY2x1ZGVzKG5vZGUpICYmIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IChBcnJheS5pc0FycmF5KG5vZGUubWFya3MpID8gbm9kZS5tYXJrcyA6IFtdKS5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyayksXG4gICAgICAgICAgX3R5cGU6IFwic3BhblwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHtcbiAgICAgICAgZGVwdGg6IDFcbiAgICAgIH0pLCBsb25lbHlFbXB0eVNwYW4gPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlblswXSkgJiYgYmxvY2suY2hpbGRyZW5bMF0udGV4dCA9PT0gXCJcIiA/IGJsb2NrLmNoaWxkcmVuWzBdIDogdm9pZCAwO1xuICAgICAgaWYgKGxvbmVseUVtcHR5U3Bhbikge1xuICAgICAgICBjb25zdCBleGlzdGluZ01hcmtzV2l0aG91dERlY29yYXRvciA9IChsb25lbHlFbXB0eVNwYW4ubWFya3MgPz8gW10pLmZpbHRlcigoZXhpc3RpbmdNYXJrKSA9PiBleGlzdGluZ01hcmsgIT09IG1hcmspO1xuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBleGlzdGluZ01hcmtzV2l0aG91dERlY29yYXRvclxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRTcGFuKG5vZGUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdNYXJrcyA9IHtcbiAgICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICAgICAgICB9Lm1hcmtzIHx8IFtdLCBtYXJrcyA9IHtcbiAgICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSxcbiAgICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrcy5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyaylcbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0ge1xuICAgICAgICAgIG1hcmtzOiBtYXJrcy5tYXJrcyxcbiAgICAgICAgICBfdHlwZTogXCJzcGFuXCJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gaXNEZWNvcmF0b3JBY3RpdmUoe1xuICBlZGl0b3IsXG4gIGRlY29yYXRvclxufSkge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzZWxlY3RlZFRleHROb2RlcyA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICBhdDogZWRpdG9yLnNlbGVjdGlvblxuICB9KSk7XG4gIHJldHVybiBzZWxlY3RlZFRleHROb2Rlcy5sZW5ndGggPT09IDAgPyAhMSA6IFJhbmdlLmlzRXhwYW5kZWQoZWRpdG9yLnNlbGVjdGlvbikgPyBzZWxlY3RlZFRleHROb2Rlcy5ldmVyeSgobikgPT4ge1xuICAgIGNvbnN0IFtub2RlXSA9IG47XG4gICAgcmV0dXJuIG5vZGUubWFya3M/LmluY2x1ZGVzKGRlY29yYXRvcik7XG4gIH0pIDogKHtcbiAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICB9Lm1hcmtzIHx8IFtdKS5pbmNsdWRlcyhkZWNvcmF0b3IpO1xufVxuY29uc3QgdG9nZ2xlRGVjb3JhdG9yQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaXNEZWNvcmF0b3JBY3RpdmUoe1xuICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvcixcbiAgICBkZWNvcmF0b3I6IGFjdGlvbi5kZWNvcmF0b3JcbiAgfSkgPyByZW1vdmVEZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb246IHtcbiAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnJlbW92ZVwiLFxuICAgICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgICAgZGVjb3JhdG9yOiBhY3Rpb24uZGVjb3JhdG9yXG4gICAgfVxuICB9KSA6IGFkZERlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgdHlwZTogXCJkZWNvcmF0b3IuYWRkXCIsXG4gICAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgICBkZWNvcmF0b3I6IGFjdGlvbi5kZWNvcmF0b3JcbiAgICB9XG4gIH0pO1xufSwgZGVidWckOSA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnNcIiksIGRlYnVnVmVyYm9zZSA9IGRlYnVnJDkuZW5hYmxlZCAmJiAhMTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zKGVkaXRvckFjdG9yLCB0eXBlcykge1xuICBsZXQgcHJldlNlbGVjdGlvbiA9IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCBlbWl0UG9ydGFibGVUZXh0U2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKHByZXZTZWxlY3Rpb24gIT09IGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IHB0UmFuZ2UgPSBudWxsO1xuICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRS5nZXQoZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nKVxuICAgICAgICAgICAgcHRSYW5nZSA9IGV4aXN0aW5nO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlZGl0b3IuY2hpbGRyZW47XG4gICAgICAgICAgICBwdFJhbmdlID0gdG9Qb3J0YWJsZVRleHRSYW5nZSh2YWx1ZSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpLCBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLnNldChlZGl0b3Iuc2VsZWN0aW9uLCBwdFJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdWZXJib3NlICYmIGRlYnVnJDkoYEVtaXR0aW5nIHNlbGVjdGlvbiAke0pTT04uc3RyaW5naWZ5KHB0UmFuZ2UgfHwgbnVsbCl9ICgke0pTT04uc3RyaW5naWZ5KGVkaXRvci5zZWxlY3Rpb24pfSlgKSwgcHRSYW5nZSA/IGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgc2VsZWN0aW9uOiBwdFJhbmdlXG4gICAgICAgIH0pIDogZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgICBzZWxlY3Rpb246IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwcmV2U2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB9LCB7XG4gICAgICBvbkNoYW5nZVxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5vbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc0NoYW5nZXMgPSBlZGl0b3Iub3BlcmF0aW9ucy5sZW5ndGggPiAwO1xuICAgICAgb25DaGFuZ2UoKSwgaGFzQ2hhbmdlcyAmJiBlbWl0UG9ydGFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckOCA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFNjaGVtYVR5cGVzXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFNjaGVtYVR5cGVzKHtcbiAgZWRpdG9yQWN0b3IsXG4gIHNjaGVtYVR5cGVzXG59KSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuaXNUZXh0QmxvY2sgPSAodmFsdWUpID0+IGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKHZhbHVlKSAmJiB2YWx1ZS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSwgZWRpdG9yLmlzVGV4dFNwYW4gPSAodmFsdWUpID0+IGlzUG9ydGFibGVUZXh0U3BhbiQxKHZhbHVlKSAmJiB2YWx1ZS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuc3Bhbi5uYW1lLCBlZGl0b3IuaXNMaXN0QmxvY2sgPSAodmFsdWUpID0+IGlzUG9ydGFibGVUZXh0TGlzdEJsb2NrKHZhbHVlKSAmJiB2YWx1ZS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSwgZWRpdG9yLmlzVm9pZCA9IChlbGVtZW50KSA9PiBzY2hlbWFUeXBlcy5ibG9jay5uYW1lICE9PSBlbGVtZW50Ll90eXBlICYmIChzY2hlbWFUeXBlcy5ibG9ja09iamVjdHMubWFwKChvYmopID0+IG9iai5uYW1lKS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSB8fCBzY2hlbWFUeXBlcy5pbmxpbmVPYmplY3RzLm1hcCgob2JqKSA9PiBvYmoubmFtZSkuaW5jbHVkZXMoZWxlbWVudC5fdHlwZSkpLCBlZGl0b3IuaXNJbmxpbmUgPSAoZWxlbWVudCkgPT4gc2NoZW1hVHlwZXMuaW5saW5lT2JqZWN0cy5tYXAoKG9iaikgPT4gb2JqLm5hbWUpLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpICYmIFwiX19pbmxpbmVcIiBpbiBlbGVtZW50ICYmIGVsZW1lbnQuX19pbmxpbmUgPT09ICEwO1xuICAgIGNvbnN0IHtcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gICAgICBpZiAobm9kZS5fdHlwZSA9PT0gdm9pZCAwICYmIHBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGRlYnVnJDgoXCJTZXR0aW5nIHNwYW4gdHlwZSBvbiB0ZXh0IG5vZGUgd2l0aG91dCBhIHR5cGVcIik7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBub2RlLCBrZXkgPSBzcGFuLl9rZXkgfHwgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpO1xuICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgLi4uc3BhbixcbiAgICAgICAgICBfdHlwZTogc2NoZW1hVHlwZXMuc3Bhbi5uYW1lLFxuICAgICAgICAgIF9rZXk6IGtleVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5fa2V5ID09PSB2b2lkIDAgJiYgKHBhdGgubGVuZ3RoID09PSAxIHx8IHBhdGgubGVuZ3RoID09PSAyKSkge1xuICAgICAgICBkZWJ1ZyQ4KFwiU2V0dGluZyBtaXNzaW5nIGtleSBvbiBjaGlsZCBub2RlIHdpdGhvdXQgYSBrZXlcIik7XG4gICAgICAgIGNvbnN0IGtleSA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKTtcbiAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIF9rZXk6IGtleVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub3JtYWxpemVOb2RlKGVudHJ5KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyQ3ID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoVXRpbHNcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoVXRpbHMoe1xuICBlZGl0b3JBY3RvcixcbiAgc2NoZW1hVHlwZXNcbn0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucHRlRXhwYW5kVG9Xb3JkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG4gICAgICBpZiAoc2VsZWN0aW9uICYmICFSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgW3RleHROb2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzLCB7XG4gICAgICAgICAgZGVwdGg6IDJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGV4dE5vZGUgfHwgIVRleHQuaXNUZXh0KHRleHROb2RlKSB8fCB0ZXh0Tm9kZS50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlYnVnJDcoXCJwdGVFeHBhbmRUb1dvcmQ6IENhbid0IGV4cGFuZCB0byB3b3JkIGhlcmVcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmb2N1c1xuICAgICAgICB9ID0gc2VsZWN0aW9uLCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldCwgY2hhcnNCZWZvcmUgPSB0ZXh0Tm9kZS50ZXh0LnNsaWNlKDAsIGZvY3VzT2Zmc2V0KSwgY2hhcnNBZnRlciA9IHRleHROb2RlLnRleHQuc2xpY2UoZm9jdXNPZmZzZXQsIC0xKSwgaXNFbXB0eSA9IChzdHIpID0+IHN0ci5tYXRjaCgvXFxzL2cpLCB3aGl0ZVNwYWNlQmVmb3JlSW5kZXggPSBjaGFyc0JlZm9yZS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuZmluZEluZGV4KChzdHIpID0+IGlzRW1wdHkoc3RyKSksIG5ld1N0YXJ0T2Zmc2V0ID0gd2hpdGVTcGFjZUJlZm9yZUluZGV4ID4gLTEgPyBjaGFyc0JlZm9yZS5sZW5ndGggLSB3aGl0ZVNwYWNlQmVmb3JlSW5kZXggOiAwLCB3aGl0ZVNwYWNlQWZ0ZXJJbmRleCA9IGNoYXJzQWZ0ZXIuc3BsaXQoXCJcIikuZmluZEluZGV4KChvYmopID0+IGlzRW1wdHkob2JqKSksIG5ld0VuZE9mZnNldCA9IGNoYXJzQmVmb3JlLmxlbmd0aCArICh3aGl0ZVNwYWNlQWZ0ZXJJbmRleCA+IC0xID8gd2hpdGVTcGFjZUFmdGVySW5kZXggOiBjaGFyc0FmdGVyLmxlbmd0aCArIDEpO1xuICAgICAgICBpZiAoIShuZXdTdGFydE9mZnNldCA9PT0gbmV3RW5kT2Zmc2V0IHx8IE51bWJlci5pc05hTihuZXdTdGFydE9mZnNldCkgfHwgTnVtYmVyLmlzTmFOKG5ld0VuZE9mZnNldCkpKSB7XG4gICAgICAgICAgZGVidWckNyhcInB0ZUV4cGFuZFRvV29yZDogRXhwYW5kaW5nIHRvIGZvY3VzZWQgd29yZFwiKSwgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgICAgLi4uc2VsZWN0aW9uLmFuY2hvcixcbiAgICAgICAgICAgICAgb2Zmc2V0OiBuZXdTdGFydE9mZnNldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgICAgIC4uLnNlbGVjdGlvbi5mb2N1cyxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBuZXdFbmRPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWckNyhcInB0ZUV4cGFuZFRvV29yZDogQ2FuJ3QgZXhwYW5kIHRvIHdvcmQgaGVyZVwiKTtcbiAgICAgIH1cbiAgICB9LCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrID0gKG9wdGlvbnMpID0+IHRvU2xhdGVWYWx1ZShbe1xuICAgICAgX3R5cGU6IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsXG4gICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICBzdHlsZTogc2NoZW1hVHlwZXMuc3R5bGVzWzBdLnZhbHVlIHx8IFwibm9ybWFsXCIsXG4gICAgICAuLi5vcHRpb25zLmxpc3RJdGVtID8ge1xuICAgICAgICBsaXN0SXRlbTogb3B0aW9ucy5saXN0SXRlbVxuICAgICAgfSA6IHt9LFxuICAgICAgLi4ub3B0aW9ucy5sZXZlbCA/IHtcbiAgICAgICAgbGV2ZWw6IG9wdGlvbnMubGV2ZWxcbiAgICAgIH0gOiB7fSxcbiAgICAgIG1hcmtEZWZzOiBbXSxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgbWFya3M6IG9wdGlvbnMuZGVjb3JhdG9ycy5maWx0ZXIoKGRlY29yYXRvcikgPT4gc2NoZW1hVHlwZXMuZGVjb3JhdG9ycy5maW5kKCh7XG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSkgPT4gdmFsdWUgPT09IGRlY29yYXRvcikpXG4gICAgICB9XVxuICAgIH1dLCB7XG4gICAgICBzY2hlbWFUeXBlc1xuICAgIH0pWzBdLCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCB3aXRoUGx1Z2lucyA9IChlZGl0b3IsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZSA9IGVkaXRvciwge1xuICAgIGVkaXRvckFjdG9yXG4gIH0gPSBvcHRpb25zLCBzY2hlbWFUeXBlcyA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWEsIG9wZXJhdGlvblRvUGF0Y2hlcyA9IGNyZWF0ZU9wZXJhdGlvblRvUGF0Y2hlcyhzY2hlbWFUeXBlcyksIHdpdGhPYmplY3RLZXlzID0gY3JlYXRlV2l0aE9iamVjdEtleXMoZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzKSwgd2l0aFNjaGVtYVR5cGVzID0gY3JlYXRlV2l0aFNjaGVtYVR5cGVzKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBzY2hlbWFUeXBlc1xuICB9KSwgd2l0aFBhdGNoZXMgPSBjcmVhdGVXaXRoUGF0Y2hlcyh7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgcGF0Y2hGdW5jdGlvbnM6IG9wZXJhdGlvblRvUGF0Y2hlcyxcbiAgICBzY2hlbWFUeXBlcyxcbiAgICBzdWJzY3JpcHRpb25zOiBvcHRpb25zLnN1YnNjcmlwdGlvbnNcbiAgfSksIHdpdGhNYXhCbG9ja3MgPSBjcmVhdGVXaXRoTWF4QmxvY2tzKGVkaXRvckFjdG9yKSwgd2l0aFBvcnRhYmxlVGV4dExpc3RzID0gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dExpc3RzKHNjaGVtYVR5cGVzKSwgd2l0aFVuZG9SZWRvID0gY3JlYXRlV2l0aFVuZG9SZWRvKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBibG9ja1NjaGVtYVR5cGU6IHNjaGVtYVR5cGVzLmJsb2NrLFxuICAgIHN1YnNjcmlwdGlvbnM6IG9wdGlvbnMuc3Vic2NyaXB0aW9uc1xuICB9KSwgd2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbCA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwoZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzKSwgd2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGUgPSBjcmVhdGVXaXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZShlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMpLCB3aXRoUGxhY2Vob2xkZXJCbG9jayA9IGNyZWF0ZVdpdGhQbGFjZWhvbGRlckJsb2NrKGVkaXRvckFjdG9yKSwgd2l0aFV0aWxzID0gY3JlYXRlV2l0aFV0aWxzKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBzY2hlbWFUeXBlc1xuICB9KSwgd2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMgPSBjcmVhdGVXaXRoUG9ydGFibGVUZXh0U2VsZWN0aW9ucyhlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMpO1xuICByZXR1cm4gY3JlYXRlV2l0aEV2ZW50TGlzdGVuZXJzKGVkaXRvckFjdG9yLCBvcHRpb25zLnN1YnNjcmlwdGlvbnMpKHdpdGhTY2hlbWFUeXBlcyh3aXRoT2JqZWN0S2V5cyh3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsKHdpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlKHdpdGhQb3J0YWJsZVRleHRMaXN0cyh3aXRoUGxhY2Vob2xkZXJCbG9jayh3aXRoVXRpbHMod2l0aE1heEJsb2Nrcyh3aXRoVW5kb1JlZG8od2l0aFBhdGNoZXMod2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMoZSkpKSkpKSkpKSkpKTtcbn0sIGRlYnVnJDYgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50OlBvcnRhYmxlVGV4dEVkaXRvcjpTbGF0ZUNvbnRhaW5lclwiKSwgc2xhdGVFZGl0b3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBjcmVhdGVTbGF0ZUVkaXRvcihjb25maWcpIHtcbiAgY29uc3QgZXhpc3RpbmdTbGF0ZUVkaXRvciA9IHNsYXRlRWRpdG9ycy5nZXQoY29uZmlnLmVkaXRvckFjdG9yKTtcbiAgaWYgKGV4aXN0aW5nU2xhdGVFZGl0b3IpXG4gICAgcmV0dXJuIGRlYnVnJDYoXCJSZXVzaW5nIGV4aXN0aW5nIFNsYXRlIGVkaXRvciBpbnN0YW5jZVwiLCBjb25maWcuZWRpdG9yQWN0b3IuaWQpLCBleGlzdGluZ1NsYXRlRWRpdG9yO1xuICBkZWJ1ZyQ2KFwiQ3JlYXRpbmcgbmV3IFNsYXRlIGVkaXRvciBpbnN0YW5jZVwiLCBjb25maWcuZWRpdG9yQWN0b3IuaWQpO1xuICBjb25zdCB1bnN1YnNjcmlwdGlvbnMgPSBbXSwgc3Vic2NyaXB0aW9ucyA9IFtdLCBpbnN0YW5jZSA9IHdpdGhQbHVnaW5zKHdpdGhSZWFjdChjcmVhdGVFZGl0b3IkMSgpKSwge1xuICAgIGVkaXRvckFjdG9yOiBjb25maWcuZWRpdG9yQWN0b3IsXG4gICAgc3Vic2NyaXB0aW9uc1xuICB9KTtcbiAgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuc2V0KGluc3RhbmNlLCB7fSksIEtFWV9UT19TTEFURV9FTEVNRU5ULnNldChpbnN0YW5jZSwge30pO1xuICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiBzdWJzY3JpcHRpb25zKVxuICAgIHVuc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbigpKTtcbiAgY29uc3QgaW5pdGlhbFZhbHVlID0gW2luc3RhbmNlLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgZGVjb3JhdG9yczogW11cbiAgfSldLCBzbGF0ZUVkaXRvciA9IHtcbiAgICBpbnN0YW5jZSxcbiAgICBpbml0aWFsVmFsdWVcbiAgfTtcbiAgcmV0dXJuIHNsYXRlRWRpdG9ycy5zZXQoY29uZmlnLmVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvciksIHNsYXRlRWRpdG9yO1xufVxuZnVuY3Rpb24gaW5zZXJ0QmxvY2soe1xuICBibG9jayxcbiAgcGxhY2VtZW50LFxuICBlZGl0b3IsXG4gIHNjaGVtYVxufSkge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIGNvbnN0IFtmb2N1c0Jsb2NrLCBmb2N1c0Jsb2NrUGF0aF0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksXG4gICAgICBtYXRjaDogKG4pID0+ICFFZGl0b3IuaXNFZGl0b3IobilcbiAgICB9KSlbMF0gPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICBpZiAocGxhY2VtZW50ID09PSBcImFmdGVyXCIpIHtcbiAgICAgIGNvbnN0IG5leHRQYXRoID0gW2ZvY3VzQmxvY2tQYXRoWzBdICsgMV07XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgYmxvY2ssIHtcbiAgICAgICAgYXQ6IG5leHRQYXRoXG4gICAgICB9KSwgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IFtuZXh0UGF0aFswXSwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aDogW25leHRQYXRoWzBdLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHBsYWNlbWVudCA9PT0gXCJiZWZvcmVcIiA/IFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBibG9jaywge1xuICAgICAgYXQ6IGZvY3VzQmxvY2tQYXRoXG4gICAgfSkgOiBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGJsb2NrKTtcbiAgICBmb2N1c0Jsb2NrICYmIGlzRXF1YWxUb0VtcHR5RWRpdG9yKFtmb2N1c0Jsb2NrXSwgc2NoZW1hKSAmJiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGZvY3VzQmxvY2tQYXRoXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGFzdEJsb2NrID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogKG4pID0+ICFFZGl0b3IuaXNFZGl0b3IobiksXG4gICAgICBhdDogW10sXG4gICAgICByZXZlcnNlOiAhMFxuICAgIH0pKVswXTtcbiAgICBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGJsb2NrKSwgbGFzdEJsb2NrICYmIGlzRXF1YWxUb0VtcHR5RWRpdG9yKFtsYXN0QmxvY2tbMF1dLCBzY2hlbWEpICYmIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogbGFzdEJsb2NrWzFdXG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGluc2VydEJsb2NrT2JqZWN0QWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3QgYmxvY2sgPSB0b1NsYXRlVmFsdWUoW3tcbiAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgIF90eXBlOiBhY3Rpb24uYmxvY2tPYmplY3QubmFtZSxcbiAgICAuLi5hY3Rpb24uYmxvY2tPYmplY3QudmFsdWUgPyBhY3Rpb24uYmxvY2tPYmplY3QudmFsdWUgOiB7fVxuICB9XSwge1xuICAgIHNjaGVtYVR5cGVzOiBjb250ZXh0LnNjaGVtYVxuICB9KVswXTtcbiAgaW5zZXJ0QmxvY2soe1xuICAgIGJsb2NrLFxuICAgIHBsYWNlbWVudDogYWN0aW9uLnBsYWNlbWVudCxcbiAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgc2NoZW1hOiBjb250ZXh0LnNjaGVtYVxuICB9KTtcbn0sIGRlYnVnJDUgPSBkZWJ1Z1dpdGhOYW1lKFwiQVBJOmVkaXRhYmxlXCIpO1xuZnVuY3Rpb24gY3JlYXRlRWRpdGFibGVBUEkoZWRpdG9yLCBlZGl0b3JBY3Rvcikge1xuICBjb25zdCB0eXBlcyA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWE7XG4gIHJldHVybiB7XG4gICAgZm9jdXM6ICgpID0+IHtcbiAgICAgIFJlYWN0RWRpdG9yLmZvY3VzKGVkaXRvcik7XG4gICAgfSxcbiAgICBibHVyOiAoKSA9PiB7XG4gICAgICBSZWFjdEVkaXRvci5ibHVyKGVkaXRvcik7XG4gICAgfSxcbiAgICB0b2dnbGVNYXJrOiAobWFyaykgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgICAgICAgIGRlY29yYXRvcjogbWFya1xuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdG9nZ2xlTGlzdDogKGxpc3RTdHlsZSkgPT4ge1xuICAgICAgZWRpdG9yLnB0ZVRvZ2dsZUxpc3RJdGVtKGxpc3RTdHlsZSk7XG4gICAgfSxcbiAgICB0b2dnbGVCbG9ja1N0eWxlOiAoYmxvY2tTdHlsZSkgPT4ge1xuICAgICAgZWRpdG9yLnB0ZVRvZ2dsZUJsb2NrU3R5bGUoYmxvY2tTdHlsZSk7XG4gICAgfSxcbiAgICBpc01hcmtBY3RpdmU6IChtYXJrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaXNEZWNvcmF0b3JBY3RpdmUoe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBkZWNvcmF0b3I6IG1hcmtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihlcnIpLCAhMTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1hcmtzOiAoKSA9PiAoe1xuICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICB9KS5tYXJrcyB8fCBbXSxcbiAgICB1bmRvOiAoKSA9PiBlZGl0b3IudW5kbygpLFxuICAgIHJlZG86ICgpID0+IGVkaXRvci5yZWRvKCksXG4gICAgc2VsZWN0OiAoc2VsZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBzbGF0ZVNlbGVjdGlvbiA9IHRvU2xhdGVSYW5nZShzZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICBzbGF0ZVNlbGVjdGlvbiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2xhdGVTZWxlY3Rpb24pIDogVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9LFxuICAgIGZvY3VzQmxvY2s6ICgpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgIHJldHVybiBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF07XG4gICAgICB9XG4gICAgfSxcbiAgICBmb2N1c0NoaWxkOiAoKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBibG9jayA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSk7XG4gICAgICAgIGlmIChibG9jayAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKVxuICAgICAgICAgIHJldHVybiBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF0uY2hpbGRyZW5bZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoWzFdXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluc2VydENoaWxkOiAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVkaXRvciBoYXMgbm8gc2VsZWN0aW9uXCIpO1xuICAgICAgY29uc3QgW2ZvY3VzQmxvY2tdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksXG4gICAgICAgIG1hdGNoOiAobikgPT4gbi5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZVxuICAgICAgfSkpWzBdIHx8IFt2b2lkIDBdO1xuICAgICAgaWYgKCFmb2N1c0Jsb2NrKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmb2N1c2VkIHRleHQgYmxvY2tcIik7XG4gICAgICBpZiAodHlwZS5uYW1lICE9PSB0eXBlcy5zcGFuLm5hbWUgJiYgIXR5cGVzLmlubGluZU9iamVjdHMuc29tZSgodCkgPT4gdC5uYW1lID09PSB0eXBlLm5hbWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHR5cGUgY2Fubm90IGJlIGluc2VydGVkIGFzIGEgY2hpbGQgdG8gYSB0ZXh0IGJsb2NrXCIpO1xuICAgICAgY29uc3QgY2hpbGQgPSB0b1NsYXRlVmFsdWUoW3tcbiAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICBfdHlwZTogdHlwZXMuYmxvY2submFtZSxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgIF90eXBlOiB0eXBlLm5hbWUsXG4gICAgICAgICAgLi4udmFsdWUgfHwge31cbiAgICAgICAgfV1cbiAgICAgIH1dLCB7XG4gICAgICAgIHNjaGVtYVR5cGVzOiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hXG4gICAgICB9KVswXS5jaGlsZHJlblswXSwgZm9jdXNDaGlsZFBhdGggPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMiksIGlzU3Bhbk5vZGUgPSBjaGlsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lLCBmb2N1c05vZGUgPSBOb2RlLmdldChlZGl0b3IsIGZvY3VzQ2hpbGRQYXRoKTtcbiAgICAgIHJldHVybiBpc1NwYW5Ob2RlICYmIGZvY3VzTm9kZS5fdHlwZSAhPT0gdHlwZXMuc3Bhbi5uYW1lICYmIChkZWJ1ZyQ1KFwiSW5zZXJ0aW5nIHNwYW4gY2hpbGQgbmV4dCB0byBpbmxpbmUgb2JqZWN0IGNoaWxkLCBtb3Zpbmcgc2VsZWN0aW9uICsgMVwiKSwgZWRpdG9yLm1vdmUoe1xuICAgICAgICBkaXN0YW5jZTogMSxcbiAgICAgICAgdW5pdDogXCJjaGFyYWN0ZXJcIlxuICAgICAgfSkpLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgICAgc2VsZWN0OiAhMCxcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpPy5mb2N1cy5wYXRoIHx8IFtdO1xuICAgIH0sXG4gICAgaW5zZXJ0QmxvY2s6ICh0eXBlLCB2YWx1ZSkgPT4gKGluc2VydEJsb2NrT2JqZWN0QWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBrZXlHZW5lcmF0b3I6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgIHNjaGVtYTogdHlwZXNcbiAgICAgIH0sXG4gICAgICBhY3Rpb246IHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnQgYmxvY2sgb2JqZWN0XCIsXG4gICAgICAgIGJsb2NrT2JqZWN0OiB7XG4gICAgICAgICAgbmFtZTogdHlwZS5uYW1lLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlbWVudDogXCJhdXRvXCIsXG4gICAgICAgIGVkaXRvclxuICAgICAgfVxuICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpPy5mb2N1cy5wYXRoID8/IFtdKSxcbiAgICBoYXNCbG9ja1N0eWxlOiAoc3R5bGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IucHRlSGFzQmxvY2tTdHlsZShzdHlsZSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFzTGlzdFN0eWxlOiAobGlzdFN0eWxlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLnB0ZUhhc0xpc3RTdHlsZShsaXN0U3R5bGUpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzVm9pZDogKGVsZW1lbnQpID0+ICFbdHlwZXMuYmxvY2submFtZSwgdHlwZXMuc3Bhbi5uYW1lXS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSxcbiAgICBmaW5kQnlQYXRoOiAocGF0aCkgPT4ge1xuICAgICAgY29uc3Qgc2xhdGVQYXRoID0gdG9TbGF0ZVJhbmdlKHtcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9XG4gICAgICB9LCBlZGl0b3IpO1xuICAgICAgaWYgKHNsYXRlUGF0aCkge1xuICAgICAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNsYXRlUGF0aC5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrUGF0aCAmJiB0eXBlb2YgYmxvY2suX2tleSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxICYmIHNsYXRlUGF0aC5mb2N1cy5wYXRoLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBbZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdHlwZXMuYmxvY2submFtZSlbMF0sIFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgIH1dXTtcbiAgICAgICAgICBjb25zdCBwdEJsb2NrID0gZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpWzBdO1xuICAgICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2socHRCbG9jaykpIHtcbiAgICAgICAgICAgIGNvbnN0IHB0Q2hpbGQgPSBwdEJsb2NrLmNoaWxkcmVuW3NsYXRlUGF0aC5mb2N1cy5wYXRoWzFdXTtcbiAgICAgICAgICAgIGlmIChwdENoaWxkKVxuICAgICAgICAgICAgICByZXR1cm4gW3B0Q2hpbGQsIFt7XG4gICAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBwdENoaWxkLl9rZXlcbiAgICAgICAgICAgICAgfV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFt2b2lkIDAsIHZvaWQgMF07XG4gICAgfSxcbiAgICBmaW5kRE9NTm9kZTogKGVsZW1lbnQpID0+IHtcbiAgICAgIGxldCBub2RlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW2l0ZW1dID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IFtdLFxuICAgICAgICAgIG1hdGNoOiAobikgPT4gbi5fa2V5ID09PSBlbGVtZW50Ll9rZXlcbiAgICAgICAgfSkgfHwgW10pWzBdIHx8IFt2b2lkIDBdO1xuICAgICAgICBub2RlID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgaXRlbSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgYWN0aXZlQW5ub3RhdGlvbnM6ICgpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGgubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWN0aXZlQW5ub3RhdGlvbnMgPSBbXSwgc3BhbnMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBUZXh0LmlzVGV4dChub2RlKSAmJiBub2RlLm1hcmtzICE9PSB2b2lkIDAgJiYgQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiBub2RlLm1hcmtzLmxlbmd0aCA+IDBcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgW3NwYW4sIHBhdGhdIG9mIHNwYW5zKSB7XG4gICAgICAgICAgY29uc3QgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCwge1xuICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLm1hcmtEZWZzPy5mb3JFYWNoKChkZWYpID0+IHtcbiAgICAgICAgICAgIFRleHQuaXNUZXh0KHNwYW4pICYmIHNwYW4ubWFya3MgJiYgQXJyYXkuaXNBcnJheShzcGFuLm1hcmtzKSAmJiBzcGFuLm1hcmtzLmluY2x1ZGVzKGRlZi5fa2V5KSAmJiBhY3RpdmVBbm5vdGF0aW9ucy5wdXNoKGRlZik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGl2ZUFubm90YXRpb25zO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzQW5ub3RhdGlvbkFjdGl2ZTogKGFubm90YXRpb25UeXBlKSA9PiBpc0Fubm90YXRpb25BY3RpdmUoe1xuICAgICAgZWRpdG9yLFxuICAgICAgYW5ub3RhdGlvbjoge1xuICAgICAgICBuYW1lOiBhbm5vdGF0aW9uVHlwZVxuICAgICAgfVxuICAgIH0pLFxuICAgIGFkZEFubm90YXRpb246ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgbGV0IHBhdGhzO1xuICAgICAgcmV0dXJuIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIHBhdGhzID0gYWRkQW5ub3RhdGlvbkFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICBrZXlHZW5lcmF0b3I6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IsXG4gICAgICAgICAgICBzY2hlbWE6IHR5cGVzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhY3Rpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5hZGRcIixcbiAgICAgICAgICAgIGFubm90YXRpb246IHtcbiAgICAgICAgICAgICAgbmFtZTogdHlwZS5uYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgPz8ge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpLCBwYXRocztcbiAgICB9LFxuICAgIGRlbGV0ZTogKHNlbGVjdGlvbiwgb3B0aW9ucykgPT4ge1xuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRvU2xhdGVSYW5nZShzZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICAgIGlmICghKHJhbmdlICYmIHJhbmdlLmFuY2hvci5wYXRoLmxlbmd0aCA+IDAgJiYgcmFuZ2UuZm9jdXMucGF0aC5sZW5ndGggPiAwKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJhbmdlXCIpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnM/Lm1vZGUgfHwgb3B0aW9ucz8ubW9kZSA9PT0gXCJzZWxlY3RlZFwiKSB7XG4gICAgICAgICAgICBkZWJ1ZyQ1KFwiRGVsZXRpbmcgY29udGVudCBpbiBzZWxlY3Rpb25cIiksIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICAgIGhhbmdpbmc6ICEwLFxuICAgICAgICAgICAgICB2b2lkczogITBcbiAgICAgICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0aW9ucz8ubW9kZSA9PT0gXCJibG9ja3NcIiAmJiAoZGVidWckNShcIkRlbGV0aW5nIGJsb2NrcyB0b3VjaGVkIGJ5IHNlbGVjdGlvblwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIHZvaWRzOiAhMCxcbiAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpIHx8ICFlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgRWxlbWVudCQxLmlzRWxlbWVudChub2RlKVxuICAgICAgICAgIH0pKSwgb3B0aW9ucz8ubW9kZSA9PT0gXCJjaGlsZHJlblwiICYmIChkZWJ1ZyQ1KFwiRGVsZXRpbmcgY2hpbGRyZW4gdG91Y2hlZCBieSBzZWxlY3Rpb25cIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICB2b2lkczogITAsXG4gICAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IG5vZGUuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSB8fCAvLyBUZXh0IGNoaWxkcmVuXG4gICAgICAgICAgICAhZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmIEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSlcbiAgICAgICAgICB9KSksIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgKGVkaXRvci5jaGlsZHJlbiA9IFtlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgICAgICAgfSldKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUFubm90YXRpb246ICh0eXBlKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJhbm5vdGF0aW9uLnJlbW92ZVwiLFxuICAgICAgICAgIGFubm90YXRpb246IHtcbiAgICAgICAgICAgIG5hbWU6IHR5cGUubmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGlvbjogKCkgPT4ge1xuICAgICAgbGV0IHB0UmFuZ2UgPSBudWxsO1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLmdldChlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgcHRSYW5nZSA9IHRvUG9ydGFibGVUZXh0UmFuZ2UoZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIGVkaXRvci5zZWxlY3Rpb24sIHR5cGVzKSwgU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRS5zZXQoZWRpdG9yLnNlbGVjdGlvbiwgcHRSYW5nZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHRSYW5nZTtcbiAgICB9LFxuICAgIGdldFZhbHVlOiAoKSA9PiBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSxcbiAgICBpc0NvbGxhcHNlZFNlbGVjdGlvbjogKCkgPT4gISFlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pLFxuICAgIGlzRXhwYW5kZWRTZWxlY3Rpb246ICgpID0+ICEhZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKGVkaXRvci5zZWxlY3Rpb24pLFxuICAgIGluc2VydEJyZWFrOiAoKSA9PiB7XG4gICAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfSxcbiAgICBnZXRGcmFnbWVudDogKCkgPT4gZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmdldEZyYWdtZW50KCksIHR5cGVzLmJsb2NrLm5hbWUpLFxuICAgIGlzU2VsZWN0aW9uc092ZXJsYXBwaW5nOiAoc2VsZWN0aW9uQSwgc2VsZWN0aW9uQikgPT4ge1xuICAgICAgY29uc3QgcmFuZ2VBID0gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbkEsIGVkaXRvciksIHJhbmdlQiA9IHRvU2xhdGVSYW5nZShzZWxlY3Rpb25CLCBlZGl0b3IpO1xuICAgICAgcmV0dXJuIFJhbmdlLmlzUmFuZ2UocmFuZ2VBKSAmJiBSYW5nZS5pc1JhbmdlKHJhbmdlQikgJiYgUmFuZ2UuaW5jbHVkZXMocmFuZ2VBLCByYW5nZUIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW5ub3RhdGlvbkFjdGl2ZSh7XG4gIGVkaXRvcixcbiAgYW5ub3RhdGlvblxufSkge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLmxlbmd0aCA8IDIpXG4gICAgcmV0dXJuICExO1xuICB0cnkge1xuICAgIGNvbnN0IHNwYW5zID0gWy4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbWF0Y2g6IChub2RlKSA9PiBUZXh0LmlzVGV4dChub2RlKVxuICAgIH0pXTtcbiAgICBpZiAoc3BhbnMubGVuZ3RoID09PSAwIHx8IHNwYW5zLnNvbWUoKFtzcGFuXSkgPT4gIWlzUG9ydGFibGVUZXh0U3BhbiQxKHNwYW4pIHx8ICFzcGFuLm1hcmtzIHx8IHNwYW4ubWFya3M/Lmxlbmd0aCA9PT0gMCkpIHJldHVybiAhMTtcbiAgICBjb25zdCBzZWxlY3Rpb25NYXJrRGVmcyA9IHNwYW5zLnJlZHVjZSgoYWNjTWFya0RlZnMsIFssIHBhdGhdKSA9PiB7XG4gICAgICBjb25zdCBbYmxvY2tdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoLCB7XG4gICAgICAgIGRlcHRoOiAxXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGJsb2NrLm1hcmtEZWZzID8gWy4uLmFjY01hcmtEZWZzLCAuLi5ibG9jay5tYXJrRGVmc10gOiBhY2NNYXJrRGVmcztcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNwYW5zLmV2ZXJ5KChbc3Bhbl0pID0+IGlzUG9ydGFibGVUZXh0U3BhbiQxKHNwYW4pID8gc3Bhbi5tYXJrcz8ubWFwKChtYXJrS2V5KSA9PiBzZWxlY3Rpb25NYXJrRGVmcy5maW5kKChkZWYpID0+IGRlZj8uX2tleSA9PT0gbWFya0tleSk/Ll90eXBlKT8uaW5jbHVkZXMoYW5ub3RhdGlvbi5uYW1lKSA6ICExKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jb25zdCBhZGRBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gYWN0aW9uLmVkaXRvciwge1xuICAgIHNlbGVjdGlvbjogb3JpZ2luYWxTZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgbGV0IHBhdGhzO1xuICBpZiAob3JpZ2luYWxTZWxlY3Rpb24gJiYgKFJhbmdlLmlzQ29sbGFwc2VkKG9yaWdpbmFsU2VsZWN0aW9uKSAmJiAoZWRpdG9yLnB0ZUV4cGFuZFRvV29yZCgpLCBlZGl0b3Iub25DaGFuZ2UoKSksIGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgbGV0IHNwYW5QYXRoLCBtYXJrRGVmUGF0aDtcbiAgICBjb25zdCBtYXJrRGVmUGF0aHMgPSBbXTtcbiAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpLFxuICAgICAgcmV2ZXJzZTogUmFuZ2UuaXNCYWNrd2FyZChlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdIG9mIHNlbGVjdGVkQmxvY2tzKSB7XG4gICAgICBpZiAoYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBibG9jay5jaGlsZHJlblswXS50ZXh0ID09PSBcIlwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGFubm90YXRpb25LZXkgPSBjb250ZXh0LmtleUdlbmVyYXRvcigpLCBtYXJrRGVmcyA9IGJsb2NrLm1hcmtEZWZzID8/IFtdO1xuICAgICAgbWFya0RlZnMuZmluZCgobWFya0RlZikgPT4gbWFya0RlZi5fdHlwZSA9PT0gYWN0aW9uLmFubm90YXRpb24ubmFtZSAmJiBtYXJrRGVmLl9rZXkgPT09IGFubm90YXRpb25LZXkpID09PSB2b2lkIDAgJiYgKFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIG1hcmtEZWZzOiBbLi4ubWFya0RlZnMsIHtcbiAgICAgICAgICBfdHlwZTogYWN0aW9uLmFubm90YXRpb24ubmFtZSxcbiAgICAgICAgICBfa2V5OiBhbm5vdGF0aW9uS2V5LFxuICAgICAgICAgIC4uLmFjdGlvbi5hbm5vdGF0aW9uLnZhbHVlXG4gICAgICAgIH1dXG4gICAgICB9LCB7XG4gICAgICAgIGF0OiBibG9ja1BhdGhcbiAgICAgIH0pLCBtYXJrRGVmUGF0aCA9IFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwibWFya0RlZnNcIiwge1xuICAgICAgICBfa2V5OiBhbm5vdGF0aW9uS2V5XG4gICAgICB9XSwgUmFuZ2UuaXNCYWNrd2FyZChlZGl0b3Iuc2VsZWN0aW9uKSA/IG1hcmtEZWZQYXRocy51bnNoaWZ0KG1hcmtEZWZQYXRoKSA6IG1hcmtEZWZQYXRocy5wdXNoKG1hcmtEZWZQYXRoKSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSwge1xuICAgICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICAgIHNwbGl0OiAhMFxuICAgICAgfSk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgICAgZm9yIChjb25zdCBbc3BhbiwgcGF0aF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFlZGl0b3IuaXNUZXh0U3BhbihzcGFuKSB8fCAhUmFuZ2UuaW5jbHVkZXMoZWRpdG9yLnNlbGVjdGlvbiwgcGF0aCkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IG1hcmtzID0gc3Bhbi5tYXJrcyA/PyBbXSwgZXhpc3RpbmdTYW1lVHlwZUFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiBtYXJrRGVmcy5zb21lKChtYXJrRGVmKSA9PiBtYXJrRGVmLl9rZXkgPT09IG1hcmsgJiYgbWFya0RlZi5fdHlwZSA9PT0gYWN0aW9uLmFubm90YXRpb24ubmFtZSkpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBbLi4ubWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZXhpc3RpbmdTYW1lVHlwZUFubm90YXRpb25zLmluY2x1ZGVzKG1hcmspKSwgYW5ub3RhdGlvbktleV1cbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBzcGFuUGF0aCA9IFt7XG4gICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBfa2V5OiBzcGFuLl9rZXlcbiAgICAgICAgfV07XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtEZWZQYXRoICYmIHNwYW5QYXRoICYmIChwYXRocyA9IHtcbiAgICAgIG1hcmtEZWZQYXRoLFxuICAgICAgbWFya0RlZlBhdGhzLFxuICAgICAgc3BhblBhdGhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcGF0aHM7XG59LCByZW1vdmVBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gYWN0aW9uLmVkaXRvcjtcbiAgaWYgKGRlYnVnJDUoXCJSZW1vdmluZyBhbm5vdGF0aW9uXCIsIGFjdGlvbi5hbm5vdGF0aW9uLm5hbWUpLCAhIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICAgICAgZGVwdGg6IDFcbiAgICAgIH0pO1xuICAgICAgaWYgKCFlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwb3RlbnRpYWxBbm5vdGF0aW9ucyA9IChibG9jay5tYXJrRGVmcyA/PyBbXSkuZmlsdGVyKChtYXJrRGVmKSA9PiBtYXJrRGVmLl90eXBlID09PSBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lKSwgW3NlbGVjdGVkQ2hpbGQsIHNlbGVjdGVkQ2hpbGRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgICBkZXB0aDogMlxuICAgICAgfSk7XG4gICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKHNlbGVjdGVkQ2hpbGQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBhbm5vdGF0aW9uVG9SZW1vdmUgPSBzZWxlY3RlZENoaWxkLm1hcmtzPy5maW5kKChtYXJrKSA9PiBwb3RlbnRpYWxBbm5vdGF0aW9ucy5zb21lKChtYXJrRGVmKSA9PiBtYXJrRGVmLl9rZXkgPT09IG1hcmspKTtcbiAgICAgIGlmICghYW5ub3RhdGlvblRvUmVtb3ZlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBwcmV2aW91c1NwYW5zV2l0aFNhbWVBbm5vdGF0aW9uID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoLCB7XG4gICAgICAgIHJldmVyc2U6ICEwXG4gICAgICB9KSlcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBQYXRoLmlzQmVmb3JlKGNoaWxkUGF0aCwgc2VsZWN0ZWRDaGlsZFBhdGgpKVxuICAgICAgICAgIGlmIChjaGlsZC5tYXJrcz8uaW5jbHVkZXMoYW5ub3RhdGlvblRvUmVtb3ZlKSlcbiAgICAgICAgICAgIHByZXZpb3VzU3BhbnNXaXRoU2FtZUFubm90YXRpb24ucHVzaChbY2hpbGQsIGNoaWxkUGF0aF0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgY29uc3QgbmV4dFNwYW5zV2l0aFNhbWVBbm5vdGF0aW9uID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoKSlcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBQYXRoLmlzQWZ0ZXIoY2hpbGRQYXRoLCBzZWxlY3RlZENoaWxkUGF0aCkpXG4gICAgICAgICAgaWYgKGNoaWxkLm1hcmtzPy5pbmNsdWRlcyhhbm5vdGF0aW9uVG9SZW1vdmUpKVxuICAgICAgICAgICAgbmV4dFNwYW5zV2l0aFNhbWVBbm5vdGF0aW9uLnB1c2goW2NoaWxkLCBjaGlsZFBhdGhdKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIFsuLi5wcmV2aW91c1NwYW5zV2l0aFNhbWVBbm5vdGF0aW9uLCBbc2VsZWN0ZWRDaGlsZCwgc2VsZWN0ZWRDaGlsZFBhdGhdLCAuLi5uZXh0U3BhbnNXaXRoU2FtZUFubm90YXRpb25dKVxuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBjaGlsZC5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiBtYXJrICE9PSBhbm5vdGF0aW9uVG9SZW1vdmUpXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSxcbiAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICBoYW5naW5nOiAhMFxuICAgICAgfSk7XG4gICAgICBjb25zdCBibG9ja3MgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSBvZiBibG9ja3MpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoKTtcbiAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSB8fCAhUmFuZ2UuaW5jbHVkZXMoZWRpdG9yLnNlbGVjdGlvbiwgY2hpbGRQYXRoKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IG1hcmtEZWZzID0gYmxvY2subWFya0RlZnMgPz8gW10sIG1hcmtzID0gY2hpbGQubWFya3MgPz8gW10sIG1hcmtzV2l0aG91dEFubm90YXRpb24gPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IG1hcmtEZWZzLmZpbmQoKG1hcmtEZWYyKSA9PiBtYXJrRGVmMi5fa2V5ID09PSBtYXJrKT8uX3R5cGUgIT09IGFjdGlvbi5hbm5vdGF0aW9uLm5hbWUpO1xuICAgICAgICAgIG1hcmtzV2l0aG91dEFubm90YXRpb24ubGVuZ3RoICE9PSBtYXJrcy5sZW5ndGggJiYgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtzOiBtYXJrc1dpdGhvdXRBbm5vdGF0aW9uXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxufSwgdG9nZ2xlQW5ub3RhdGlvbkFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGlmIChpc0Fubm90YXRpb25BY3RpdmUoe1xuICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvcixcbiAgICBhbm5vdGF0aW9uOiB7XG4gICAgICBuYW1lOiBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lXG4gICAgfVxuICB9KSlcbiAgICByZW1vdmVBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgY29udGV4dCxcbiAgICAgIGFjdGlvbjoge1xuICAgICAgICB0eXBlOiBcImFubm90YXRpb24ucmVtb3ZlXCIsXG4gICAgICAgIGFubm90YXRpb246IGFjdGlvbi5hbm5vdGF0aW9uLFxuICAgICAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3JcbiAgICAgIH1cbiAgICB9KTtcbiAgZWxzZVxuICAgIHJldHVybiBhZGRBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgY29udGV4dCxcbiAgICAgIGFjdGlvbjoge1xuICAgICAgICB0eXBlOiBcImFubm90YXRpb24uYWRkXCIsXG4gICAgICAgIGFubm90YXRpb246IGFjdGlvbi5hbm5vdGF0aW9uLFxuICAgICAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3JcbiAgICAgIH1cbiAgICB9KTtcbn0sIGluc2VydEJyZWFrQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3Qga2V5R2VuZXJhdG9yID0gY29udGV4dC5rZXlHZW5lcmF0b3IsIHNjaGVtYSA9IGNvbnRleHQuc2NoZW1hLCBlZGl0b3IgPSBhY3Rpb24uZWRpdG9yO1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBbZm9jdXNTcGFuXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMsXG4gICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICB2b2lkczogITFcbiAgfSkpWzBdID8/IFt2b2lkIDBdLCBmb2N1c0RlY29yYXRvcnMgPSBmb2N1c1NwYW4ubWFya3M/LmZpbHRlcigobWFyaykgPT4gc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUgPT09IG1hcmspKSA/PyBbXSwgZm9jdXNBbm5vdGF0aW9ucyA9IGZvY3VzU3Bhbi5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUgPT09IG1hcmspKSA/PyBbXSwgZm9jdXNCbG9ja1BhdGggPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksIGZvY3VzQmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCk7XG4gIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykpIHtcbiAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhlZGl0b3Iuc2VsZWN0aW9uKSwgYXRUaGVTdGFydE9mQmxvY2sgPSBpc0VxdWFsKGVuZCwge1xuICAgICAgcGF0aDogWy4uLmZvY3VzQmxvY2tQYXRoLCAwXSxcbiAgICAgIG9mZnNldDogMFxuICAgIH0pO1xuICAgIGlmIChhdFRoZVN0YXJ0T2ZCbG9jayAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgICAgRWRpdG9yLmluc2VydE5vZGUoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgZGVjb3JhdG9yczogZm9jdXNBbm5vdGF0aW9ucy5sZW5ndGggPT09IDAgPyBmb2N1c0RlY29yYXRvcnMgOiBbXSxcbiAgICAgICAgbGlzdEl0ZW06IGZvY3VzQmxvY2subGlzdEl0ZW0sXG4gICAgICAgIGxldmVsOiBmb2N1c0Jsb2NrLmxldmVsXG4gICAgICB9KSk7XG4gICAgICBjb25zdCBbbmV4dEJsb2NrUGF0aF0gPSBQYXRoLm5leHQoZm9jdXNCbG9ja1BhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IFtuZXh0QmxvY2tQYXRoLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBbbmV4dEJsb2NrUGF0aCwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0Rm9jdXNCbG9ja0NoaWxkID0gZm9jdXNCbG9jay5jaGlsZHJlbltmb2N1c0Jsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDFdLCBhdFRoZUVuZE9mQmxvY2sgPSBpc0VxdWFsKHN0YXJ0LCB7XG4gICAgICBwYXRoOiBbLi4uZm9jdXNCbG9ja1BhdGgsIGZvY3VzQmxvY2suY2hpbGRyZW4ubGVuZ3RoIC0gMV0sXG4gICAgICBvZmZzZXQ6IGVkaXRvci5pc1RleHRTcGFuKGxhc3RGb2N1c0Jsb2NrQ2hpbGQpID8gbGFzdEZvY3VzQmxvY2tDaGlsZC50ZXh0Lmxlbmd0aCA6IDBcbiAgICB9KTtcbiAgICBpZiAoYXRUaGVFbmRPZkJsb2NrICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICBkZWNvcmF0b3JzOiBbXSxcbiAgICAgICAgbGlzdEl0ZW06IGZvY3VzQmxvY2subGlzdEl0ZW0sXG4gICAgICAgIGxldmVsOiBmb2N1c0Jsb2NrLmxldmVsXG4gICAgICB9KSk7XG4gICAgICBjb25zdCBbbmV4dEJsb2NrUGF0aF0gPSBQYXRoLm5leHQoZm9jdXNCbG9ja1BhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IFtuZXh0QmxvY2tQYXRoLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBbbmV4dEJsb2NrUGF0aCwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWF0VGhlU3RhcnRPZkJsb2NrICYmICFhdFRoZUVuZE9mQmxvY2spIHtcbiAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgW25leHROb2RlLCBuZXh0Tm9kZVBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBQYXRoLm5leHQoZm9jdXNCbG9ja1BhdGgpLCB7XG4gICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgIHBhdGg6IFsuLi5uZXh0Tm9kZVBhdGgsIDBdLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgcGF0aDogWy4uLm5leHROb2RlUGF0aCwgMF0sXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBlZGl0b3IuaXNUZXh0QmxvY2sobmV4dE5vZGUpICYmIG5leHROb2RlLm1hcmtEZWZzICYmIG5leHROb2RlLm1hcmtEZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBuZXdNYXJrRGVmS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHByZXZOb2RlU3BhbnMgPSBBcnJheS5mcm9tKE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCkpLm1hcCgoZW50cnkpID0+IGVudHJ5WzBdKS5maWx0ZXIoKG5vZGUpID0+IGVkaXRvci5pc1RleHRTcGFuKG5vZGUpKSwgY2hpbGRyZW4gPSBOb2RlLmNoaWxkcmVuKGVkaXRvciwgbmV4dE5vZGVQYXRoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCFlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbWFya3MgPSBjaGlsZC5tYXJrcyA/PyBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWFyayBvZiBtYXJrcylcbiAgICAgICAgICAgICAgc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUgPT09IG1hcmspIHx8IHByZXZOb2RlU3BhbnMuc29tZSgocHJldk5vZGVTcGFuKSA9PiBwcmV2Tm9kZVNwYW4ubWFya3M/LmluY2x1ZGVzKG1hcmspKSAmJiAhbmV3TWFya0RlZktleXMuaGFzKG1hcmspICYmIG5ld01hcmtEZWZLZXlzLnNldChtYXJrLCBrZXlHZW5lcmF0b3IoKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdNYXJrcyA9IG1hcmtzLm1hcCgobWFyaykgPT4gbmV3TWFya0RlZktleXMuZ2V0KG1hcmspID8/IG1hcmspO1xuICAgICAgICAgICAgaXNFcXVhbChtYXJrcywgbmV3TWFya3MpIHx8IFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hcmtzOiBuZXdNYXJrc1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV3TWFya0RlZnMgPSBuZXh0Tm9kZS5tYXJrRGVmcy5tYXAoKG1hcmtEZWYpID0+ICh7XG4gICAgICAgICAgICAuLi5tYXJrRGVmLFxuICAgICAgICAgICAgX2tleTogbmV3TWFya0RlZktleXMuZ2V0KG1hcmtEZWYuX2tleSkgPz8gbWFya0RlZi5fa2V5XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGlzRXF1YWwobmV4dE5vZGUubWFya0RlZnMsIG5ld01hcmtEZWZzKSB8fCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya0RlZnM6IG5ld01hcmtEZWZzXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IG5leHROb2RlUGF0aCxcbiAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn0sIGluc2VydFNvZnRCcmVha0FjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGluc2VydEJyZWFrQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgIGNvbnRleHQsXG4gICAgYWN0aW9uOiB7XG4gICAgICAuLi5hY3Rpb24sXG4gICAgICB0eXBlOiBcImluc2VydCBicmVha1wiXG4gICAgfVxuICB9KTtcbn0sIGluc2VydFNwYW5BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBwZXJmb3JtIGFjdGlvbiB3aXRob3V0IHNlbGVjdGlvblwiLCBhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbZm9jdXNCbG9jaywgZm9jdXNCbG9ja1BhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLFxuICAgIG1hdGNoOiAobm9kZSkgPT4gYWN0aW9uLmVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICB9KSlbMF0gPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgaWYgKCFmb2N1c0Jsb2NrIHx8ICFmb2N1c0Jsb2NrUGF0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gcGVyZm9ybSBhY3Rpb24gd2l0aG91dCBmb2N1cyBibG9ja1wiLCBhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBtYXJrRGVmcyA9IGZvY3VzQmxvY2subWFya0RlZnMgPz8gW10sIGFubm90YXRpb25zID0gYWN0aW9uLmFubm90YXRpb25zID8gYWN0aW9uLmFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4gKHtcbiAgICBfdHlwZTogYW5ub3RhdGlvbi5uYW1lLFxuICAgIF9rZXk6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgLi4uYW5ub3RhdGlvbi52YWx1ZVxuICB9KSkgOiB2b2lkIDA7XG4gIGFubm90YXRpb25zICYmIGFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgVHJhbnNmb3Jtcy5zZXROb2RlcyhhY3Rpb24uZWRpdG9yLCB7XG4gICAgbWFya0RlZnM6IFsuLi5tYXJrRGVmcywgLi4uYW5ub3RhdGlvbnNdXG4gIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICB0ZXh0OiBhY3Rpb24udGV4dCxcbiAgICBtYXJrczogWy4uLmFubm90YXRpb25zPy5tYXAoKGFubm90YXRpb24pID0+IGFubm90YXRpb24uX2tleSkgPz8gW10sIC4uLmFjdGlvbi5kZWNvcmF0b3JzID8/IFtdXVxuICB9KTtcbn0sIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zID0ge1xuICBcImFubm90YXRpb24uYWRkXCI6IGFkZEFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJhbm5vdGF0aW9uLnJlbW92ZVwiOiByZW1vdmVBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiYW5ub3RhdGlvbi50b2dnbGVcIjogdG9nZ2xlQW5ub3RhdGlvbkFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImRlY29yYXRvci5hZGRcIjogYWRkRGVjb3JhdG9yQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiZGVjb3JhdG9yLnJlbW92ZVwiOiByZW1vdmVEZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJkZWNvcmF0b3IudG9nZ2xlXCI6IHRvZ2dsZURlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBmb2N1czogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIFJlYWN0RWRpdG9yLmZvY3VzKGFjdGlvbi5lZGl0b3IpO1xuICB9LFxuICBcInNldCBibG9ja1wiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIGFjdGlvbi5wYXRocykge1xuICAgICAgY29uc3QgYXQgPSB0b1NsYXRlUmFuZ2Uoe1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0sIGFjdGlvbi5lZGl0b3IpO1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhhY3Rpb24uZWRpdG9yLCB7XG4gICAgICAgIC4uLmFjdGlvbi5zdHlsZSA/IHtcbiAgICAgICAgICBzdHlsZTogYWN0aW9uLnN0eWxlXG4gICAgICAgIH0gOiB7fSxcbiAgICAgICAgLi4uYWN0aW9uLmxpc3RJdGVtID8ge1xuICAgICAgICAgIGxpc3RJdGVtOiBhY3Rpb24ubGlzdEl0ZW1cbiAgICAgICAgfSA6IHt9LFxuICAgICAgICAuLi5hY3Rpb24ubGV2ZWwgPyB7XG4gICAgICAgICAgbGV2ZWw6IGFjdGlvbi5sZXZlbFxuICAgICAgICB9IDoge31cbiAgICAgIH0sIHtcbiAgICAgICAgYXRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgXCJ1bnNldCBibG9ja1wiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIGFjdGlvbi5wYXRocykge1xuICAgICAgY29uc3QgYXQgPSB0b1NsYXRlUmFuZ2Uoe1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0sIGFjdGlvbi5lZGl0b3IpO1xuICAgICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGFjdGlvbi5lZGl0b3IsIGFjdGlvbi5wcm9wcywge1xuICAgICAgICBhdFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBcImRlbGV0ZSBiYWNrd2FyZFwiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgZGVsZXRlQmFja3dhcmQoYWN0aW9uLmVkaXRvciwgYWN0aW9uLnVuaXQpO1xuICB9LFxuICBcImRlbGV0ZSBmb3J3YXJkXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBkZWxldGVGb3J3YXJkKGFjdGlvbi5lZGl0b3IsIGFjdGlvbi51bml0KTtcbiAgfSxcbiAgXCJkZWxldGUgYmxvY2tcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHJhbmdlID0gdG9TbGF0ZVJhbmdlKHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBhY3Rpb24uYmxvY2tQYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBhY3Rpb24uYmxvY2tQYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9LCBhY3Rpb24uZWRpdG9yKTtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGZpbmQgU2xhdGUgcmFuZ2UgZnJvbSBzZWxlY3Rpb24gcG9pbnRzXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICB9LFxuICBcImRlbGV0ZSB0ZXh0XCI6ICh7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gZnJvbVNsYXRlVmFsdWUoYWN0aW9uLmVkaXRvci5jaGlsZHJlbiwgY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGFjdGlvbi5lZGl0b3IpKSwgYW5jaG9yID0gYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGJsb2NrT2Zmc2V0OiBhY3Rpb24uYW5jaG9yXG4gICAgfSksIGZvY3VzID0gYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGJsb2NrT2Zmc2V0OiBhY3Rpb24uZm9jdXNcbiAgICB9KTtcbiAgICBpZiAoIWFuY2hvciB8fCAhZm9jdXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gZmluZCBhbmNob3Igb3IgZm9jdXMgc2VsZWN0aW9uIHBvaW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0sIGFjdGlvbi5lZGl0b3IpO1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gZmluZCBTbGF0ZSByYW5nZSBmcm9tIHNlbGVjdGlvbiBwb2ludHNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICB9LFxuICBcImluc2VydCBibG9jayBvYmplY3RcIjogaW5zZXJ0QmxvY2tPYmplY3RBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQgYnJlYWtcIjogaW5zZXJ0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQgc29mdCBicmVha1wiOiBpbnNlcnRTb2Z0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQgc3BhblwiOiBpbnNlcnRTcGFuQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0IHRleHRcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGluc2VydFRleHQoYWN0aW9uLmVkaXRvciwgYWN0aW9uLnRleHQpO1xuICB9LFxuICBcImluc2VydCB0ZXh0IGJsb2NrXCI6ICh7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IGJsb2NrID0gdG9TbGF0ZVZhbHVlKFt7XG4gICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsXG4gICAgICBzdHlsZTogY29udGV4dC5zY2hlbWEuc3R5bGVzWzBdLnZhbHVlID8/IFwibm9ybWFsXCIsXG4gICAgICBtYXJrRGVmczogW10sXG4gICAgICBjaGlsZHJlbjogYWN0aW9uLnRleHRCbG9jaz8uY2hpbGRyZW4/Lm1hcCgoY2hpbGQpID0+ICh7XG4gICAgICAgIC4uLmNoaWxkLFxuICAgICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICB9KSkgPz8gW3tcbiAgICAgICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSxcbiAgICAgICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgdGV4dDogXCJcIlxuICAgICAgfV1cbiAgICB9XSwge1xuICAgICAgc2NoZW1hVHlwZXM6IGNvbnRleHQuc2NoZW1hXG4gICAgfSlbMF07XG4gICAgaW5zZXJ0QmxvY2soe1xuICAgICAgYmxvY2ssXG4gICAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgcGxhY2VtZW50OiBhY3Rpb24ucGxhY2VtZW50XG4gICAgfSk7XG4gIH0sXG4gIGVmZmVjdDogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGFjdGlvbi5lZmZlY3QoKTtcbiAgfSxcbiAgcGFzdGU6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBhY3Rpb24uZWRpdG9yLmluc2VydERhdGEoYWN0aW9uLmNsaXBib2FyZERhdGEpO1xuICB9LFxuICBzZWxlY3Q6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSB0b1NsYXRlUmFuZ2UoYWN0aW9uLnNlbGVjdGlvbiwgYWN0aW9uLmVkaXRvcik7XG4gICAgbmV3U2VsZWN0aW9uID8gVHJhbnNmb3Jtcy5zZWxlY3QoYWN0aW9uLmVkaXRvciwgbmV3U2VsZWN0aW9uKSA6IFRyYW5zZm9ybXMuZGVzZWxlY3QoYWN0aW9uLmVkaXRvcik7XG4gIH0sXG4gIHJlc2VsZWN0OiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gYWN0aW9uLmVkaXRvci5zZWxlY3Rpb247XG4gICAgc2VsZWN0aW9uICYmIChUcmFuc2Zvcm1zLnNlbGVjdChhY3Rpb24uZWRpdG9yLCB7XG4gICAgICAuLi5zZWxlY3Rpb25cbiAgICB9KSwgYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24gPSB7XG4gICAgICAuLi5zZWxlY3Rpb25cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHBlcmZvcm1BY3Rpb24oe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJkZWxldGUgYmxvY2tcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWxldGUgYmxvY2tcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkZWxldGUgdGV4dFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlbGV0ZSB0ZXh0XCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0IGJsb2NrIG9iamVjdFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydCBibG9jayBvYmplY3RcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbnNlcnQgc3BhblwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydCBzcGFuXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0IHRleHQgYmxvY2tcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQgdGV4dCBibG9ja1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInNldCBibG9ja1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcInNldCBibG9ja1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInVuc2V0IGJsb2NrXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1widW5zZXQgYmxvY2tcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJlZmZlY3RcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMuZWZmZWN0KHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic2VsZWN0XCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zLnNlbGVjdCh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInJlc2VsZWN0XCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zLnJlc2VsZWN0KHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcGVyZm9ybURlZmF1bHRBY3Rpb24oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwZXJmb3JtRGVmYXVsdEFjdGlvbih7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcImFubm90YXRpb24uYWRkXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiYW5ub3RhdGlvbi5hZGRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJhbm5vdGF0aW9uLnJlbW92ZVwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImFubm90YXRpb24ucmVtb3ZlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiYW5ub3RhdGlvbi50b2dnbGVcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJhbm5vdGF0aW9uLnRvZ2dsZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImRlY29yYXRvci5hZGRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWNvcmF0b3IuYWRkXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVjb3JhdG9yLnJlbW92ZVwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlY29yYXRvci5yZW1vdmVcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkZWNvcmF0b3IudG9nZ2xlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVjb3JhdG9yLnRvZ2dsZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImRlbGV0ZSBiYWNrd2FyZFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlbGV0ZSBiYWNrd2FyZFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImRlbGV0ZSBmb3J3YXJkXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVsZXRlIGZvcndhcmRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmb2N1c1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9ucy5mb2N1cyh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImluc2VydCBicmVha1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydCBicmVha1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImluc2VydCBzb2Z0IGJyZWFrXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0IHNvZnQgYnJlYWtcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbnNlcnQgdGV4dFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydCB0ZXh0XCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMucGFzdGUoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICB9XG59XG5jb25zdCBlZGl0b3JNYWNoaW5lID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGV2ZW50czoge30sXG4gICAgZW1pdHRlZDoge30sXG4gICAgaW5wdXQ6IHt9XG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcImFzc2lnbiBiZWhhdmlvcnNcIjogYXNzaWduKHtcbiAgICAgIGJlaGF2aW9yczogKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ1cGRhdGUgYmVoYXZpb3JzXCIpLCBldmVudC5iZWhhdmlvcnMpXG4gICAgfSksXG4gICAgXCJhc3NpZ24gc2NoZW1hXCI6IGFzc2lnbih7XG4gICAgICBzY2hlbWE6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwidXBkYXRlIHNjaGVtYVwiKSwgZXZlbnQuc2NoZW1hKVxuICAgIH0pLFxuICAgIFwiZW1pdCBwYXRjaCBldmVudFwiOiBlbWl0KCh7XG4gICAgICBldmVudFxuICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJwYXRjaFwiKSwgZXZlbnQpKSxcbiAgICBcImVtaXQgbXV0YXRpb24gZXZlbnRcIjogZW1pdCgoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibXV0YXRpb25cIiksIGV2ZW50KSksXG4gICAgXCJkZWZlciBldmVudFwiOiBhc3NpZ24oe1xuICAgICAgcGVuZGluZ0V2ZW50czogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgW1wicGF0Y2hcIiwgXCJtdXRhdGlvblwiXSksIFsuLi5jb250ZXh0LnBlbmRpbmdFdmVudHMsIGV2ZW50XSlcbiAgICB9KSxcbiAgICBcImVtaXQgcGVuZGluZyBldmVudHNcIjogZW5xdWV1ZUFjdGlvbnMoKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBlbnF1ZXVlXG4gICAgfSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBldmVudCBvZiBjb250ZXh0LnBlbmRpbmdFdmVudHMpXG4gICAgICAgIGVucXVldWUoZW1pdChldmVudCkpO1xuICAgIH0pLFxuICAgIFwiY2xlYXIgcGVuZGluZyBldmVudHNcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdFdmVudHM6IFtdXG4gICAgfSksXG4gICAgXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIjogZW5xdWV1ZUFjdGlvbnMoKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIGVucXVldWVcbiAgICB9KSA9PiB7XG4gICAgICBhc3NlcnRFdmVudChldmVudCwgW1wiYmVoYXZpb3IgZXZlbnRcIl0pO1xuICAgICAgY29uc3QgZGVmYXVsdEFjdGlvbiA9IHtcbiAgICAgICAgLi4uZXZlbnQuYmVoYXZpb3JFdmVudCxcbiAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3JcbiAgICAgIH0sIGV2ZW50QmVoYXZpb3JzID0gY29udGV4dC5iZWhhdmlvcnMuZmlsdGVyKChiZWhhdmlvcikgPT4gYmVoYXZpb3Iub24gPT09IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSk7XG4gICAgICBpZiAoZXZlbnRCZWhhdmlvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVucXVldWUucmFpc2Uoe1xuICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgYWN0aW9uIGludGVuZHNcIixcbiAgICAgICAgICBlZGl0b3I6IGV2ZW50LmVkaXRvcixcbiAgICAgICAgICBhY3Rpb25JbnRlbmRzOiBbZGVmYXVsdEFjdGlvbl1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gZnJvbVNsYXRlVmFsdWUoZXZlbnQuZWRpdG9yLmNoaWxkcmVuLCBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZXZlbnQuZWRpdG9yKSksIHNlbGVjdGlvbiA9IHRvUG9ydGFibGVUZXh0UmFuZ2UodmFsdWUsIGV2ZW50LmVkaXRvci5zZWxlY3Rpb24sIGNvbnRleHQuc2NoZW1hKTtcbiAgICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5hYmxlIHRvIGhhbmRsZSBldmVudCAke2V2ZW50LnR5cGV9IGR1ZSB0byBtaXNzaW5nIHNlbGVjdGlvbmApLCBlbnF1ZXVlLnJhaXNlKHtcbiAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGFjdGlvbiBpbnRlbmRzXCIsXG4gICAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3IsXG4gICAgICAgICAgYWN0aW9uSW50ZW5kczogW2RlZmF1bHRBY3Rpb25dXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBiZWhhdmlvckNvbnRleHQgPSB7XG4gICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH07XG4gICAgICBsZXQgYmVoYXZpb3JPdmVyd3JpdHRlbiA9ICExO1xuICAgICAgZm9yIChjb25zdCBldmVudEJlaGF2aW9yIG9mIGV2ZW50QmVoYXZpb3JzKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFJ1biA9IGV2ZW50QmVoYXZpb3IuZ3VhcmQ/Lih7XG4gICAgICAgICAgY29udGV4dDogYmVoYXZpb3JDb250ZXh0LFxuICAgICAgICAgIGV2ZW50OiBldmVudC5iZWhhdmlvckV2ZW50XG4gICAgICAgIH0pID8/ICEwO1xuICAgICAgICBpZiAoIXNob3VsZFJ1bilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYWN0aW9uSW50ZW5kU2V0cyA9IGV2ZW50QmVoYXZpb3IuYWN0aW9ucy5tYXAoKGFjdGlvblNldCkgPT4gYWN0aW9uU2V0KHtcbiAgICAgICAgICBjb250ZXh0OiBiZWhhdmlvckNvbnRleHQsXG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LmJlaGF2aW9yRXZlbnRcbiAgICAgICAgfSwgc2hvdWxkUnVuKSk7XG4gICAgICAgIGZvciAoY29uc3QgYWN0aW9uSW50ZW5kcyBvZiBhY3Rpb25JbnRlbmRTZXRzKVxuICAgICAgICAgIGJlaGF2aW9yT3ZlcndyaXR0ZW4gPSBiZWhhdmlvck92ZXJ3cml0dGVuIHx8IGFjdGlvbkludGVuZHMubGVuZ3RoID4gMCAmJiBhY3Rpb25JbnRlbmRzLnNvbWUoKGFjdGlvbkludGVuZCkgPT4gYWN0aW9uSW50ZW5kLnR5cGUgIT09IFwiZWZmZWN0XCIpLCBlbnF1ZXVlLnJhaXNlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgYWN0aW9uIGludGVuZHNcIixcbiAgICAgICAgICAgIGVkaXRvcjogZXZlbnQuZWRpdG9yLFxuICAgICAgICAgICAgYWN0aW9uSW50ZW5kc1xuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoYmVoYXZpb3JPdmVyd3JpdHRlbilcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJlaGF2aW9yT3ZlcndyaXR0ZW4gfHwgZW5xdWV1ZS5yYWlzZSh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgYWN0aW9uIGludGVuZHNcIixcbiAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3IsXG4gICAgICAgIGFjdGlvbkludGVuZHM6IFtkZWZhdWx0QWN0aW9uXVxuICAgICAgfSk7XG4gICAgfSlcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIGlkOiBcImVkaXRvclwiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgYmVoYXZpb3JzOiBpbnB1dC5iZWhhdmlvcnMgPz8gY29yZUJlaGF2aW9ycyxcbiAgICBrZXlHZW5lcmF0b3I6IGlucHV0LmtleUdlbmVyYXRvcixcbiAgICBwZW5kaW5nRXZlbnRzOiBbXSxcbiAgICBzY2hlbWE6IGlucHV0LnNjaGVtYSxcbiAgICByZWFkT25seTogaW5wdXQucmVhZE9ubHkgPz8gITEsXG4gICAgbWF4QmxvY2tzOiBpbnB1dC5tYXhCbG9ja3MsXG4gICAgdmFsdWU6IGlucHV0LnZhbHVlXG4gIH0pLFxuICBvbjoge1xuICAgIFwiYW5ub3RhdGlvbi5hZGRcIjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpLFxuICAgICAgZ3VhcmQ6ICh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pID0+ICFjb250ZXh0LnJlYWRPbmx5XG4gICAgfSxcbiAgICBcImFubm90YXRpb24ucmVtb3ZlXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KSxcbiAgICAgIGd1YXJkOiAoe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KSA9PiAhY29udGV4dC5yZWFkT25seVxuICAgIH0sXG4gICAgXCJhbm5vdGF0aW9uLnRvZ2dsZVwiOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudCksXG4gICAgICBndWFyZDogKHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSkgPT4gIWNvbnRleHQucmVhZE9ubHlcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudCksXG4gICAgICBndWFyZDogKHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSkgPT4gIWNvbnRleHQucmVhZE9ubHlcbiAgICB9LFxuICAgIHJlYWR5OiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudClcbiAgICB9LFxuICAgIHVuc2V0OiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudClcbiAgICB9LFxuICAgIFwidmFsdWUgY2hhbmdlZFwiOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudClcbiAgICB9LFxuICAgIFwiaW52YWxpZCB2YWx1ZVwiOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudClcbiAgICB9LFxuICAgIGVycm9yOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudClcbiAgICB9LFxuICAgIHNlbGVjdGlvbjoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBibHVyOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudClcbiAgICB9LFxuICAgIGZvY3VzZWQ6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgbG9hZGluZzoge1xuICAgICAgYWN0aW9uczogZW1pdCh7XG4gICAgICAgIHR5cGU6IFwibG9hZGluZ1wiXG4gICAgICB9KVxuICAgIH0sXG4gICAgcGF0Y2hlczoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBcImRvbmUgbG9hZGluZ1wiOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KHtcbiAgICAgICAgdHlwZTogXCJkb25lIGxvYWRpbmdcIlxuICAgICAgfSlcbiAgICB9LFxuICAgIFwidXBkYXRlIGJlaGF2aW9yc1wiOiB7XG4gICAgICBhY3Rpb25zOiBcImFzc2lnbiBiZWhhdmlvcnNcIlxuICAgIH0sXG4gICAgXCJ1cGRhdGUgc2NoZW1hXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwiYXNzaWduIHNjaGVtYVwiXG4gICAgfSxcbiAgICBcInVwZGF0ZSB2YWx1ZVwiOiB7XG4gICAgICBhY3Rpb25zOiBhc3NpZ24oe1xuICAgICAgICB2YWx1ZTogKHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSA9PiBldmVudC52YWx1ZVxuICAgICAgfSlcbiAgICB9LFxuICAgIFwidG9nZ2xlIHJlYWRPbmx5XCI6IHtcbiAgICAgIGFjdGlvbnM6IFthc3NpZ24oe1xuICAgICAgICByZWFkT25seTogKHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0pID0+ICFjb250ZXh0LnJlYWRPbmx5XG4gICAgICB9KSwgZW1pdCgoe1xuICAgICAgICBjb250ZXh0XG4gICAgICB9KSA9PiAoe1xuICAgICAgICB0eXBlOiBcInJlYWRPbmx5IHRvZ2dsZWRcIixcbiAgICAgICAgcmVhZE9ubHk6IGNvbnRleHQucmVhZE9ubHlcbiAgICAgIH0pKV1cbiAgICB9LFxuICAgIFwidXBkYXRlIG1heEJsb2Nrc1wiOiB7XG4gICAgICBhY3Rpb25zOiBhc3NpZ24oe1xuICAgICAgICBtYXhCbG9ja3M6ICh7XG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgfSkgPT4gZXZlbnQubWF4QmxvY2tzXG4gICAgICB9KVxuICAgIH0sXG4gICAgXCJiZWhhdmlvciBldmVudFwiOiB7XG4gICAgICBhY3Rpb25zOiBcImhhbmRsZSBiZWhhdmlvciBldmVudFwiLFxuICAgICAgZ3VhcmQ6ICh7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pID0+ICFjb250ZXh0LnJlYWRPbmx5XG4gICAgfSxcbiAgICBcImJlaGF2aW9yIGFjdGlvbiBpbnRlbmRzXCI6IHtcbiAgICAgIGFjdGlvbnM6IFsoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudFxuICAgICAgfSkgPT4ge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGV2ZW50LmVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgYWN0aW9uSW50ZW5kIG9mIGV2ZW50LmFjdGlvbkludGVuZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgLi4uYWN0aW9uSW50ZW5kLFxuICAgICAgICAgICAgICBlZGl0b3I6IGV2ZW50LmVkaXRvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBlcmZvcm1BY3Rpb24oe1xuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBhY3Rpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIGV2ZW50LmVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgfSwgZW5xdWV1ZUFjdGlvbnMoKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGVucXVldWVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgZXZlbnQuYWN0aW9uSW50ZW5kcy5zb21lKChhY3Rpb25JbnRlbmQpID0+IGFjdGlvbkludGVuZC50eXBlID09PSBcInJlc2VsZWN0XCIpICYmIGVucXVldWUucmFpc2Uoe1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgc2VsZWN0aW9uOiB0b1BvcnRhYmxlVGV4dFJhbmdlKGV2ZW50LmVkaXRvci5jaGlsZHJlbiwgZXZlbnQuZWRpdG9yLnNlbGVjdGlvbiwgY29udGV4dC5zY2hlbWEpXG4gICAgICAgIH0pO1xuICAgICAgfSldXG4gICAgfVxuICB9LFxuICBpbml0aWFsOiBcInByaXN0aW5lXCIsXG4gIHN0YXRlczoge1xuICAgIHByaXN0aW5lOiB7XG4gICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgIHN0YXRlczoge1xuICAgICAgICBpZGxlOiB7XG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIG5vcm1hbGl6aW5nOiB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2VkaXRvci5kaXJ0eVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiLFxuICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2VkaXRvci5kaXJ0eVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtYWxpemluZzoge1xuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcImRvbmUgbm9ybWFsaXppbmdcIjoge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXJ0eToge1xuICAgICAgZW50cnk6IFtcImVtaXQgcGVuZGluZyBldmVudHNcIiwgXCJjbGVhciBwZW5kaW5nIGV2ZW50c1wiXSxcbiAgICAgIG9uOiB7XG4gICAgICAgIHBhdGNoOiB7XG4gICAgICAgICAgYWN0aW9uczogXCJlbWl0IHBhdGNoIGV2ZW50XCJcbiAgICAgICAgfSxcbiAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICBhY3Rpb25zOiBcImVtaXQgbXV0YXRpb24gZXZlbnRcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZUVkaXRvcihjb25maWcpIHtcbiAgY29uc3QgZWRpdG9yQWN0b3IgPSBjcmVhdGVBY3RvcihlZGl0b3JNYWNoaW5lLCB7XG4gICAgaW5wdXQ6IGVkaXRvckNvbmZpZ1RvTWFjaGluZUlucHV0KGNvbmZpZylcbiAgfSk7XG4gIGVkaXRvckFjdG9yLnN0YXJ0KCk7XG4gIGNvbnN0IHNsYXRlRWRpdG9yID0gY3JlYXRlU2xhdGVFZGl0b3Ioe1xuICAgIGVkaXRvckFjdG9yXG4gIH0pLCBlZGl0YWJsZSA9IGNyZWF0ZUVkaXRhYmxlQVBJKHNsYXRlRWRpdG9yLmluc3RhbmNlLCBlZGl0b3JBY3Rvcik7XG4gIHJldHVybiB7XG4gICAgc2VuZDogKGV2ZW50KSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKGV2ZW50KTtcbiAgICB9LFxuICAgIG9uOiAoZXZlbnQsIGxpc3RlbmVyKSA9PiBlZGl0b3JBY3Rvci5vbihcbiAgICAgIGV2ZW50LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbGlzdGVuZXJcbiAgICApLFxuICAgIGVkaXRhYmxlLFxuICAgIF9pbnRlcm5hbDoge1xuICAgICAgZWRpdG9yQWN0b3IsXG4gICAgICBzbGF0ZUVkaXRvclxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRvcihjb25maWcpIHtcbiAgY29uc3QgZWRpdG9yQWN0b3IgPSB1c2VBY3RvclJlZihlZGl0b3JNYWNoaW5lLCB7XG4gICAgaW5wdXQ6IGVkaXRvckNvbmZpZ1RvTWFjaGluZUlucHV0KGNvbmZpZylcbiAgfSksIHNsYXRlRWRpdG9yID0gY3JlYXRlU2xhdGVFZGl0b3Ioe1xuICAgIGVkaXRvckFjdG9yXG4gIH0pLCBlZGl0YWJsZSA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlRWRpdGFibGVBUEkoc2xhdGVFZGl0b3IuaW5zdGFuY2UsIGVkaXRvckFjdG9yKSwgW3NsYXRlRWRpdG9yLmluc3RhbmNlLCBlZGl0b3JBY3Rvcl0pLCBzZW5kID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgZWRpdG9yQWN0b3Iuc2VuZChldmVudCk7XG4gIH0sIFtlZGl0b3JBY3Rvcl0pLCBvbiA9IHVzZUNhbGxiYWNrKChldmVudF8wLCBsaXN0ZW5lcikgPT4gZWRpdG9yQWN0b3Iub24oXG4gICAgZXZlbnRfMCxcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbGlzdGVuZXJcbiAgKSwgW2VkaXRvckFjdG9yXSk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgc2VuZCxcbiAgICBvbixcbiAgICBlZGl0YWJsZSxcbiAgICBfaW50ZXJuYWw6IHtcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3JcbiAgICB9XG4gIH0pLCBbc2VuZCwgb24sIGVkaXRhYmxlLCBlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3JdKTtcbn1cbmZ1bmN0aW9uIGVkaXRvckNvbmZpZ1RvTWFjaGluZUlucHV0KGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGJlaGF2aW9yczogY29uZmlnLmJlaGF2aW9ycyxcbiAgICBrZXlHZW5lcmF0b3I6IGNvbmZpZy5rZXlHZW5lcmF0b3IgPz8gZGVmYXVsdEtleUdlbmVyYXRvcixcbiAgICBtYXhCbG9ja3M6IGNvbmZpZy5tYXhCbG9ja3MsXG4gICAgcmVhZE9ubHk6IGNvbmZpZy5yZWFkT25seSxcbiAgICBzY2hlbWE6IGNvbmZpZy5zY2hlbWFEZWZpbml0aW9uID8gY29tcGlsZVNjaGVtYURlZmluaXRpb24oY29uZmlnLnNjaGVtYURlZmluaXRpb24pIDogZ2V0UG9ydGFibGVUZXh0TWVtYmVyU2NoZW1hVHlwZXMoY29uZmlnLnNjaGVtYS5oYXNPd25Qcm9wZXJ0eShcImpzb25UeXBlXCIpID8gY29uZmlnLnNjaGVtYSA6IGNvbXBpbGVUeXBlKGNvbmZpZy5zY2hlbWEpKSxcbiAgICB2YWx1ZTogY29uZmlnLmluaXRpYWxWYWx1ZVxuICB9O1xufVxuY29uc3QgZGVidWckNCA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yXCIpO1xuY2xhc3MgUG9ydGFibGVUZXh0RWRpdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGljIGRpc3BsYXlOYW1lID0gXCJQb3J0YWJsZVRleHRFZGl0b3JcIjtcbiAgLyoqXG4gICAqIEFuIG9ic2VydmFibGUgb2YgYWxsIHRoZSBlZGl0b3IgY2hhbmdlcy5cbiAgICovXG4gIGNoYW5nZSQgPSBuZXcgU3ViamVjdCgpO1xuICAvKipcbiAgICogQSBsb29rdXAgdGFibGUgZm9yIGFsbCB0aGUgcmVsZXZhbnQgc2NoZW1hIHR5cGVzIGZvciB0aGlzIHBvcnRhYmxlIHRleHQgdHlwZS5cbiAgICovXG4gIC8qKlxuICAgKiBUaGUgZWRpdG9yIGluc3RhbmNlXG4gICAqL1xuICAvKlxuICAgKiBUaGUgZWRpdG9yIEFQSSAoY3VycmVudGx5IGltcGxlbWVudGVkIHdpdGggU2xhdGUpLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyksIHByb3BzLmVkaXRvciA/IHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yIDogdGhpcy5lZGl0b3IgPSBjcmVhdGVFZGl0b3Ioe1xuICAgICAga2V5R2VuZXJhdG9yOiBwcm9wcy5rZXlHZW5lcmF0b3IgPz8gZGVmYXVsdEtleUdlbmVyYXRvcixcbiAgICAgIHNjaGVtYTogcHJvcHMuc2NoZW1hVHlwZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUsXG4gICAgICBtYXhCbG9ja3M6IHByb3BzLm1heEJsb2NrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogTnVtYmVyLnBhcnNlSW50KHByb3BzLm1heEJsb2Nrcy50b1N0cmluZygpLCAxMCksXG4gICAgICByZWFkT25seTogcHJvcHMucmVhZE9ubHlcbiAgICB9KSwgdGhpcy5zY2hlbWFUeXBlcyA9IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLCB0aGlzLmVkaXRhYmxlID0gdGhpcy5lZGl0b3IuZWRpdGFibGU7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICF0aGlzLnByb3BzLmVkaXRvciAmJiAhcHJldlByb3BzLmVkaXRvciAmJiB0aGlzLnByb3BzLnNjaGVtYVR5cGUgIT09IHByZXZQcm9wcy5zY2hlbWFUeXBlICYmICh0aGlzLnNjaGVtYVR5cGVzID0gZ2V0UG9ydGFibGVUZXh0TWVtYmVyU2NoZW1hVHlwZXModGhpcy5wcm9wcy5zY2hlbWFUeXBlLmhhc093blByb3BlcnR5KFwianNvblR5cGVcIikgPyB0aGlzLnByb3BzLnNjaGVtYVR5cGUgOiBjb21waWxlVHlwZSh0aGlzLnByb3BzLnNjaGVtYVR5cGUpKSwgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgc2NoZW1hXCIsXG4gICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hVHlwZXNcbiAgICB9KSksICF0aGlzLnByb3BzLmVkaXRvciAmJiAhcHJldlByb3BzLmVkaXRvciAmJiAodGhpcy5wcm9wcy5yZWFkT25seSAhPT0gcHJldlByb3BzLnJlYWRPbmx5ICYmIHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwidG9nZ2xlIHJlYWRPbmx5XCJcbiAgICB9KSwgdGhpcy5wcm9wcy5tYXhCbG9ja3MgIT09IHByZXZQcm9wcy5tYXhCbG9ja3MgJiYgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgbWF4QmxvY2tzXCIsXG4gICAgICBtYXhCbG9ja3M6IHRoaXMucHJvcHMubWF4QmxvY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBOdW1iZXIucGFyc2VJbnQodGhpcy5wcm9wcy5tYXhCbG9ja3MudG9TdHJpbmcoKSwgMTApXG4gICAgfSksIHRoaXMucHJvcHMudmFsdWUgIT09IHByZXZQcm9wcy52YWx1ZSAmJiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSB2YWx1ZVwiLFxuICAgICAgdmFsdWU6IHRoaXMucHJvcHMudmFsdWVcbiAgICB9KSwgdGhpcy5wcm9wcy5lZGl0b3JSZWYgIT09IHByZXZQcm9wcy5lZGl0b3JSZWYgJiYgdGhpcy5wcm9wcy5lZGl0b3JSZWYgJiYgKHRoaXMucHJvcHMuZWRpdG9yUmVmLmN1cnJlbnQgPSB0aGlzKSk7XG4gIH1cbiAgc2V0RWRpdGFibGUgPSAoZWRpdGFibGUpID0+IHtcbiAgICB0aGlzLmVkaXRvci5lZGl0YWJsZSA9IHtcbiAgICAgIC4uLnRoaXMuZWRpdG9yLmVkaXRhYmxlLFxuICAgICAgLi4uZWRpdGFibGVcbiAgICB9O1xuICB9O1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgbGVnYWN5UGF0Y2hlcyA9IHRoaXMucHJvcHMuZWRpdG9yID8gdm9pZCAwIDogdGhpcy5wcm9wcy5pbmNvbWluZ1BhdGNoZXMkID8/IHRoaXMucHJvcHMucGF0Y2hlcyQ7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICBsZWdhY3lQYXRjaGVzID8gLyogQF9fUFVSRV9fICovIGpzeChSb3V0ZVBhdGNoZXNPYnNlcnZhYmxlVG9FZGl0b3JBY3RvciwgeyBlZGl0b3JBY3RvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCBwYXRjaGVzJDogbGVnYWN5UGF0Y2hlcyB9KSA6IG51bGwsXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFJvdXRlRXZlbnRzVG9DaGFuZ2VzLCB7IGVkaXRvckFjdG9yOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIG9uQ2hhbmdlOiAoY2hhbmdlKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMuZWRpdG9yIHx8IHRoaXMucHJvcHMub25DaGFuZ2UoY2hhbmdlKSwgdGhpcy5jaGFuZ2UkLm5leHQoY2hhbmdlKTtcbiAgICAgIH0gfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFN5bmNocm9uaXplciwgeyBlZGl0b3JBY3RvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCBnZXRWYWx1ZTogdGhpcy5lZGl0b3IuZWRpdGFibGUuZ2V0VmFsdWUsIHBvcnRhYmxlVGV4dEVkaXRvcjogdGhpcywgc2xhdGVFZGl0b3I6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRWRpdG9yQWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFNsYXRlLCB7IGVkaXRvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluc3RhbmNlLCBpbml0aWFsVmFsdWU6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbml0aWFsVmFsdWUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvblByb3ZpZGVyLCB7IGVkaXRvckFjdG9yOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pIH0pIH0pIH0pXG4gICAgXSB9KTtcbiAgfVxuICAvLyBTdGF0aWMgQVBJIG1ldGhvZHNcbiAgc3RhdGljIGFjdGl2ZUFubm90YXRpb25zID0gKGVkaXRvcikgPT4gZWRpdG9yICYmIGVkaXRvci5lZGl0YWJsZSA/IGVkaXRvci5lZGl0YWJsZS5hY3RpdmVBbm5vdGF0aW9ucygpIDogW107XG4gIHN0YXRpYyBpc0Fubm90YXRpb25BY3RpdmUgPSAoZWRpdG9yLCBhbm5vdGF0aW9uVHlwZSkgPT4gZWRpdG9yICYmIGVkaXRvci5lZGl0YWJsZSA/IGVkaXRvci5lZGl0YWJsZS5pc0Fubm90YXRpb25BY3RpdmUoYW5ub3RhdGlvblR5cGUpIDogITE7XG4gIHN0YXRpYyBhZGRBbm5vdGF0aW9uID0gKGVkaXRvciwgdHlwZSwgdmFsdWUpID0+IGVkaXRvci5lZGl0YWJsZT8uYWRkQW5ub3RhdGlvbih0eXBlLCB2YWx1ZSk7XG4gIHN0YXRpYyBibHVyID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnJDQoXCJIb3N0IGJsdXJyZWRcIiksIGVkaXRvci5lZGl0YWJsZT8uYmx1cigpO1xuICB9O1xuICBzdGF0aWMgZGVsZXRlID0gKGVkaXRvciwgc2VsZWN0aW9uLCBvcHRpb25zKSA9PiBlZGl0b3IuZWRpdGFibGU/LmRlbGV0ZShzZWxlY3Rpb24sIG9wdGlvbnMpO1xuICBzdGF0aWMgZmluZERPTU5vZGUgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiBlZGl0b3IuZWRpdGFibGU/LmZpbmRET01Ob2RlKGVsZW1lbnQpO1xuICBzdGF0aWMgZmluZEJ5UGF0aCA9IChlZGl0b3IsIHBhdGgpID0+IGVkaXRvci5lZGl0YWJsZT8uZmluZEJ5UGF0aChwYXRoKSB8fCBbXTtcbiAgc3RhdGljIGZvY3VzID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnJDQoXCJIb3N0IHJlcXVlc3RpbmcgZm9jdXNcIiksIGVkaXRvci5lZGl0YWJsZT8uZm9jdXMoKTtcbiAgfTtcbiAgc3RhdGljIGZvY3VzQmxvY2sgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/LmZvY3VzQmxvY2soKTtcbiAgc3RhdGljIGZvY3VzQ2hpbGQgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/LmZvY3VzQ2hpbGQoKTtcbiAgc3RhdGljIGdldFNlbGVjdGlvbiA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZSA/IGVkaXRvci5lZGl0YWJsZS5nZXRTZWxlY3Rpb24oKSA6IG51bGw7XG4gIHN0YXRpYyBnZXRWYWx1ZSA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZ2V0VmFsdWUoKTtcbiAgc3RhdGljIGhhc0Jsb2NrU3R5bGUgPSAoZWRpdG9yLCBibG9ja1N0eWxlKSA9PiBlZGl0b3IuZWRpdGFibGU/Lmhhc0Jsb2NrU3R5bGUoYmxvY2tTdHlsZSk7XG4gIHN0YXRpYyBoYXNMaXN0U3R5bGUgPSAoZWRpdG9yLCBsaXN0U3R5bGUpID0+IGVkaXRvci5lZGl0YWJsZT8uaGFzTGlzdFN0eWxlKGxpc3RTdHlsZSk7XG4gIHN0YXRpYyBpc0NvbGxhcHNlZFNlbGVjdGlvbiA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uaXNDb2xsYXBzZWRTZWxlY3Rpb24oKTtcbiAgc3RhdGljIGlzRXhwYW5kZWRTZWxlY3Rpb24gPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/LmlzRXhwYW5kZWRTZWxlY3Rpb24oKTtcbiAgc3RhdGljIGlzTWFya0FjdGl2ZSA9IChlZGl0b3IsIG1hcmspID0+IGVkaXRvci5lZGl0YWJsZT8uaXNNYXJrQWN0aXZlKG1hcmspO1xuICBzdGF0aWMgaW5zZXJ0Q2hpbGQgPSAoZWRpdG9yLCB0eXBlLCB2YWx1ZSkgPT4gKGRlYnVnJDQoXCJIb3N0IGluc2VydGluZyBjaGlsZFwiKSwgZWRpdG9yLmVkaXRhYmxlPy5pbnNlcnRDaGlsZCh0eXBlLCB2YWx1ZSkpO1xuICBzdGF0aWMgaW5zZXJ0QmxvY2sgPSAoZWRpdG9yLCB0eXBlLCB2YWx1ZSkgPT4gZWRpdG9yLmVkaXRhYmxlPy5pbnNlcnRCbG9jayh0eXBlLCB2YWx1ZSk7XG4gIHN0YXRpYyBpbnNlcnRCcmVhayA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uaW5zZXJ0QnJlYWsoKTtcbiAgc3RhdGljIGlzVm9pZCA9IChlZGl0b3IsIGVsZW1lbnQpID0+IGVkaXRvci5lZGl0YWJsZT8uaXNWb2lkKGVsZW1lbnQpO1xuICBzdGF0aWMgaXNPYmplY3RQYXRoID0gKF9lZGl0b3IsIHBhdGgpID0+IHtcbiAgICBpZiAoIXBhdGggfHwgIUFycmF5LmlzQXJyYXkocGF0aCkpIHJldHVybiAhMTtcbiAgICBjb25zdCBpc0NoaWxkT2JqZWN0RWRpdFBhdGggPSBwYXRoLmxlbmd0aCA+IDMgJiYgcGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiO1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDEgJiYgcGF0aFsxXSAhPT0gXCJjaGlsZHJlblwiIHx8IGlzQ2hpbGRPYmplY3RFZGl0UGF0aDtcbiAgfTtcbiAgc3RhdGljIG1hcmtzID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5tYXJrcygpO1xuICBzdGF0aWMgc2VsZWN0ID0gKGVkaXRvciwgc2VsZWN0aW9uKSA9PiB7XG4gICAgZGVidWckNChcIkhvc3Qgc2V0dGluZyBzZWxlY3Rpb25cIiwgc2VsZWN0aW9uKSwgZWRpdG9yLmVkaXRhYmxlPy5zZWxlY3Qoc2VsZWN0aW9uKTtcbiAgfTtcbiAgc3RhdGljIHJlbW92ZUFubm90YXRpb24gPSAoZWRpdG9yLCB0eXBlKSA9PiBlZGl0b3IuZWRpdGFibGU/LnJlbW92ZUFubm90YXRpb24odHlwZSk7XG4gIHN0YXRpYyB0b2dnbGVCbG9ja1N0eWxlID0gKGVkaXRvciwgYmxvY2tTdHlsZSkgPT4gKGRlYnVnJDQoXCJIb3N0IGlzIHRvZ2dsaW5nIGJsb2NrIHN0eWxlXCIpLCBlZGl0b3IuZWRpdGFibGU/LnRvZ2dsZUJsb2NrU3R5bGUoYmxvY2tTdHlsZSkpO1xuICBzdGF0aWMgdG9nZ2xlTGlzdCA9IChlZGl0b3IsIGxpc3RTdHlsZSkgPT4gZWRpdG9yLmVkaXRhYmxlPy50b2dnbGVMaXN0KGxpc3RTdHlsZSk7XG4gIHN0YXRpYyB0b2dnbGVNYXJrID0gKGVkaXRvciwgbWFyaykgPT4ge1xuICAgIGRlYnVnJDQoXCJIb3N0IHRvZ2dsaW5nIG1hcmtcIiwgbWFyayksIGVkaXRvci5lZGl0YWJsZT8udG9nZ2xlTWFyayhtYXJrKTtcbiAgfTtcbiAgc3RhdGljIGdldEZyYWdtZW50ID0gKGVkaXRvcikgPT4gKGRlYnVnJDQoXCJIb3N0IGdldHRpbmcgZnJhZ21lbnRcIiksIGVkaXRvci5lZGl0YWJsZT8uZ2V0RnJhZ21lbnQoKSk7XG4gIHN0YXRpYyB1bmRvID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnJDQoXCJIb3N0IHVuZG9pbmdcIiksIGVkaXRvci5lZGl0YWJsZT8udW5kbygpO1xuICB9O1xuICBzdGF0aWMgcmVkbyA9IChlZGl0b3IpID0+IHtcbiAgICBkZWJ1ZyQ0KFwiSG9zdCByZWRvaW5nXCIpLCBlZGl0b3IuZWRpdGFibGU/LnJlZG8oKTtcbiAgfTtcbiAgc3RhdGljIGlzU2VsZWN0aW9uc092ZXJsYXBwaW5nID0gKGVkaXRvciwgc2VsZWN0aW9uQSwgc2VsZWN0aW9uQikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc1NlbGVjdGlvbnNPdmVybGFwcGluZyhzZWxlY3Rpb25BLCBzZWxlY3Rpb25CKTtcbn1cbmZ1bmN0aW9uIFJvdXRlUGF0Y2hlc09ic2VydmFibGVUb0VkaXRvckFjdG9yKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDQpO1xuICBsZXQgdDAsIHQxO1xuICByZXR1cm4gJFswXSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgfHwgJFsxXSAhPT0gcHJvcHMucGF0Y2hlcyQgPyAodDAgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gcHJvcHMucGF0Y2hlcyQuc3Vic2NyaWJlKChwYXlsb2FkKSA9PiB7XG4gICAgICBwcm9wcy5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJwYXRjaGVzXCIsXG4gICAgICAgIC4uLnBheWxvYWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MSA9IFtwcm9wcy5lZGl0b3JBY3RvciwgcHJvcHMucGF0Y2hlcyRdLCAkWzBdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbMV0gPSBwcm9wcy5wYXRjaGVzJCwgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogKHQwID0gJFsyXSwgdDEgPSAkWzNdKSwgdXNlRWZmZWN0KHQwLCB0MSksIG51bGw7XG59XG5mdW5jdGlvbiBSb3V0ZUV2ZW50c1RvQ2hhbmdlcyhwcm9wcykge1xuICBjb25zdCAkID0gYyg2KTtcbiAgbGV0IHQwO1xuICAkWzBdICE9PSBwcm9wcyA/ICh0MCA9IChjaGFuZ2UpID0+IHByb3BzLm9uQ2hhbmdlKGNoYW5nZSksICRbMF0gPSBwcm9wcywgJFsxXSA9IHQwKSA6IHQwID0gJFsxXTtcbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodDApO1xuICBsZXQgdDEsIHQyO1xuICByZXR1cm4gJFsyXSAhPT0gaGFuZGxlQ2hhbmdlIHx8ICRbM10gIT09IHByb3BzLmVkaXRvckFjdG9yID8gKHQxID0gKCkgPT4ge1xuICAgIGRlYnVnJDQoXCJTdWJzY3JpYmluZyB0byBlZGl0b3IgY2hhbmdlc1wiKTtcbiAgICBjb25zdCBzdWIgPSBwcm9wcy5lZGl0b3JBY3Rvci5vbihcIipcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBiYjU6IHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFwicGF0Y2hcIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJsb2FkaW5nXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgICBpc0xvYWRpbmc6ICEwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJkb25lIGxvYWRpbmdcIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZSh7XG4gICAgICAgICAgICB0eXBlOiBcImxvYWRpbmdcIixcbiAgICAgICAgICAgIGlzTG9hZGluZzogITFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZvY3VzZWRcIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZSh7XG4gICAgICAgICAgICB0eXBlOiBcImZvY3VzXCIsXG4gICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInZhbHVlIGNoYW5nZWRcIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZSh7XG4gICAgICAgICAgICB0eXBlOiBcInZhbHVlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZXZlbnQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImludmFsaWQgdmFsdWVcIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZSh7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWRWYWx1ZVwiLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogZXZlbnQucmVzb2x1dGlvbixcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiNTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgIGhhbmRsZUNoYW5nZSh7XG4gICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgIGxldmVsOiBcIndhcm5pbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiNTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi5hZGRcIjpcbiAgICAgICAgY2FzZSBcImFubm90YXRpb24ucmVtb3ZlXCI6XG4gICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLnRvZ2dsZVwiOlxuICAgICAgICBjYXNlIFwiZm9jdXNcIjpcbiAgICAgICAgY2FzZSBcInBhdGNoZXNcIjpcbiAgICAgICAgY2FzZSBcInJlYWRPbmx5IHRvZ2dsZWRcIjpcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaGFuZGxlQ2hhbmdlKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVidWckNChcIlVuc3Vic2NyaWJpbmcgdG8gY2hhbmdlc1wiKSwgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgdDIgPSBbcHJvcHMuZWRpdG9yQWN0b3IsIGhhbmRsZUNoYW5nZV0sICRbMl0gPSBoYW5kbGVDaGFuZ2UsICRbM10gPSBwcm9wcy5lZGl0b3JBY3RvciwgJFs0XSA9IHQxLCAkWzVdID0gdDIpIDogKHQxID0gJFs0XSwgdDIgPSAkWzVdKSwgdXNlRWZmZWN0KHQxLCB0MiksIG51bGw7XG59XG5jb25zdCBkZWJ1ZyQzID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudHM6TGVhZlwiKSwgRU1QVFlfTUFSS1MgPSBbXSwgTGVhZiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgZWRpdG9yQWN0b3IsXG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbixcbiAgICBsZWFmLFxuICAgIHNjaGVtYVR5cGVzLFxuICAgIHJlbmRlckNoaWxkLFxuICAgIHJlbmRlckRlY29yYXRvcixcbiAgICByZW5kZXJBbm5vdGF0aW9uXG4gIH0gPSBwcm9wcywgc3BhblJlZiA9IHVzZVJlZihudWxsKSwgcG9ydGFibGVUZXh0RWRpdG9yID0gdXNlUG9ydGFibGVUZXh0RWRpdG9yKCksIGJsb2NrU2VsZWN0ZWQgPSB1c2VTZWxlY3RlZCgpLCBbZm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VTdGF0ZSghMSksIFtzZWxlY3RlZCwgc2V0U2VsZWN0ZWRdID0gdXNlU3RhdGUoITEpLCBibG9jayA9IGNoaWxkcmVuLnByb3BzLnBhcmVudCwgcGF0aCA9IHVzZU1lbW8oKCkgPT4gYmxvY2sgPyBbe1xuICAgIF9rZXk6IGJsb2NrPy5fa2V5XG4gIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgIF9rZXk6IGxlYWYuX2tleVxuICB9XSA6IFtdLCBbYmxvY2ssIGxlYWYuX2tleV0pLCBkZWNvcmF0b3JWYWx1ZXMgPSB1c2VNZW1vKCgpID0+IHNjaGVtYVR5cGVzLmRlY29yYXRvcnMubWFwKChkZWMpID0+IGRlYy52YWx1ZSksIFtzY2hlbWFUeXBlcy5kZWNvcmF0b3JzXSksIG1hcmtzID0gdXNlTWVtbygoKSA9PiB1bmlxKChsZWFmLm1hcmtzIHx8IEVNUFRZX01BUktTKS5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvclZhbHVlcy5pbmNsdWRlcyhtYXJrKSkpLCBbZGVjb3JhdG9yVmFsdWVzLCBsZWFmLm1hcmtzXSksIGFubm90YXRpb25NYXJrcyA9IEFycmF5LmlzQXJyYXkobGVhZi5tYXJrcykgPyBsZWFmLm1hcmtzIDogRU1QVFlfTUFSS1MsIGFubm90YXRpb25zID0gdXNlTWVtbygoKSA9PiBhbm5vdGF0aW9uTWFya3MubWFwKChtYXJrXzApID0+ICFkZWNvcmF0b3JWYWx1ZXMuaW5jbHVkZXMobWFya18wKSAmJiBibG9jaz8ubWFya0RlZnM/LmZpbmQoKGRlZikgPT4gZGVmLl9rZXkgPT09IG1hcmtfMCkpLmZpbHRlcihCb29sZWFuKSwgW2Fubm90YXRpb25NYXJrcywgYmxvY2ssIGRlY29yYXRvclZhbHVlc10pLCBzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzID0gYW5ub3RhdGlvbnMubGVuZ3RoID4gMCAmJiBibG9ja1NlbGVjdGVkO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1cykge1xuICAgICAgc2V0Rm9jdXNlZCghMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbCA9IFBvcnRhYmxlVGV4dEVkaXRvci5nZXRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICBzZWwgJiYgaXNFcXVhbChzZWwuZm9jdXMucGF0aCwgcGF0aCkgJiYgUG9ydGFibGVUZXh0RWRpdG9yLmlzQ29sbGFwc2VkU2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcikgJiYgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIHNldEZvY3VzZWQoITApO1xuICAgIH0pO1xuICB9LCBbc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1cywgcGF0aCwgcG9ydGFibGVUZXh0RWRpdG9yXSk7XG4gIGNvbnN0IHNldFNlbGVjdGVkRnJvbVJhbmdlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1cylcbiAgICAgIHJldHVybjtcbiAgICBkZWJ1ZyQzKFwiU2V0dGluZyBzZWxlY3Rpb24gYW5kIGZvY3VzIGZyb20gcmFuZ2VcIik7XG4gICAgY29uc3Qgd2luU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghd2luU2VsZWN0aW9uKSB7XG4gICAgICBzZXRTZWxlY3RlZCghMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3aW5TZWxlY3Rpb24gJiYgd2luU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICBjb25zdCByYW5nZSA9IHdpblNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgc3BhblJlZi5jdXJyZW50ICYmIHJhbmdlLmludGVyc2VjdHNOb2RlKHNwYW5SZWYuY3VycmVudCkgPyBzZXRTZWxlY3RlZCghMCkgOiBzZXRTZWxlY3RlZCghMSk7XG4gICAgfSBlbHNlXG4gICAgICBzZXRTZWxlY3RlZCghMSk7XG4gIH0sIFtzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG9uQmx1ciA9IGVkaXRvckFjdG9yLm9uKFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICBzZXRGb2N1c2VkKCExKSwgc2V0U2VsZWN0ZWQoITEpO1xuICAgIH0pLCBvbkZvY3VzID0gZWRpdG9yQWN0b3Iub24oXCJmb2N1c1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxfMCA9IFBvcnRhYmxlVGV4dEVkaXRvci5nZXRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICAgIHNlbF8wICYmIGlzRXF1YWwoc2VsXzAuZm9jdXMucGF0aCwgcGF0aCkgJiYgUG9ydGFibGVUZXh0RWRpdG9yLmlzQ29sbGFwc2VkU2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcikgJiYgc2V0Rm9jdXNlZCghMCksIHNldFNlbGVjdGVkRnJvbVJhbmdlKCk7XG4gICAgfSksIG9uU2VsZWN0aW9uID0gZWRpdG9yQWN0b3Iub24oXCJzZWxlY3Rpb25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5zZWxlY3Rpb24gJiYgaXNFcXVhbChldmVudC5zZWxlY3Rpb24uZm9jdXMucGF0aCwgcGF0aCkgJiYgUG9ydGFibGVUZXh0RWRpdG9yLmlzQ29sbGFwc2VkU2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcikgPyBzZXRGb2N1c2VkKCEwKSA6IHNldEZvY3VzZWQoITEpLCBzZXRTZWxlY3RlZEZyb21SYW5nZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvbkJsdXIudW5zdWJzY3JpYmUoKSwgb25Gb2N1cy51bnN1YnNjcmliZSgpLCBvblNlbGVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtlZGl0b3JBY3RvciwgcGF0aCwgcG9ydGFibGVUZXh0RWRpdG9yLCBzZXRTZWxlY3RlZEZyb21SYW5nZSwgc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1c10pLCB1c2VFZmZlY3QoKCkgPT4gc2V0U2VsZWN0ZWRGcm9tUmFuZ2UoKSwgW3NldFNlbGVjdGVkRnJvbVJhbmdlXSk7XG4gIGNvbnN0IGNvbnRlbnQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgcmV0dXJuZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIGlmIChUZXh0LmlzVGV4dChsZWFmKSAmJiBsZWFmLl90eXBlID09PSBzY2hlbWFUeXBlcy5zcGFuLm5hbWUgJiYgKG1hcmtzLmZvckVhY2goKG1hcmtfMSkgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGVzLmRlY29yYXRvcnMuZmluZCgoZGVjXzApID0+IGRlY18wLnZhbHVlID09PSBtYXJrXzEpO1xuICAgICAgaWYgKHNjaGVtYVR5cGUgJiYgcmVuZGVyRGVjb3JhdG9yKSB7XG4gICAgICAgIGNvbnN0IF9wcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgICAgY2hpbGRyZW46IHJldHVybmVkQ2hpbGRyZW4sXG4gICAgICAgICAgZWRpdG9yRWxlbWVudFJlZjogc3BhblJlZixcbiAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgc2NoZW1hVHlwZSxcbiAgICAgICAgICB2YWx1ZTogbWFya18xXG4gICAgICAgIH0sIFwidHlwZVwiLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIlByb3BlcnR5ICd0eXBlJyBpcyBkZXByZWNhdGVkLCB1c2UgJ3NjaGVtYVR5cGUnIGluc3RlYWQuXCIpLCBzY2hlbWFUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybmVkQ2hpbGRyZW4gPSByZW5kZXJEZWNvcmF0b3IoX3Byb3BzKTtcbiAgICAgIH1cbiAgICB9KSwgYmxvY2sgJiYgYW5ub3RhdGlvbnMubGVuZ3RoID4gMCAmJiBhbm5vdGF0aW9ucy5mb3JFYWNoKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWFUeXBlXzAgPSBzY2hlbWFUeXBlcy5hbm5vdGF0aW9ucy5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGFubm90YXRpb24uX3R5cGUpO1xuICAgICAgaWYgKHNjaGVtYVR5cGVfMClcbiAgICAgICAgaWYgKHJlbmRlckFubm90YXRpb24pIHtcbiAgICAgICAgICBjb25zdCBfcHJvcHNfMCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIGNoaWxkcmVuOiByZXR1cm5lZENoaWxkcmVuLFxuICAgICAgICAgICAgZWRpdG9yRWxlbWVudFJlZjogc3BhblJlZixcbiAgICAgICAgICAgIGZvY3VzZWQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiBzY2hlbWFUeXBlXzAsXG4gICAgICAgICAgICB2YWx1ZTogYW5ub3RhdGlvblxuICAgICAgICAgIH0sIFwidHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIlByb3BlcnR5ICd0eXBlJyBpcyBkZXByZWNhdGVkLCB1c2UgJ3NjaGVtYVR5cGUnIGluc3RlYWQuXCIpLCBzY2hlbWFUeXBlXzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuZWRDaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgcmVmOiBzcGFuUmVmLCBjaGlsZHJlbjogcmVuZGVyQW5ub3RhdGlvbihfcHJvcHNfMCkgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHJldHVybmVkQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRBbm5vdGF0aW9uLCB7IGFubm90YXRpb24sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IHJlZjogc3BhblJlZiwgY2hpbGRyZW46IHJldHVybmVkQ2hpbGRyZW4gfSkgfSk7XG4gICAgfSksIGJsb2NrICYmIHJlbmRlckNoaWxkKSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbi5maW5kKChfY2hpbGQpID0+IF9jaGlsZC5fa2V5ID09PSBsZWFmLl9rZXkpO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGNvbnN0IF9wcm9wc18xID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgICAgICBhbm5vdGF0aW9ucyxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogcmV0dXJuZWRDaGlsZHJlbiB9KSxcbiAgICAgICAgICBlZGl0b3JFbGVtZW50UmVmOiBzcGFuUmVmLFxuICAgICAgICAgIGZvY3VzZWQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBzY2hlbWFUeXBlOiBzY2hlbWFUeXBlcy5zcGFuLFxuICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgIHZhbHVlOiBjaGlsZFxuICAgICAgICB9LCBcInR5cGVcIiwge1xuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZXMuc3BhbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm5lZENoaWxkcmVuID0gcmVuZGVyQ2hpbGQoX3Byb3BzXzEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuZWRDaGlsZHJlbjtcbiAgfSwgW2Fubm90YXRpb25zLCBibG9jaywgY2hpbGRyZW4sIGZvY3VzZWQsIGxlYWYsIG1hcmtzLCBwYXRoLCByZW5kZXJBbm5vdGF0aW9uLCByZW5kZXJDaGlsZCwgcmVuZGVyRGVjb3JhdG9yLCBzY2hlbWFUeXBlcy5hbm5vdGF0aW9ucywgc2NoZW1hVHlwZXMuZGVjb3JhdG9ycywgc2NoZW1hVHlwZXMuc3Bhbiwgc2VsZWN0ZWRdKTtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyAuLi5hdHRyaWJ1dGVzLCByZWY6IHNwYW5SZWYsIGNoaWxkcmVuOiBjb250ZW50IH0sIGxlYWYuX2tleSksIFtsZWFmLCBhdHRyaWJ1dGVzLCBjb250ZW50XSk7XG59O1xuTGVhZi5kaXNwbGF5TmFtZSA9IFwiTGVhZlwiO1xuY29uc3QgSVNfTUFDID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCksIG1vZGlmaWVycyA9IHtcbiAgYWx0OiBcImFsdEtleVwiLFxuICBjb250cm9sOiBcImN0cmxLZXlcIixcbiAgbWV0YTogXCJtZXRhS2V5XCIsXG4gIHNoaWZ0OiBcInNoaWZ0S2V5XCJcbn0sIGFsaWFzZXMgPSB7XG4gIGFkZDogXCIrXCIsXG4gIGJyZWFrOiBcInBhdXNlXCIsXG4gIGNtZDogXCJtZXRhXCIsXG4gIGNvbW1hbmQ6IFwibWV0YVwiLFxuICBjdGw6IFwiY29udHJvbFwiLFxuICBjdHJsOiBcImNvbnRyb2xcIixcbiAgZGVsOiBcImRlbGV0ZVwiLFxuICBkb3duOiBcImFycm93ZG93blwiLFxuICBlc2M6IFwiZXNjYXBlXCIsXG4gIGluczogXCJpbnNlcnRcIixcbiAgbGVmdDogXCJhcnJvd2xlZnRcIixcbiAgbW9kOiBJU19NQUMgPyBcIm1ldGFcIiA6IFwiY29udHJvbFwiLFxuICBvcHQ6IFwiYWx0XCIsXG4gIG9wdGlvbjogXCJhbHRcIixcbiAgcmV0dXJuOiBcImVudGVyXCIsXG4gIHJpZ2h0OiBcImFycm93cmlnaHRcIixcbiAgc3BhY2U6IFwiIFwiLFxuICBzcGFjZWJhcjogXCIgXCIsXG4gIHVwOiBcImFycm93dXBcIixcbiAgd2luOiBcIm1ldGFcIixcbiAgd2luZG93czogXCJtZXRhXCJcbn0sIGtleUNvZGVzID0ge1xuICBiYWNrc3BhY2U6IDgsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzaGlmdDogMTYsXG4gIGNvbnRyb2w6IDE3LFxuICBhbHQ6IDE4LFxuICBwYXVzZTogMTksXG4gIGNhcHNsb2NrOiAyMCxcbiAgZXNjYXBlOiAyNyxcbiAgXCIgXCI6IDMyLFxuICBwYWdldXA6IDMzLFxuICBwYWdlZG93bjogMzQsXG4gIGVuZDogMzUsXG4gIGhvbWU6IDM2LFxuICBhcnJvd2xlZnQ6IDM3LFxuICBhcnJvd3VwOiAzOCxcbiAgYXJyb3dyaWdodDogMzksXG4gIGFycm93ZG93bjogNDAsXG4gIGluc2VydDogNDUsXG4gIGRlbGV0ZTogNDYsXG4gIG1ldGE6IDkxLFxuICBudW1sb2NrOiAxNDQsXG4gIHNjcm9sbGxvY2s6IDE0NSxcbiAgXCI7XCI6IDE4NixcbiAgXCI9XCI6IDE4NyxcbiAgXCIsXCI6IDE4OCxcbiAgXCItXCI6IDE4OSxcbiAgXCIuXCI6IDE5MCxcbiAgXCIvXCI6IDE5MSxcbiAgXCJgXCI6IDE5MixcbiAgXCJbXCI6IDIxOSxcbiAgXCJcXFxcXCI6IDIyMCxcbiAgXCJdXCI6IDIyMSxcbiAgXCInXCI6IDIyMixcbiAgZjE6IDExMixcbiAgZjI6IDExMyxcbiAgZjM6IDExNCxcbiAgZjQ6IDExNSxcbiAgZjU6IDExNixcbiAgZjY6IDExNyxcbiAgZjc6IDExOCxcbiAgZjg6IDExOSxcbiAgZjk6IDEyMCxcbiAgZjEwOiAxMjEsXG4gIGYxMTogMTIyLFxuICBmMTI6IDEyMyxcbiAgZjEzOiAxMjQsXG4gIGYxNDogMTI1LFxuICBmMTU6IDEyNixcbiAgZjE2OiAxMjcsXG4gIGYxNzogMTI4LFxuICBmMTg6IDEyOSxcbiAgZjE5OiAxMzAsXG4gIGYyMDogMTMxXG59O1xuZnVuY3Rpb24gaXNIb3RrZXkoaG90a2V5LCBldmVudCkge1xuICByZXR1cm4gY29tcGFyZUhvdGtleShwYXJzZUhvdGtleShob3RrZXkpLCBldmVudCk7XG59XG5mdW5jdGlvbiBwYXJzZUhvdGtleShob3RrZXkpIHtcbiAgY29uc3QgcGFyc2VkSG90a2V5ID0ge1xuICAgIGFsdEtleTogITEsXG4gICAgY3RybEtleTogITEsXG4gICAgbWV0YUtleTogITEsXG4gICAgc2hpZnRLZXk6ICExXG4gIH0sIGhvdGtleVNlZ21lbnRzID0gaG90a2V5LnJlcGxhY2UoXCIrK1wiLCBcIithZGRcIikuc3BsaXQoXCIrXCIpO1xuICBmb3IgKGNvbnN0IHJhd0hvdGtleVNlZ21lbnQgb2YgaG90a2V5U2VnbWVudHMpIHtcbiAgICBjb25zdCBvcHRpb25hbCA9IHJhd0hvdGtleVNlZ21lbnQuZW5kc1dpdGgoXCI/XCIpICYmIHJhd0hvdGtleVNlZ21lbnQubGVuZ3RoID4gMSwgaG90a2V5U2VnbWVudCA9IG9wdGlvbmFsID8gcmF3SG90a2V5U2VnbWVudC5zbGljZSgwLCAtMSkgOiByYXdIb3RrZXlTZWdtZW50LCBrZXlOYW1lID0gdG9LZXlOYW1lKGhvdGtleVNlZ21lbnQpLCBtb2RpZmllciA9IG1vZGlmaWVyc1trZXlOYW1lXSwgYWxpYXMgPSBhbGlhc2VzW2hvdGtleVNlZ21lbnRdLCBjb2RlID0ga2V5Q29kZXNba2V5TmFtZV07XG4gICAgaWYgKGhvdGtleVNlZ21lbnQubGVuZ3RoID4gMSAmJiBtb2RpZmllciA9PT0gdm9pZCAwICYmIGFsaWFzID09PSB2b2lkIDAgJiYgY29kZSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5rbm93biBtb2RpZmllcjogXCIke2hvdGtleVNlZ21lbnR9XCJgKTtcbiAgICAoaG90a2V5U2VnbWVudHMubGVuZ3RoID09PSAxIHx8IG1vZGlmaWVyID09PSB2b2lkIDApICYmIChwYXJzZWRIb3RrZXkua2V5ID0ga2V5TmFtZSwgcGFyc2VkSG90a2V5LmtleUNvZGUgPSB0b0tleUNvZGUoaG90a2V5U2VnbWVudCkpLCBtb2RpZmllciAhPT0gdm9pZCAwICYmIChwYXJzZWRIb3RrZXlbbW9kaWZpZXJdID0gb3B0aW9uYWwgPyBudWxsIDogITApO1xuICB9XG4gIHJldHVybiBwYXJzZWRIb3RrZXk7XG59XG5mdW5jdGlvbiBjb21wYXJlSG90a2V5KHBhcnNlZEhvdGtleSwgZXZlbnQpIHtcbiAgcmV0dXJuIChwYXJzZWRIb3RrZXkuYWx0S2V5ID09IG51bGwgfHwgcGFyc2VkSG90a2V5LmFsdEtleSA9PT0gZXZlbnQuYWx0S2V5KSAmJiAocGFyc2VkSG90a2V5LmN0cmxLZXkgPT0gbnVsbCB8fCBwYXJzZWRIb3RrZXkuY3RybEtleSA9PT0gZXZlbnQuY3RybEtleSkgJiYgKHBhcnNlZEhvdGtleS5tZXRhS2V5ID09IG51bGwgfHwgcGFyc2VkSG90a2V5Lm1ldGFLZXkgPT09IGV2ZW50Lm1ldGFLZXkpICYmIChwYXJzZWRIb3RrZXkuc2hpZnRLZXkgPT0gbnVsbCB8fCBwYXJzZWRIb3RrZXkuc2hpZnRLZXkgPT09IGV2ZW50LnNoaWZ0S2V5KSA/IHBhcnNlZEhvdGtleS5rZXlDb2RlICE9PSB2b2lkIDAgJiYgZXZlbnQua2V5Q29kZSAhPT0gdm9pZCAwID8gcGFyc2VkSG90a2V5LmtleUNvZGUgPT09IDkxICYmIGV2ZW50LmtleUNvZGUgPT09IDkzID8gITAgOiBwYXJzZWRIb3RrZXkua2V5Q29kZSA9PT0gZXZlbnQua2V5Q29kZSA6IHBhcnNlZEhvdGtleS5rZXlDb2RlID09PSBldmVudC5rZXlDb2RlIHx8IHBhcnNlZEhvdGtleS5rZXkgPT09IGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpIDogITE7XG59XG5mdW5jdGlvbiB0b0tleUNvZGUobmFtZSkge1xuICBjb25zdCBrZXlOYW1lID0gdG9LZXlOYW1lKG5hbWUpO1xuICByZXR1cm4ga2V5Q29kZXNba2V5TmFtZV0gPz8ga2V5TmFtZS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG59XG5mdW5jdGlvbiB0b0tleU5hbWUobmFtZSkge1xuICBjb25zdCBrZXlOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gYWxpYXNlc1trZXlOYW1lXSA/PyBrZXlOYW1lO1xufVxuY29uc3QgZGVidWckMiA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aEhvdEtleXNcIiksIERFRkFVTFRfSE9US0VZUyA9IHtcbiAgbWFya3M6IHtcbiAgICBcIm1vZCtiXCI6IFwic3Ryb25nXCIsXG4gICAgXCJtb2QraVwiOiBcImVtXCIsXG4gICAgXCJtb2QrdVwiOiBcInVuZGVybGluZVwiLFxuICAgIFwibW9kKydcIjogXCJjb2RlXCJcbiAgfSxcbiAgY3VzdG9tOiB7fVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhIb3RrZXlzKGVkaXRvckFjdG9yLCBwb3J0YWJsZVRleHRFZGl0b3IsIGhvdGtleXNGcm9tT3B0aW9ucykge1xuICBjb25zdCByZXNlcnZlZEhvdGtleXMgPSBbXCJlbnRlclwiLCBcInRhYlwiLCBcInNoaWZ0XCIsIFwiZGVsZXRlXCIsIFwiZW5kXCJdLCBhY3RpdmVIb3RrZXlzID0gaG90a2V5c0Zyb21PcHRpb25zIHx8IERFRkFVTFRfSE9US0VZUztcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucHRlV2l0aEhvdEtleXMgPSAoZXZlbnQpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKGFjdGl2ZUhvdGtleXMpLmZvckVhY2goKGNhdCkgPT4ge1xuICAgICAgICBpZiAoY2F0ID09PSBcIm1hcmtzXCIpXG4gICAgICAgICAgZm9yIChjb25zdCBob3RrZXkgaW4gYWN0aXZlSG90a2V5c1tjYXRdKSB7XG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRIb3RrZXlzLmluY2x1ZGVzKGhvdGtleSkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGhvdGtleSAke2hvdGtleX0gaXMgcmVzZXJ2ZWQhYCk7XG4gICAgICAgICAgICBpZiAoaXNIb3RrZXkoaG90a2V5LCBldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVNYXJrID0gYWN0aXZlSG90a2V5c1tjYXRdO1xuICAgICAgICAgICAgICBpZiAocG9zc2libGVNYXJrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFyayA9IHBvc3NpYmxlTWFya1tob3RrZXldO1xuICAgICAgICAgICAgICAgIGRlYnVnJDIoYEhvdEtleSAke2hvdGtleX0gdG8gdG9nZ2xlICR7bWFya31gKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3I6IG1hcmtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgaWYgKGNhdCA9PT0gXCJjdXN0b21cIilcbiAgICAgICAgICBmb3IgKGNvbnN0IGhvdGtleSBpbiBhY3RpdmVIb3RrZXlzW2NhdF0pIHtcbiAgICAgICAgICAgIGlmIChyZXNlcnZlZEhvdGtleXMuaW5jbHVkZXMoaG90a2V5KSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaG90a2V5ICR7aG90a2V5fSBpcyByZXNlcnZlZCFgKTtcbiAgICAgICAgICAgIGlmIChpc0hvdGtleShob3RrZXksIGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZUNvbW1hbmQgPSBhY3RpdmVIb3RrZXlzW2NhdF07XG4gICAgICAgICAgICAgIGlmIChwb3NzaWJsZUNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kID0gcG9zc2libGVDb21tYW5kW2hvdGtleV07XG4gICAgICAgICAgICAgICAgY29tbWFuZChldmVudCwgcG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgaXNFbnRlciA9IGlzSG90a2V5KFwiZW50ZXJcIiwgZXZlbnQubmF0aXZlRXZlbnQpLCBpc1RhYiA9IGlzSG90a2V5KFwidGFiXCIsIGV2ZW50Lm5hdGl2ZUV2ZW50KSwgaXNTaGlmdEVudGVyID0gaXNIb3RrZXkoXCJzaGlmdCtlbnRlclwiLCBldmVudC5uYXRpdmVFdmVudCksIGlzU2hpZnRUYWIgPSBpc0hvdGtleShcInNoaWZ0K3RhYlwiLCBldmVudC5uYXRpdmVFdmVudCksIGlzQXJyb3dEb3duID0gaXNIb3RrZXkoXCJkb3duXCIsIGV2ZW50Lm5hdGl2ZUV2ZW50KSwgaXNBcnJvd1VwID0gaXNIb3RrZXkoXCJ1cFwiLCBldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICBpZiAoaXNBcnJvd0Rvd24gJiYgZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBmb2N1c0Jsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGZvY3VzQmxvY2sgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIGZvY3VzQmxvY2spKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFBhdGggPSBQYXRoLm5leHQoZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgICBpZiAoIU5vZGUuaGFzKGVkaXRvciwgbmV4dFBhdGgpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZWRpdG9yLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgICAgICAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgICBhdDogbmV4dFBhdGhcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgcGF0aDogWy4uLm5leHRQYXRoLCAwXSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJvd1VwICYmIGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgaXNGaXJzdEJsb2NrID0gZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdID09PSAwLCBmb2N1c0Jsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGlzRmlyc3RCbG9jayAmJiBmb2N1c0Jsb2NrICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBmb2N1c0Jsb2NrKSkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiBbMF1cbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKGlzVGFiIHx8IGlzU2hpZnRUYWIpICYmIGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgW2ZvY3VzQ2hpbGRdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLCB7XG4gICAgICAgICAgZGVwdGg6IDJcbiAgICAgICAgfSksIFtmb2N1c0Jsb2NrXSA9IGlzUG9ydGFibGVUZXh0U3BhbiQxKGZvY3VzQ2hpbGQpID8gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLCB7XG4gICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgfSkgOiBbXSwgaGFzQW5ub3RhdGlvbkZvY3VzID0gZm9jdXNDaGlsZCAmJiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhmb2N1c0Jsb2NrKSAmJiBpc1BvcnRhYmxlVGV4dFNwYW4kMShmb2N1c0NoaWxkKSAmJiAoZm9jdXNDaGlsZC5tYXJrcyB8fCBbXSkuZmlsdGVyKChtKSA9PiAoZm9jdXNCbG9jay5tYXJrRGVmcyB8fCBbXSkubWFwKChkZWYpID0+IGRlZi5fa2V5KS5pbmNsdWRlcyhtKSkubGVuZ3RoID4gMCwgW3N0YXJ0XSA9IFJhbmdlLmVkZ2VzKGVkaXRvci5zZWxlY3Rpb24pLCBhdFN0YXJ0T2ZOb2RlID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBzdGFydCwgc3RhcnQucGF0aCk7XG4gICAgICAgIGZvY3VzQ2hpbGQgJiYgaXNQb3J0YWJsZVRleHRTcGFuJDEoZm9jdXNDaGlsZCkgJiYgKCFoYXNBbm5vdGF0aW9uRm9jdXMgfHwgYXRTdGFydE9mTm9kZSkgJiYgZWRpdG9yLnB0ZUluY3JlbWVudEJsb2NrTGV2ZWxzKGlzU2hpZnRUYWIpICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbnRlciAmJiAhaXNTaGlmdEVudGVyICYmIGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZm9jdXNCbG9ja1BhdGggPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksIGZvY3VzQmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNMaXN0QmxvY2soZm9jdXNCbG9jaykpIHtcbiAgICAgICAgICBlZGl0b3IucHRlRW5kTGlzdCgpICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckMSA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aEluc2VydERhdGFcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoSW5zZXJ0RGF0YShlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IGJsb2NrVHlwZU5hbWUgPSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBzcGFuVHlwZU5hbWUgPSBzY2hlbWFUeXBlcy5zcGFuLm5hbWUsIHdoaXRlc3BhY2VPblBhc3RlTW9kZSA9IHNjaGVtYVR5cGVzLmJsb2NrLm9wdGlvbnMudW5zdGFibGVfd2hpdGVzcGFjZU9uUGFzdGVNb2RlLCB0b1BsYWluVGV4dCA9IChibG9ja3MpID0+IGJsb2Nrcy5tYXAoKGJsb2NrKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spID8gYmxvY2suY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuX3R5cGUgPT09IHNwYW5UeXBlTmFtZSA/IGNoaWxkLnRleHQgOiBgWyR7c2NoZW1hVHlwZXMuaW5saW5lT2JqZWN0cy5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGNoaWxkLl90eXBlKT8udGl0bGUgfHwgXCJPYmplY3RcIn1dYCkuam9pbihcIlwiKSA6IGBbJHtzY2hlbWFUeXBlcy5ibG9ja09iamVjdHMuZmluZCgodCkgPT4gdC5uYW1lID09PSBibG9jay5fdHlwZSk/LnRpdGxlIHx8IFwiT2JqZWN0XCJ9XWApLmpvaW4oYFxuXG5gKTtcbiAgICByZXR1cm4gZWRpdG9yLnNldEZyYWdtZW50RGF0YSA9IChkYXRhLCBvcmlnaW5FdmVudCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG4gICAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKSwgc3RhcnRWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydC5wYXRoXG4gICAgICB9KSwgZW5kVm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdDogZW5kLnBhdGhcbiAgICAgIH0pO1xuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiYgIXN0YXJ0Vm9pZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZG9tUmFuZ2UgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIGxldCBjb250ZW50cyA9IGRvbVJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICAgIGlmIChlbmRWb2lkKSB7XG4gICAgICAgIGNvbnN0IFt2b2lkTm9kZV0gPSBlbmRWb2lkLCByID0gZG9tUmFuZ2UuY2xvbmVSYW5nZSgpLCBkb21Ob2RlID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgdm9pZE5vZGUpO1xuICAgICAgICByLnNldEVuZEFmdGVyKGRvbU5vZGUpLCBjb250ZW50cyA9IHIuY2xvbmVDb250ZW50cygpO1xuICAgICAgfVxuICAgICAgQXJyYXkuZnJvbShjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtc2xhdGUtemVyby13aWR0aF1cIikpLmZvckVhY2goKHp3KSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTmV3bGluZSA9IHp3LmdldEF0dHJpYnV0ZShcImRhdGEtc2xhdGUtemVyby13aWR0aFwiKSA9PT0gXCJuXCI7XG4gICAgICAgIHp3LnRleHRDb250ZW50ID0gaXNOZXdsaW5lID8gYFxuYCA6IFwiXCI7XG4gICAgICB9KSwgQXJyYXkuZnJvbShjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSkuZm9yRWFjaCgoZWxtKSA9PiB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIiksIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXNsYXRlLWlubGluZVwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtbGVhZlwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtbm9kZVwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtc3BhY2VyXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1zdHJpbmdcIiksIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXNsYXRlLXplcm8td2lkdGhcIiksIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGVsbS5hdHRyaWJ1dGVzKVxuICAgICAgICAgIGVsbS5oYXNBdHRyaWJ1dGUoa2V5KSAmJiBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRpdiA9IGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChjb250ZW50cyksIGRpdi5zZXRBdHRyaWJ1dGUoXCJoaWRkZW5cIiwgXCJ0cnVlXCIpLCBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIGNvbnN0IGFzSFRNTCA9IGRpdi5pbm5lckhUTUw7XG4gICAgICBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZWRpdG9yLmdldEZyYWdtZW50KCksIHBvcnRhYmxlVGV4dCA9IGZyb21TbGF0ZVZhbHVlKGZyYWdtZW50LCBibG9ja1R5cGVOYW1lKSwgYXNKU09OID0gSlNPTi5zdHJpbmdpZnkocG9ydGFibGVUZXh0KSwgYXNQbGFpblRleHQgPSB0b1BsYWluVGV4dChwb3J0YWJsZVRleHQpO1xuICAgICAgZGF0YS5jbGVhckRhdGEoKSwgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCBhc1BsYWluVGV4dCksIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBhc0hUTUwpLCBkYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9qc29uXCIsIGFzSlNPTiksIGRhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dFwiLCBhc0pTT04pLCBkZWJ1ZyQxKFwidGV4dFwiLCBhc1BsYWluVGV4dCksIGRhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dC1ldmVudC1vcmlnaW5cIiwgb3JpZ2luRXZlbnQgfHwgXCJleHRlcm5hbFwiKSwgZGVidWckMShcIlNldCBmcmFnbWVudCBkYXRhXCIsIGFzSlNPTiwgYXNIVE1MKTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0UG9ydGFibGVUZXh0RGF0YSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHBUZXh0ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIpLCBvcmlnaW4gPSBkYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHQtZXZlbnQtb3JpZ2luXCIpO1xuICAgICAgaWYgKGRlYnVnJDEoYEluc2VydGluZyBwb3J0YWJsZSB0ZXh0IGZyb20gJHtvcmlnaW59IGV2ZW50YCwgcFRleHQpLCBwVGV4dCkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHBUZXh0KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkKSAmJiBwYXJzZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHNsYXRlVmFsdWUgPSBfcmVnZW5lcmF0ZUtleXMoZWRpdG9yLCB0b1NsYXRlVmFsdWUocGFyc2VkLCB7XG4gICAgICAgICAgICBzY2hlbWFUeXBlc1xuICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yLCBzcGFuVHlwZU5hbWUsIHNjaGVtYVR5cGVzKSwgdmFsaWRhdGlvbiA9IHZhbGlkYXRlVmFsdWUocGFyc2VkLCBzY2hlbWFUeXBlcywgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcik7XG4gICAgICAgICAgaWYgKCF2YWxpZGF0aW9uLnZhbGlkICYmICF2YWxpZGF0aW9uLnJlc29sdXRpb24/LmF1dG9SZXNvbHZlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvckRlc2NyaXB0aW9uID0gYCR7dmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5kZXNjcmlwdGlvbn1gO1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIG5hbWU6IFwicGFzdGVFcnJvclwiLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZXJyb3JEZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgZGF0YTogdmFsaWRhdGlvblxuICAgICAgICAgICAgfSksIGRlYnVnJDEoXCJJbnZhbGlkIGluc2VydCByZXN1bHRcIiwgdmFsaWRhdGlvbiksICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX2luc2VydEZyYWdtZW50KGVkaXRvciwgc2xhdGVWYWx1ZSwgc2NoZW1hVHlwZXMpLCAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGVkaXRvci5pbnNlcnRUZXh0T3JIVE1MRGF0YSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiBkZWJ1ZyQxKFwiTm8gc2VsZWN0aW9uLCBub3QgaW5zZXJ0aW5nXCIpLCAhMTtcbiAgICAgIGNvbnN0IGh0bWwgPSBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIHRleHQgPSBkYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgaWYgKGh0bWwgfHwgdGV4dCkge1xuICAgICAgICBkZWJ1ZyQxKFwiSW5zZXJ0aW5nIGRhdGFcIiwgZGF0YSk7XG4gICAgICAgIGxldCBwb3J0YWJsZVRleHQsIGZyYWdtZW50LCBpbnNlcnRlZFR5cGU7XG4gICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgaWYgKHBvcnRhYmxlVGV4dCA9IGh0bWxUb0Jsb2NrcyhodG1sLCBzY2hlbWFUeXBlcy5wb3J0YWJsZVRleHQsIHtcbiAgICAgICAgICAgIHVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZTogd2hpdGVzcGFjZU9uUGFzdGVNb2RlXG4gICAgICAgICAgfSkubWFwKChibG9jaykgPT4gbm9ybWFsaXplQmxvY2soYmxvY2ssIHtcbiAgICAgICAgICAgIGJsb2NrVHlwZU5hbWVcbiAgICAgICAgICB9KSksIGZyYWdtZW50ID0gdG9TbGF0ZVZhbHVlKHBvcnRhYmxlVGV4dCwge1xuICAgICAgICAgICAgc2NoZW1hVHlwZXNcbiAgICAgICAgICB9KSwgaW5zZXJ0ZWRUeXBlID0gXCJIVE1MXCIsIHBvcnRhYmxlVGV4dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGV4dFRvSHRtbCA9IGA8aHRtbD48Ym9keT4ke2VzY2FwZUh0bWwodGV4dCkuc3BsaXQoL1xcbnsyLH0vKS5tYXAoKGxpbmUpID0+IGxpbmUgPyBgPHA+JHtsaW5lLnJlcGxhY2UoLyg/OlxcclxcbnxcXHJ8XFxuKS9nLCBcIjxici8+XCIpfTwvcD5gIDogXCI8cD48L3A+XCIpLmpvaW4oXCJcIil9PC9ib2R5PjwvaHRtbD5gO1xuICAgICAgICAgIHBvcnRhYmxlVGV4dCA9IGh0bWxUb0Jsb2Nrcyh0ZXh0VG9IdG1sLCBzY2hlbWFUeXBlcy5wb3J0YWJsZVRleHQpLm1hcCgoYmxvY2spID0+IG5vcm1hbGl6ZUJsb2NrKGJsb2NrLCB7XG4gICAgICAgICAgICBibG9ja1R5cGVOYW1lXG4gICAgICAgICAgfSkpLCBmcmFnbWVudCA9IHRvU2xhdGVWYWx1ZShwb3J0YWJsZVRleHQsIHtcbiAgICAgICAgICAgIHNjaGVtYVR5cGVzXG4gICAgICAgICAgfSksIGluc2VydGVkVHlwZSA9IFwidGV4dFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZVZhbHVlKHBvcnRhYmxlVGV4dCwgc2NoZW1hVHlwZXMsIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IpO1xuICAgICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRlc2NyaXB0aW9uID0gYENvdWxkIG5vdCB2YWxpZGF0ZSB0aGUgcmVzdWx0aW5nIHBvcnRhYmxlIHRleHQgdG8gaW5zZXJ0LlxuJHt2YWxpZGF0aW9uLnJlc29sdXRpb24/LmRlc2NyaXB0aW9ufVxuVHJ5IHRvIGluc2VydCBhcyBwbGFpbiB0ZXh0IChzaGlmdC1wYXN0ZSkgaW5zdGVhZC5gO1xuICAgICAgICAgIHJldHVybiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIG5hbWU6IFwicGFzdGVFcnJvclwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGVycm9yRGVzY3JpcHRpb24sXG4gICAgICAgICAgICBkYXRhOiB2YWxpZGF0aW9uXG4gICAgICAgICAgfSksIGRlYnVnJDEoXCJJbnZhbGlkIGluc2VydCByZXN1bHRcIiwgdmFsaWRhdGlvbiksICExO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWJ1ZyQxKGBJbnNlcnRpbmcgJHtpbnNlcnRlZFR5cGV9IGZyYWdtZW50IGF0ICR7SlNPTi5zdHJpbmdpZnkoZWRpdG9yLnNlbGVjdGlvbil9YCksIF9pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBzY2hlbWFUeXBlcyksICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGVkaXRvci5pbnNlcnREYXRhID0gKGRhdGEpID0+IHtcbiAgICAgIGVkaXRvci5pbnNlcnRQb3J0YWJsZVRleHREYXRhKGRhdGEpIHx8IGVkaXRvci5pbnNlcnRUZXh0T3JIVE1MRGF0YShkYXRhKTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0RnJhZ21lbnREYXRhID0gKGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIpO1xuICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZnJhZ21lbnQpO1xuICAgICAgICByZXR1cm4gZWRpdG9yLmluc2VydEZyYWdtZW50KHBhcnNlZCksICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGVudGl0eU1hcCA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjMzk7XCIsXG4gIFwiL1wiOiBcIiYjeDJGO1wiLFxuICBcImBcIjogXCImI3g2MDtcIixcbiAgXCI9XCI6IFwiJiN4M0Q7XCJcbn07XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvWyY8PlwiJ2A9L10vZywgKHMpID0+IGVudGl0eU1hcFtzXSk7XG59XG5mdW5jdGlvbiBfcmVnZW5lcmF0ZUtleXMoZWRpdG9yLCBmcmFnbWVudCwga2V5R2VuZXJhdG9yLCBzcGFuVHlwZU5hbWUsIGVkaXRvclR5cGVzKSB7XG4gIHJldHVybiBmcmFnbWVudC5tYXAoKG5vZGUpID0+IHtcbiAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgLi4ubm9kZVxuICAgIH07XG4gICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhuZXdOb2RlKSkge1xuICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSBlZGl0b3JUeXBlcy5hbm5vdGF0aW9ucy5tYXAoKHQpID0+IHQubmFtZSk7XG4gICAgICBpZiAoYW5ub3RhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtYXJrRGVmcyxcbiAgICAgICAgICAuLi5OZXdOb2RlTm9EZWZzXG4gICAgICAgIH0gPSBuZXdOb2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLk5ld05vZGVOb0RlZnMsXG4gICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICgobmV3Tm9kZS5tYXJrRGVmcyB8fCBbXSkuc29tZSgoZGVmKSA9PiAhYW5ub3RhdGlvbnMuaW5jbHVkZXMoZGVmLl90eXBlKSkpIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZEFubm90YXRpb25zID0gKG5ld05vZGUubWFya0RlZnMgfHwgW10pLmZpbHRlcigoZGVmKSA9PiBhbm5vdGF0aW9ucy5pbmNsdWRlcyhkZWYuX3R5cGUpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5uZXdOb2RlLFxuICAgICAgICAgIG1hcmtEZWZzOiBhbGxvd2VkQW5ub3RhdGlvbnMsXG4gICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG5ld05vZGUubWFya0RlZnMgPSAobmV3Tm9kZS5tYXJrRGVmcyB8fCBbXSkubWFwKChkZWYpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkS2V5ID0gZGVmLl9rZXksIG5ld0tleSA9IGtleUdlbmVyYXRvcigpO1xuICAgICAgICByZXR1cm4gbmV3Tm9kZS5jaGlsZHJlbiA9IG5ld05vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuX3R5cGUgPT09IHNwYW5UeXBlTmFtZSAmJiBlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgPyB7XG4gICAgICAgICAgLi4uY2hpbGQsXG4gICAgICAgICAgbWFya3M6IGNoaWxkLm1hcmtzICYmIGNoaWxkLm1hcmtzLmluY2x1ZGVzKG9sZEtleSkgPyBbLi4uY2hpbGQubWFya3NdLmZpbHRlcigobWFyaykgPT4gbWFyayAhPT0gb2xkS2V5KS5jb25jYXQobmV3S2V5KSA6IGNoaWxkLm1hcmtzXG4gICAgICAgIH0gOiBjaGlsZCksIHtcbiAgICAgICAgICAuLi5kZWYsXG4gICAgICAgICAgX2tleTogbmV3S2V5XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZVdpdGhOZXdLZXlzID0ge1xuICAgICAgLi4ubmV3Tm9kZSxcbiAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgfTtcbiAgICByZXR1cm4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGVXaXRoTmV3S2V5cykgJiYgKG5vZGVXaXRoTmV3S2V5cy5jaGlsZHJlbiA9IG5vZGVXaXRoTmV3S2V5cy5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiAoe1xuICAgICAgLi4uY2hpbGQsXG4gICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKVxuICAgIH0pKSksIG5vZGVXaXRoTmV3S2V5cztcbiAgfSk7XG59XG5mdW5jdGlvbiBfaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCwgc2NoZW1hVHlwZXMpIHtcbiAgZWRpdG9yLndpdGhvdXROb3JtYWxpemluZygoKSA9PiB7XG4gICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFtmb2N1c0Jsb2NrLCBmb2N1c1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLCB7XG4gICAgICBkZXB0aDogMVxuICAgIH0pO1xuICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKGZyYWdtZW50WzBdKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYXJrRGVmc1xuICAgICAgfSA9IGZvY3VzQmxvY2s7XG4gICAgICBkZWJ1ZyQxKFwiTWl4aW5nIG1hcmtEZWZzIG9mIGZvY3VzQmxvY2sgYW5kIGZyYWdtZW50c1swXSBibG9ja1wiLCBtYXJrRGVmcywgZnJhZ21lbnRbMF0ubWFya0RlZnMpLCBpc0VxdWFsKG1hcmtEZWZzLCBmcmFnbWVudFswXS5tYXJrRGVmcykgfHwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWFya0RlZnM6IHVuaXEoWy4uLmZyYWdtZW50WzBdLm1hcmtEZWZzIHx8IFtdLCAuLi5tYXJrRGVmcyB8fCBbXV0pXG4gICAgICB9LCB7XG4gICAgICAgIGF0OiBmb2N1c1BhdGgsXG4gICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgIHZvaWRzOiAhMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlzRXF1YWxUb0VtcHR5RWRpdG9yKGVkaXRvci5jaGlsZHJlbiwgc2NoZW1hVHlwZXMpID8gKFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBbMCwgMF1cbiAgICB9KSwgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50KSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBbMF1cbiAgICB9KSkgOiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG59XG5mdW5jdGlvbiB3aXRoU3luY1JhbmdlRGVjb3JhdGlvbnMoc2xhdGVFZGl0b3IsIHN5bmNSYW5nZURlY29yYXRpb25zKSB7XG4gIGNvbnN0IG9yaWdpbmFsQXBwbHkgPSBzbGF0ZUVkaXRvci5hcHBseTtcbiAgcmV0dXJuIHNsYXRlRWRpdG9yLmFwcGx5ID0gKG9wKSA9PiB7XG4gICAgb3JpZ2luYWxBcHBseShvcCksIG9wLnR5cGUgIT09IFwic2V0X3NlbGVjdGlvblwiICYmIHN5bmNSYW5nZURlY29yYXRpb25zKG9wKTtcbiAgfSwgKCkgPT4ge1xuICAgIHNsYXRlRWRpdG9yLmFwcGx5ID0gb3JpZ2luYWxBcHBseTtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudDpFZGl0YWJsZVwiKSwgUExBQ0VIT0xERVJfU1RZTEUgPSB7XG4gIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgbGVmdDogMCxcbiAgcmlnaHQ6IDBcbn0sIFBvcnRhYmxlVGV4dEVkaXRhYmxlID0gZm9yd2FyZFJlZihmdW5jdGlvbihwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gIGNvbnN0IHtcbiAgICBob3RrZXlzLFxuICAgIG9uQmx1cixcbiAgICBvbkZvY3VzLFxuICAgIG9uQmVmb3JlSW5wdXQsXG4gICAgb25QYXN0ZSxcbiAgICBvbkNvcHksXG4gICAgb25DbGljayxcbiAgICByYW5nZURlY29yYXRpb25zLFxuICAgIHJlbmRlckFubm90YXRpb24sXG4gICAgcmVuZGVyQmxvY2ssXG4gICAgcmVuZGVyQ2hpbGQsXG4gICAgcmVuZGVyRGVjb3JhdG9yLFxuICAgIHJlbmRlckxpc3RJdGVtLFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlclN0eWxlLFxuICAgIHNlbGVjdGlvbjogcHJvcHNTZWxlY3Rpb24sXG4gICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcsXG4gICAgc3BlbGxDaGVjayxcbiAgICAuLi5yZXN0UHJvcHNcbiAgfSA9IHByb3BzLCBwb3J0YWJsZVRleHRFZGl0b3IgPSB1c2VQb3J0YWJsZVRleHRFZGl0b3IoKSwgcmVmID0gdXNlUmVmKG51bGwpLCBbZWRpdGFibGVFbGVtZW50LCBzZXRFZGl0YWJsZUVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCksIFtoYXNJbnZhbGlkVmFsdWUsIHNldEhhc0ludmFsaWRWYWx1ZV0gPSB1c2VTdGF0ZSghMSksIFtyYW5nZURlY29yYXRpb25TdGF0ZSwgc2V0UmFuZ2VEZWNvcmF0aW9uc1N0YXRlXSA9IHVzZVN0YXRlKFtdKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+IHJlZi5jdXJyZW50KTtcbiAgY29uc3QgcmFuZ2VEZWNvcmF0aW9uc1JlZiA9IHVzZVJlZihyYW5nZURlY29yYXRpb25zKSwgZWRpdG9yQWN0b3IgPSB1c2VDb250ZXh0KEVkaXRvckFjdG9yQ29udGV4dCksIHJlYWRPbmx5ID0gdXNlU2VsZWN0b3IoZWRpdG9yQWN0b3IsIChzKSA9PiBzLmNvbnRleHQucmVhZE9ubHkpLCBzY2hlbWFUeXBlcyA9IHVzZVNlbGVjdG9yKGVkaXRvckFjdG9yLCAoc18wKSA9PiBzXzAuY29udGV4dC5zY2hlbWEpLCBzbGF0ZUVkaXRvciA9IHVzZVNsYXRlKCksIGJsb2NrVHlwZU5hbWUgPSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lO1xuICB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB3aXRoSW5zZXJ0RGF0YSA9IGNyZWF0ZVdpdGhJbnNlcnREYXRhKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcyk7XG4gICAgaWYgKHJlYWRPbmx5KVxuICAgICAgcmV0dXJuIGRlYnVnKFwiRWRpdGFibGUgaXMgaW4gcmVhZCBvbmx5IG1vZGVcIiksIHdpdGhJbnNlcnREYXRhKHNsYXRlRWRpdG9yKTtcbiAgICBjb25zdCB3aXRoSG90S2V5cyA9IGNyZWF0ZVdpdGhIb3RrZXlzKGVkaXRvckFjdG9yLCBwb3J0YWJsZVRleHRFZGl0b3IsIGhvdGtleXMpO1xuICAgIHJldHVybiBkZWJ1ZyhcIkVkaXRhYmxlIGlzIGluIGVkaXQgbW9kZVwiKSwgd2l0aEluc2VydERhdGEod2l0aEhvdEtleXMoc2xhdGVFZGl0b3IpKTtcbiAgfSwgW2VkaXRvckFjdG9yLCBob3RrZXlzLCBwb3J0YWJsZVRleHRFZGl0b3IsIHJlYWRPbmx5LCBzY2hlbWFUeXBlcywgc2xhdGVFZGl0b3JdKTtcbiAgY29uc3QgcmVuZGVyRWxlbWVudCA9IHVzZUNhbGxiYWNrKChlUHJvcHMpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goRWxlbWVudCwgeyAuLi5lUHJvcHMsIHJlYWRPbmx5LCByZW5kZXJCbG9jaywgcmVuZGVyQ2hpbGQsIHJlbmRlckxpc3RJdGVtLCByZW5kZXJTdHlsZSwgc2NoZW1hVHlwZXMsIHNwZWxsQ2hlY2sgfSksIFtzY2hlbWFUeXBlcywgc3BlbGxDaGVjaywgcmVhZE9ubHksIHJlbmRlckJsb2NrLCByZW5kZXJDaGlsZCwgcmVuZGVyTGlzdEl0ZW0sIHJlbmRlclN0eWxlXSksIHJlbmRlckxlYWYgPSB1c2VDYWxsYmFjaygobFByb3BzKSA9PiB7XG4gICAgaWYgKGxQcm9wcy5sZWFmLl90eXBlID09PSBcInNwYW5cIikge1xuICAgICAgbGV0IHJlbmRlcmVkID0gLyogQF9fUFVSRV9fICovIGpzeChMZWFmLCB7IC4uLmxQcm9wcywgZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzLCByZW5kZXJBbm5vdGF0aW9uLCByZW5kZXJDaGlsZCwgcmVuZGVyRGVjb3JhdG9yLCByZWFkT25seSB9KTtcbiAgICAgIGlmIChyZW5kZXJQbGFjZWhvbGRlciAmJiBsUHJvcHMubGVhZi5wbGFjZWhvbGRlciAmJiBsUHJvcHMudGV4dC50ZXh0ID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IHN0eWxlOiBQTEFDRUhPTERFUl9TVFlMRSwgY29udGVudEVkaXRhYmxlOiAhMSwgY2hpbGRyZW46IHJlbmRlclBsYWNlaG9sZGVyKCkgfSksXG4gICAgICAgICAgcmVuZGVyZWRcbiAgICAgICAgXSB9KTtcbiAgICAgIGNvbnN0IGRlY29yYXRpb24gPSBsUHJvcHMubGVhZi5yYW5nZURlY29yYXRpb247XG4gICAgICByZXR1cm4gZGVjb3JhdGlvbiAmJiAocmVuZGVyZWQgPSBkZWNvcmF0aW9uLmNvbXBvbmVudCh7XG4gICAgICAgIGNoaWxkcmVuOiByZW5kZXJlZFxuICAgICAgfSkpLCByZW5kZXJlZDtcbiAgICB9XG4gICAgcmV0dXJuIGxQcm9wcy5jaGlsZHJlbjtcbiAgfSwgW2VkaXRvckFjdG9yLCByZWFkT25seSwgcmVuZGVyQW5ub3RhdGlvbiwgcmVuZGVyQ2hpbGQsIHJlbmRlckRlY29yYXRvciwgcmVuZGVyUGxhY2Vob2xkZXIsIHNjaGVtYVR5cGVzXSksIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHByb3BzU2VsZWN0aW9uKSB7XG4gICAgICBkZWJ1ZyhgU2VsZWN0aW9uIGZyb20gcHJvcHMgJHtKU09OLnN0cmluZ2lmeShwcm9wc1NlbGVjdGlvbil9YCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkU2VsZWN0aW9uID0gbm9ybWFsaXplU2VsZWN0aW9uKHByb3BzU2VsZWN0aW9uLCBmcm9tU2xhdGVWYWx1ZShzbGF0ZUVkaXRvci5jaGlsZHJlbiwgYmxvY2tUeXBlTmFtZSkpO1xuICAgICAgaWYgKG5vcm1hbGl6ZWRTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgZGVidWcoYE5vcm1hbGl6ZWQgc2VsZWN0aW9uIGZyb20gcHJvcHMgJHtKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VsZWN0aW9uKX1gKTtcbiAgICAgICAgY29uc3Qgc2xhdGVSYW5nZSA9IHRvU2xhdGVSYW5nZShub3JtYWxpemVkU2VsZWN0aW9uLCBzbGF0ZUVkaXRvcik7XG4gICAgICAgIHNsYXRlUmFuZ2UgJiYgKFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBzbGF0ZVJhbmdlKSwgc2xhdGVFZGl0b3Iub3BlcmF0aW9ucy5zb21lKChvKSA9PiBvLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSB8fCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgIHNlbGVjdGlvbjogbm9ybWFsaXplZFNlbGVjdGlvblxuICAgICAgICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbYmxvY2tUeXBlTmFtZSwgZWRpdG9yQWN0b3IsIHByb3BzU2VsZWN0aW9uLCBzbGF0ZUVkaXRvcl0pLCBzeW5jUmFuZ2VEZWNvcmF0aW9ucyA9IHVzZUNhbGxiYWNrKChvcGVyYXRpb24pID0+IHtcbiAgICBpZiAocmFuZ2VEZWNvcmF0aW9ucyAmJiByYW5nZURlY29yYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5ld1NsYXRlUmFuZ2VzID0gW107XG4gICAgICBpZiAocmFuZ2VEZWNvcmF0aW9ucy5mb3JFYWNoKChyYW5nZURlY29yYXRpb25JdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHNsYXRlUmFuZ2VfMCA9IHRvU2xhdGVSYW5nZShyYW5nZURlY29yYXRpb25JdGVtLnNlbGVjdGlvbiwgc2xhdGVFZGl0b3IpO1xuICAgICAgICBpZiAoIVJhbmdlLmlzUmFuZ2Uoc2xhdGVSYW5nZV8wKSkge1xuICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbkl0ZW0ub25Nb3ZlZCAmJiByYW5nZURlY29yYXRpb25JdGVtLm9uTW92ZWQoe1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uOiByYW5nZURlY29yYXRpb25JdGVtLFxuICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1JhbmdlO1xuICAgICAgICBpZiAob3BlcmF0aW9uICYmIChuZXdSYW5nZSA9IG1vdmVSYW5nZUJ5T3BlcmF0aW9uKHNsYXRlUmFuZ2VfMCwgb3BlcmF0aW9uKSwgbmV3UmFuZ2UgJiYgbmV3UmFuZ2UgIT09IHNsYXRlUmFuZ2VfMCB8fCBuZXdSYW5nZSA9PT0gbnVsbCAmJiBzbGF0ZVJhbmdlXzApKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0VmFsdWUocG9ydGFibGVUZXh0RWRpdG9yKSwgbmV3UmFuZ2VTZWxlY3Rpb24gPSB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlLCBuZXdSYW5nZSwgc2NoZW1hVHlwZXMpO1xuICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbkl0ZW0ub25Nb3ZlZCAmJiByYW5nZURlY29yYXRpb25JdGVtLm9uTW92ZWQoe1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uOiBuZXdSYW5nZVNlbGVjdGlvbixcbiAgICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbjogcmFuZ2VEZWNvcmF0aW9uSXRlbSxcbiAgICAgICAgICAgIG9yaWdpbjogXCJsb2NhbFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3UmFuZ2UgIT09IG51bGwgJiYgbmV3U2xhdGVSYW5nZXMucHVzaCh7XG4gICAgICAgICAgLi4ubmV3UmFuZ2UgfHwgc2xhdGVSYW5nZV8wLFxuICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbjogcmFuZ2VEZWNvcmF0aW9uSXRlbVxuICAgICAgICB9KTtcbiAgICAgIH0pLCBuZXdTbGF0ZVJhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldFJhbmdlRGVjb3JhdGlvbnNTdGF0ZShuZXdTbGF0ZVJhbmdlcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0UmFuZ2VEZWNvcmF0aW9uc1N0YXRlKChyYW5nZURlY29yYXRpb25TdGF0ZV8wKSA9PiByYW5nZURlY29yYXRpb25TdGF0ZV8wLmxlbmd0aCA+IDAgPyBbXSA6IHJhbmdlRGVjb3JhdGlvblN0YXRlXzApO1xuICB9LCBbcG9ydGFibGVUZXh0RWRpdG9yLCByYW5nZURlY29yYXRpb25zLCBzY2hlbWFUeXBlcywgc2xhdGVFZGl0b3JdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBvblJlYWR5ID0gZWRpdG9yQWN0b3Iub24oXCJyZWFkeVwiLCAoKSA9PiB7XG4gICAgICByZXN0b3JlU2VsZWN0aW9uRnJvbVByb3BzKCk7XG4gICAgfSksIG9uSW52YWxpZFZhbHVlID0gZWRpdG9yQWN0b3Iub24oXCJpbnZhbGlkIHZhbHVlXCIsICgpID0+IHtcbiAgICAgIHNldEhhc0ludmFsaWRWYWx1ZSghMCk7XG4gICAgfSksIG9uVmFsdWVDaGFuZ2VkID0gZWRpdG9yQWN0b3Iub24oXCJ2YWx1ZSBjaGFuZ2VkXCIsICgpID0+IHtcbiAgICAgIHNldEhhc0ludmFsaWRWYWx1ZSghMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9uUmVhZHkudW5zdWJzY3JpYmUoKSwgb25JbnZhbGlkVmFsdWUudW5zdWJzY3JpYmUoKSwgb25WYWx1ZUNoYW5nZWQudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbZWRpdG9yQWN0b3IsIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHNdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBwcm9wc1NlbGVjdGlvbiAmJiAhaGFzSW52YWxpZFZhbHVlICYmIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMoKTtcbiAgfSwgW2hhc0ludmFsaWRWYWx1ZSwgcHJvcHNTZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHNdKTtcbiAgY29uc3QgW3N5bmNlZFJhbmdlRGVjb3JhdGlvbnMsIHNldFN5bmNlZFJhbmdlRGVjb3JhdGlvbnNdID0gdXNlU3RhdGUoITEpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHN5bmNlZFJhbmdlRGVjb3JhdGlvbnMgfHwgKHNldFN5bmNlZFJhbmdlRGVjb3JhdGlvbnMoITApLCBzeW5jUmFuZ2VEZWNvcmF0aW9ucygpKTtcbiAgfSwgW3N5bmNSYW5nZURlY29yYXRpb25zLCBzeW5jZWRSYW5nZURlY29yYXRpb25zXSksIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNFcXVhbChyYW5nZURlY29yYXRpb25zLCByYW5nZURlY29yYXRpb25zUmVmLmN1cnJlbnQpIHx8IHN5bmNSYW5nZURlY29yYXRpb25zKCksIHJhbmdlRGVjb3JhdGlvbnNSZWYuY3VycmVudCA9IHJhbmdlRGVjb3JhdGlvbnM7XG4gIH0sIFtyYW5nZURlY29yYXRpb25zLCBzeW5jUmFuZ2VEZWNvcmF0aW9uc10pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHRlYXJkb3duID0gd2l0aFN5bmNSYW5nZURlY29yYXRpb25zKHNsYXRlRWRpdG9yLCBzeW5jUmFuZ2VEZWNvcmF0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHRlYXJkb3duKCk7XG4gIH0sIFtzbGF0ZUVkaXRvciwgc3luY1JhbmdlRGVjb3JhdGlvbnNdKTtcbiAgY29uc3QgaGFuZGxlQ29weSA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgIG9uQ29weSAmJiBvbkNvcHkoZXZlbnQpICE9PSB2b2lkIDAgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSwgW29uQ29weV0pLCBoYW5kbGVQYXN0ZSA9IHVzZUNhbGxiYWNrKChldmVudF8wKSA9PiB7XG4gICAgY29uc3QgdmFsdWVfMCA9IFBvcnRhYmxlVGV4dEVkaXRvci5nZXRWYWx1ZShwb3J0YWJsZVRleHRFZGl0b3IpLCBwYXRoID0gdG9Qb3J0YWJsZVRleHRSYW5nZSh2YWx1ZV8wLCBzbGF0ZUVkaXRvci5zZWxlY3Rpb24sIHNjaGVtYVR5cGVzKT8uZm9jdXMucGF0aCB8fCBbXSwgb25QYXN0ZVJlc3VsdCA9IG9uUGFzdGU/Lih7XG4gICAgICBldmVudDogZXZlbnRfMCxcbiAgICAgIHZhbHVlOiB2YWx1ZV8wLFxuICAgICAgcGF0aCxcbiAgICAgIHNjaGVtYVR5cGVzXG4gICAgfSk7XG4gICAgb25QYXN0ZVJlc3VsdCB8fCAhc2xhdGVFZGl0b3Iuc2VsZWN0aW9uID8gKGV2ZW50XzAucHJldmVudERlZmF1bHQoKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImxvYWRpbmdcIlxuICAgIH0pLCBQcm9taXNlLnJlc29sdmUob25QYXN0ZVJlc3VsdCkudGhlbigocmVzdWx0XzApID0+IHtcbiAgICAgIGRlYnVnKFwiQ3VzdG9tIHBhc3RlIGZ1bmN0aW9uIGZyb20gY2xpZW50IHJlc29sdmVkXCIsIHJlc3VsdF8wKSwgIXJlc3VsdF8wIHx8ICFyZXN1bHRfMC5pbnNlcnQgPyAoZGVidWcoXCJObyByZXN1bHQgZnJvbSBjdXN0b20gcGFzdGUgaGFuZGxlciwgcGFzdGluZyBub3JtYWxseVwiKSwgc2xhdGVFZGl0b3IuaW5zZXJ0RGF0YShldmVudF8wLmNsaXBib2FyZERhdGEpKSA6IHJlc3VsdF8wLmluc2VydCA/IHNsYXRlRWRpdG9yLmluc2VydEZyYWdtZW50KHRvU2xhdGVWYWx1ZShyZXN1bHRfMC5pbnNlcnQsIHtcbiAgICAgICAgc2NoZW1hVHlwZXNcbiAgICAgIH0pKSA6IGNvbnNvbGUud2FybihcIllvdXIgb25QYXN0ZSBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcgdW5leHBlY3RlZDpcIiwgcmVzdWx0XzApO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4gKGNvbnNvbGUuZXJyb3IoZXJyb3IpLCBlcnJvcikpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiZG9uZSBsb2FkaW5nXCJcbiAgICAgIH0pO1xuICAgIH0pKSA6IGV2ZW50XzAubmF0aXZlRXZlbnQuY2xpcGJvYXJkRGF0YSAmJiAoZXZlbnRfMC5wcmV2ZW50RGVmYXVsdCgpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJwYXN0ZVwiLFxuICAgICAgICBjbGlwYm9hcmREYXRhOiBldmVudF8wLm5hdGl2ZUV2ZW50LmNsaXBib2FyZERhdGFcbiAgICAgIH0sXG4gICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yXG4gICAgfSkpLCBkZWJ1ZyhcIk5vIHJlc3VsdCBmcm9tIGN1c3RvbSBwYXN0ZSBoYW5kbGVyLCBwYXN0aW5nIG5vcm1hbGx5XCIpO1xuICB9LCBbZWRpdG9yQWN0b3IsIG9uUGFzdGUsIHBvcnRhYmxlVGV4dEVkaXRvciwgc2NoZW1hVHlwZXMsIHNsYXRlRWRpdG9yXSksIGhhbmRsZU9uRm9jdXMgPSB1c2VDYWxsYmFjaygoZXZlbnRfMSkgPT4ge1xuICAgIGlmIChvbkZvY3VzICYmIG9uRm9jdXMoZXZlbnRfMSksICFldmVudF8xLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICBzZWxlY3Rpb24gPT09IG51bGwgJiYgKFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBFZGl0b3Iuc3RhcnQoc2xhdGVFZGl0b3IsIFtdKSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJmb2N1c2VkXCIsXG4gICAgICAgIGV2ZW50OiBldmVudF8xXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFBvcnRhYmxlVGV4dEVkaXRvci5nZXRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICAgIHNlbGVjdGlvbiA9PT0gbmV3U2VsZWN0aW9uICYmIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VkaXRvckFjdG9yLCBvbkZvY3VzLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKGV2ZW50XzIpID0+IHtcbiAgICBvbkNsaWNrICYmIG9uQ2xpY2soZXZlbnRfMik7XG4gICAgY29uc3QgZm9jdXNCbG9ja1BhdGggPSBzbGF0ZUVkaXRvci5zZWxlY3Rpb24gPyBzbGF0ZUVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSA6IHZvaWQgMCwgZm9jdXNCbG9jayA9IGZvY3VzQmxvY2tQYXRoID8gTm9kZS5kZXNjZW5kYW50KHNsYXRlRWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCkgOiB2b2lkIDAsIFtfLCBsYXN0Tm9kZVBhdGhdID0gTm9kZS5sYXN0KHNsYXRlRWRpdG9yLCBbXSksIGxhc3RCbG9ja1BhdGggPSBsYXN0Tm9kZVBhdGguc2xpY2UoMCwgMSksIGxhc3ROb2RlRm9jdXNlZCA9IGZvY3VzQmxvY2tQYXRoID8gUGF0aC5lcXVhbHMobGFzdEJsb2NrUGF0aCwgZm9jdXNCbG9ja1BhdGgpIDogITEsIGxhc3RCbG9ja0lzVm9pZCA9IGZvY3VzQmxvY2sgPyAhc2xhdGVFZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykgOiAhMTtcbiAgICBzbGF0ZUVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKSAmJiBsYXN0Tm9kZUZvY3VzZWQgJiYgbGFzdEJsb2NrSXNWb2lkICYmIChUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBzbGF0ZUVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgZGVjb3JhdG9yczogW11cbiAgICB9KSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpO1xuICB9LCBbb25DbGljaywgc2xhdGVFZGl0b3JdKSwgaGFuZGxlT25CbHVyID0gdXNlQ2FsbGJhY2soKGV2ZW50XzMpID0+IHtcbiAgICBvbkJsdXIgJiYgb25CbHVyKGV2ZW50XzMpLCBldmVudF8zLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgfHwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJsdXJcIixcbiAgICAgIGV2ZW50OiBldmVudF8zXG4gICAgfSk7XG4gIH0sIFtlZGl0b3JBY3Rvciwgb25CbHVyXSksIGhhbmRsZU9uQmVmb3JlSW5wdXQgPSB1c2VDYWxsYmFjaygoZXZlbnRfNCkgPT4ge1xuICAgIG9uQmVmb3JlSW5wdXQgJiYgb25CZWZvcmVJbnB1dChldmVudF80KTtcbiAgfSwgW29uQmVmb3JlSW5wdXRdKSwgdmFsaWRhdGVTZWxlY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFzbGF0ZUVkaXRvci5zZWxlY3Rpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChzbGF0ZUVkaXRvciksIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gcm9vdDtcbiAgICBpZiAocmVmLmN1cnJlbnQgIT09IGFjdGl2ZUVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KHNsYXRlRWRpdG9yKS5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIWRvbVNlbGVjdGlvbiB8fCBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBleGlzdGluZ0RPTVJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5ld0RPTVJhbmdlID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShzbGF0ZUVkaXRvciwgc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgIChuZXdET01SYW5nZS5zdGFydE9mZnNldCAhPT0gZXhpc3RpbmdET01SYW5nZS5zdGFydE9mZnNldCB8fCBuZXdET01SYW5nZS5lbmRPZmZzZXQgIT09IGV4aXN0aW5nRE9NUmFuZ2UuZW5kT2Zmc2V0KSAmJiAoZGVidWcoXCJET00gcmFuZ2Ugb3V0IG9mIHN5bmMsIHZhbGlkYXRpbmcgc2VsZWN0aW9uXCIpLCBkb21TZWxlY3Rpb24/LnJlbW92ZUFsbFJhbmdlcygpLCBkb21TZWxlY3Rpb24uYWRkUmFuZ2UobmV3RE9NUmFuZ2UpKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGRlYnVnKFwiQ291bGQgbm90IHJlc29sdmUgc2VsZWN0aW9uLCBzZWxlY3RpbmcgdG9wIGRvY3VtZW50XCIpLCBUcmFuc2Zvcm1zLmRlc2VsZWN0KHNsYXRlRWRpdG9yKSwgc2xhdGVFZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiBUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgWzAsIDBdKSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9XG4gIH0sIFtyZWYsIHNsYXRlRWRpdG9yXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVkaXRhYmxlRWxlbWVudCkge1xuICAgICAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHZhbGlkYXRlU2VsZWN0aW9uKTtcbiAgICAgIHJldHVybiBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZWRpdGFibGVFbGVtZW50LCB7XG4gICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiAhMSxcbiAgICAgICAgYXR0cmlidXRlczogITEsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6ICExLFxuICAgICAgICBjaGlsZExpc3Q6ICEwLFxuICAgICAgICBzdWJ0cmVlOiAhMFxuICAgICAgfSksICgpID0+IHtcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3ZhbGlkYXRlU2VsZWN0aW9uLCBlZGl0YWJsZUVsZW1lbnRdKTtcbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKChldmVudF81KSA9PiB7XG4gICAgcHJvcHMub25LZXlEb3duICYmIHByb3BzLm9uS2V5RG93bihldmVudF81KSwgZXZlbnRfNS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBzbGF0ZUVkaXRvci5wdGVXaXRoSG90S2V5cyhldmVudF81KTtcbiAgfSwgW3Byb3BzLCBzbGF0ZUVkaXRvcl0pLCBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1RvU2xhdGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9PT0gbnVsbCA/IG5vb3AgOiAoX2VkaXRvciwgZG9tUmFuZ2UpID0+IHtcbiAgICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcocG9ydGFibGVUZXh0RWRpdG9yLCBkb21SYW5nZSk7XG4gICAgICB9O1xuICB9LCBbcG9ydGFibGVUZXh0RWRpdG9yLCBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld10pLCBkZWNvcmF0ZSA9IHVzZUNhbGxiYWNrKChbLCBwYXRoXzBdKSA9PiB7XG4gICAgaWYgKGlzRXF1YWxUb0VtcHR5RWRpdG9yKHNsYXRlRWRpdG9yLmNoaWxkcmVuLCBzY2hlbWFUeXBlcykpXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2Vob2xkZXI6ICEwXG4gICAgICB9XTtcbiAgICBpZiAocGF0aF8wLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCByZXN1bHRfMSA9IHJhbmdlRGVjb3JhdGlvblN0YXRlLmZpbHRlcigoaXRlbSkgPT4gUmFuZ2UuaXNDb2xsYXBzZWQoaXRlbSkgPyBwYXRoXzAubGVuZ3RoICE9PSAyID8gITEgOiBQYXRoLmVxdWFscyhpdGVtLmZvY3VzLnBhdGgsIHBhdGhfMCkgJiYgUGF0aC5lcXVhbHMoaXRlbS5hbmNob3IucGF0aCwgcGF0aF8wKSA6IFJhbmdlLmludGVyc2VjdGlvbihpdGVtLCB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogcGF0aF8wLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBwYXRoXzAsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfVxuICAgIH0pIHx8IFJhbmdlLmluY2x1ZGVzKGl0ZW0sIHBhdGhfMCkpO1xuICAgIHJldHVybiByZXN1bHRfMS5sZW5ndGggPiAwID8gcmVzdWx0XzEgOiBbXTtcbiAgfSwgW3NsYXRlRWRpdG9yLCBzY2hlbWFUeXBlcywgcmFuZ2VEZWNvcmF0aW9uU3RhdGVdKTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoc2xhdGVFZGl0b3IsIHNsYXRlRWRpdG9yKSwgc2V0RWRpdGFibGVFbGVtZW50KHJlZi5jdXJyZW50KTtcbiAgfSwgW3NsYXRlRWRpdG9yLCByZWZdKSwgcG9ydGFibGVUZXh0RWRpdG9yID8gaGFzSW52YWxpZFZhbHVlID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgRWRpdGFibGUsXG4gICAge1xuICAgICAgLi4ucmVzdFByb3BzLFxuICAgICAgYXV0b0ZvY3VzOiAhMSxcbiAgICAgIGNsYXNzTmFtZTogcmVzdFByb3BzLmNsYXNzTmFtZSB8fCBcInB0LWVkaXRhYmxlXCIsXG4gICAgICBkZWNvcmF0ZSxcbiAgICAgIG9uQmx1cjogaGFuZGxlT25CbHVyLFxuICAgICAgb25Db3B5OiBoYW5kbGVDb3B5LFxuICAgICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgICBvbkRPTUJlZm9yZUlucHV0OiBoYW5kbGVPbkJlZm9yZUlucHV0LFxuICAgICAgb25Gb2N1czogaGFuZGxlT25Gb2N1cyxcbiAgICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICAgIG9uUGFzdGU6IGhhbmRsZVBhc3RlLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByZW5kZXJQbGFjZWhvbGRlcjogdm9pZCAwLFxuICAgICAgcmVuZGVyRWxlbWVudCxcbiAgICAgIHJlbmRlckxlYWYsXG4gICAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldzogc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXdUb1NsYXRlXG4gICAgfVxuICApIDogbnVsbDtcbn0pO1xuUG9ydGFibGVUZXh0RWRpdGFibGUuZGlzcGxheU5hbWUgPSBcIkZvcndhcmRSZWYoUG9ydGFibGVUZXh0RWRpdGFibGUpXCI7XG5jb25zdCBFZGl0b3JDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gRWRpdG9yUHJvdmlkZXIocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoMzApLCBlZGl0b3IgPSB1c2VFZGl0b3IocHJvcHMuY29uZmlnKSwgZWRpdG9yQWN0b3IgPSBlZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvciA9IGVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IsIGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlO1xuICBsZXQgdDAsIHQxO1xuICAkWzBdICE9PSBlZGl0b3IgPyAodDEgPSBuZXcgUG9ydGFibGVUZXh0RWRpdG9yKHtcbiAgICBlZGl0b3JcbiAgfSksICRbMF0gPSBlZGl0b3IsICRbMV0gPSB0MSkgOiB0MSA9ICRbMV0sIHQwID0gdDE7XG4gIGNvbnN0IHBvcnRhYmxlVGV4dEVkaXRvciA9IHQwO1xuICBsZXQgdDI7XG4gICRbMl0gIT09IHBvcnRhYmxlVGV4dEVkaXRvci5jaGFuZ2UkID8gKHQyID0gKGNoYW5nZSkgPT4ge1xuICAgIHBvcnRhYmxlVGV4dEVkaXRvci5jaGFuZ2UkLm5leHQoY2hhbmdlKTtcbiAgfSwgJFsyXSA9IHBvcnRhYmxlVGV4dEVkaXRvci5jaGFuZ2UkLCAkWzNdID0gdDIpIDogdDIgPSAkWzNdO1xuICBsZXQgdDM7XG4gICRbNF0gIT09IGVkaXRvckFjdG9yIHx8ICRbNV0gIT09IHQyID8gKHQzID0gLyogQF9fUFVSRV9fICovIGpzeChSb3V0ZUV2ZW50c1RvQ2hhbmdlcywgeyBlZGl0b3JBY3Rvciwgb25DaGFuZ2U6IHQyIH0pLCAkWzRdID0gZWRpdG9yQWN0b3IsICRbNV0gPSB0MiwgJFs2XSA9IHQzKSA6IHQzID0gJFs2XTtcbiAgbGV0IHQ0O1xuICAkWzddICE9PSBlZGl0YWJsZS5nZXRWYWx1ZSB8fCAkWzhdICE9PSBlZGl0b3JBY3RvciB8fCAkWzldICE9PSBwb3J0YWJsZVRleHRFZGl0b3IgfHwgJFsxMF0gIT09IHNsYXRlRWRpdG9yLmluc3RhbmNlID8gKHQ0ID0gLyogQF9fUFVSRV9fICovIGpzeChTeW5jaHJvbml6ZXIsIHsgZWRpdG9yQWN0b3IsIGdldFZhbHVlOiBlZGl0YWJsZS5nZXRWYWx1ZSwgcG9ydGFibGVUZXh0RWRpdG9yLCBzbGF0ZUVkaXRvcjogc2xhdGVFZGl0b3IuaW5zdGFuY2UgfSksICRbN10gPSBlZGl0YWJsZS5nZXRWYWx1ZSwgJFs4XSA9IGVkaXRvckFjdG9yLCAkWzldID0gcG9ydGFibGVUZXh0RWRpdG9yLCAkWzEwXSA9IHNsYXRlRWRpdG9yLmluc3RhbmNlLCAkWzExXSA9IHQ0KSA6IHQ0ID0gJFsxMV07XG4gIGxldCB0NTtcbiAgJFsxMl0gIT09IGVkaXRvckFjdG9yIHx8ICRbMTNdICE9PSBwcm9wcy5jaGlsZHJlbiA/ICh0NSA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uUHJvdmlkZXIsIHsgZWRpdG9yQWN0b3IsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KSwgJFsxMl0gPSBlZGl0b3JBY3RvciwgJFsxM10gPSBwcm9wcy5jaGlsZHJlbiwgJFsxNF0gPSB0NSkgOiB0NSA9ICRbMTRdO1xuICBsZXQgdDY7XG4gICRbMTVdICE9PSBwb3J0YWJsZVRleHRFZGl0b3IgfHwgJFsxNl0gIT09IHQ1ID8gKHQ2ID0gLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwb3J0YWJsZVRleHRFZGl0b3IsIGNoaWxkcmVuOiB0NSB9KSwgJFsxNV0gPSBwb3J0YWJsZVRleHRFZGl0b3IsICRbMTZdID0gdDUsICRbMTddID0gdDYpIDogdDYgPSAkWzE3XTtcbiAgbGV0IHQ3O1xuICAkWzE4XSAhPT0gc2xhdGVFZGl0b3IuaW5pdGlhbFZhbHVlIHx8ICRbMTldICE9PSBzbGF0ZUVkaXRvci5pbnN0YW5jZSB8fCAkWzIwXSAhPT0gdDYgPyAodDcgPSAvKiBAX19QVVJFX18gKi8ganN4KFNsYXRlLCB7IGVkaXRvcjogc2xhdGVFZGl0b3IuaW5zdGFuY2UsIGluaXRpYWxWYWx1ZTogc2xhdGVFZGl0b3IuaW5pdGlhbFZhbHVlLCBjaGlsZHJlbjogdDYgfSksICRbMThdID0gc2xhdGVFZGl0b3IuaW5pdGlhbFZhbHVlLCAkWzE5XSA9IHNsYXRlRWRpdG9yLmluc3RhbmNlLCAkWzIwXSA9IHQ2LCAkWzIxXSA9IHQ3KSA6IHQ3ID0gJFsyMV07XG4gIGxldCB0ODtcbiAgJFsyMl0gIT09IGVkaXRvckFjdG9yIHx8ICRbMjNdICE9PSB0NyA/ICh0OCA9IC8qIEBfX1BVUkVfXyAqLyBqc3goRWRpdG9yQWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBlZGl0b3JBY3RvciwgY2hpbGRyZW46IHQ3IH0pLCAkWzIyXSA9IGVkaXRvckFjdG9yLCAkWzIzXSA9IHQ3LCAkWzI0XSA9IHQ4KSA6IHQ4ID0gJFsyNF07XG4gIGxldCB0OTtcbiAgcmV0dXJuICRbMjVdICE9PSBlZGl0b3IgfHwgJFsyNl0gIT09IHQzIHx8ICRbMjddICE9PSB0NCB8fCAkWzI4XSAhPT0gdDggPyAodDkgPSAvKiBAX19QVVJFX18gKi8ganN4cyhFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBlZGl0b3IsIGNoaWxkcmVuOiBbXG4gICAgdDMsXG4gICAgdDQsXG4gICAgdDhcbiAgXSB9KSwgJFsyNV0gPSBlZGl0b3IsICRbMjZdID0gdDMsICRbMjddID0gdDQsICRbMjhdID0gdDgsICRbMjldID0gdDkpIDogdDkgPSAkWzI5XSwgdDk7XG59XG5mdW5jdGlvbiB1c2VFZGl0b3JDb250ZXh0KCkge1xuICBjb25zdCBlZGl0b3IgPSBSZWFjdC51c2VDb250ZXh0KEVkaXRvckNvbnRleHQpO1xuICBpZiAoIWVkaXRvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBFZGl0b3Igc2V0LiBVc2UgRWRpdG9yUHJvdmlkZXIgdG8gc2V0IG9uZS5cIik7XG4gIHJldHVybiBlZGl0b3I7XG59XG5mdW5jdGlvbiBFZGl0b3JFdmVudExpc3RlbmVyKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDQpLCBlZGl0b3IgPSB1c2VFZGl0b3JDb250ZXh0KCksIG9uID0gdXNlRWZmZWN0RXZlbnQocHJvcHMub24pO1xuICBsZXQgdDAsIHQxO1xuICByZXR1cm4gJFswXSAhPT0gZWRpdG9yIHx8ICRbMV0gIT09IG9uID8gKHQwID0gKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGVkaXRvci5vbihcIipcIiwgb24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MSA9IFtlZGl0b3IsIG9uXSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IG9uLCAkWzJdID0gdDAsICRbM10gPSB0MSkgOiAodDAgPSAkWzJdLCB0MSA9ICRbM10pLCB1c2VFZmZlY3QodDAsIHQxKSwgbnVsbDtcbn1cbmV4cG9ydCB7XG4gIEVkaXRvckV2ZW50TGlzdGVuZXIsXG4gIEVkaXRvclByb3ZpZGVyLFxuICBQb3J0YWJsZVRleHRFZGl0YWJsZSxcbiAgUG9ydGFibGVUZXh0RWRpdG9yLFxuICBjb3JlQmVoYXZpb3IsXG4gIGNvcmVCZWhhdmlvcnMsXG4gIGNyZWF0ZUxpbmtCZWhhdmlvcnMsXG4gIGNyZWF0ZU1hcmtkb3duQmVoYXZpb3JzLFxuICBkZWZpbmVCZWhhdmlvcixcbiAgZGVmaW5lU2NoZW1hLFxuICBlZGl0b3JNYWNoaW5lLFxuICBkZWZhdWx0S2V5R2VuZXJhdG9yIGFzIGtleUdlbmVyYXRvcixcbiAgdXNlRWRpdG9yLFxuICB1c2VFZGl0b3JDb250ZXh0LFxuICB1c2VQb3J0YWJsZVRleHRFZGl0b3IsXG4gIHVzZVBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/patches/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/patches/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyAll: () => (/* binding */ applyAll),\n/* harmony export */   diffMatchPatch: () => (/* binding */ diffMatchPatch),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   prefixPath: () => (/* binding */ prefixPath),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setIfMissing: () => (/* binding */ setIfMissing),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\n/* harmony import */ var lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isObject.js */ \"(ssr)/./node_modules/lodash/isObject.js\");\n/* harmony import */ var lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isString.js */ \"(ssr)/./node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/findIndex.js */ \"(ssr)/./node_modules/lodash/findIndex.js\");\n/* harmony import */ var lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/clone.js */ \"(ssr)/./node_modules/lodash/clone.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/./node_modules/lodash/omit.js\");\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\n\n\n\n\n\nconst BEFORE = \"before\", AFTER = \"after\";\nfunction insert$1(array, position, index, ...args) {\n  if (position !== BEFORE && position !== AFTER)\n    throw new Error(`Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`);\n  const items = flatten(...args);\n  if (array.length === 0)\n    return items;\n  const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === \"after\" ? idx + 1 : idx, copy = array.slice();\n  return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;\n}\nfunction flatten(...values) {\n  return values.reduce((prev, item) => prev.concat(item), []);\n}\nconst hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\nfunction move(arr, from, to) {\n  const nextValue = arr.slice(), val = nextValue[from];\n  return nextValue.splice(from, 1), nextValue.splice(to, 0, val), nextValue;\n}\nfunction findTargetIndex(array, pathSegment) {\n  if (typeof pathSegment == \"number\")\n    return pathSegment;\n  const index = lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__(array, pathSegment);\n  return index === -1 ? !1 : index;\n}\nfunction apply$3(value, patch) {\n  const nextValue = value.slice();\n  if (patch.path.length === 0) {\n    if (patch.type === \"setIfMissing\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return value === void 0 ? patch.value : value;\n    } else if (patch.type === \"set\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"move\") {\n        if (!patch.value || !hasOwn(patch.value, \"from\") || !hasOwn(patch.value, \"to\"))\n          throw new Error(\n            `Invalid value of 'move' patch. Expected a value with \"from\" and \"to\" indexes, instead got: ${JSON.stringify(\n              patch.value\n            )}`\n          );\n        return move(nextValue, patch.value.from, patch.value.to);\n      }\n    }\n    throw new Error(`Invalid array operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path, index = findTargetIndex(value, head);\n  if (index === !1)\n    return nextValue;\n  if (tail.length === 0) {\n    if (patch.type === \"insert\") {\n      const { position, items } = patch;\n      return insert$1(value, position, index, items);\n    } else if (patch.type === \"unset\") {\n      if (typeof index != \"number\")\n        throw new Error(`Expected array index to be a number, instead got \"${index}\"`);\n      return nextValue.splice(index, 1), nextValue;\n    }\n  }\n  return nextValue[index] = _apply(nextValue[index], {\n    ...patch,\n    path: tail\n  }), nextValue;\n}\nfunction apply$2(value, patch) {\n  const nextValue = lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__(value);\n  if (patch.path.length === 0) {\n    if (patch.type === \"set\") {\n      if (!lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(patch.value))\n        throw new Error(\"Cannot set value of an object to a non-object\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"setIfMissing\")\n        return value === void 0 ? patch.value : value;\n    }\n    throw new Error(`Invalid object operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path;\n  if (typeof head != \"string\")\n    throw new Error(`Expected field name to be a string, instad got: ${head}`);\n  return tail.length === 0 && patch.type === \"unset\" ? lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__(nextValue, head) : (nextValue[head] = _apply(nextValue[head], {\n    ...patch,\n    path: tail\n  }), nextValue);\n}\nconst OPERATIONS$1 = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  inc(currentValue, nextValue) {\n    return currentValue + nextValue;\n  },\n  dec(currentValue, nextValue) {\n    return currentValue - nextValue;\n  }\n}, SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);\nfunction apply$1(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for primitives. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${patch.type}\" and path \"${patch.path.map((path) => JSON.stringify(path)).join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  return OPERATIONS$1[patch.type](value, patch.value);\n}\nconst OPERATIONS = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  diffMatchPatch(currentValue, nextValue) {\n    const [result] = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.applyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.parsePatch)(nextValue), currentValue, {\n      allowExceedingIndices: !0\n    });\n    return result;\n  }\n}, SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);\nfunction apply(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for string. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on string values. Received patch with type \"${patch.type}\" and path \"${patch.path.join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  const func = OPERATIONS[patch.type];\n  if (func)\n    return func(value, patch.value);\n  throw new Error(\"Unknown patch type\");\n}\nfunction applyAll(value, patches) {\n  return patches.reduce(_apply, value);\n}\nfunction applyPatch(value, patch) {\n  return Array.isArray(value) ? apply$3(value, patch) : lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__(value) ? apply(value, patch) : lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(value) ? apply$2(value, patch) : apply$1(value, patch);\n}\nfunction _apply(value, patch) {\n  return applyPatch(value, patch);\n}\nfunction setIfMissing(value, path = []) {\n  return {\n    type: \"setIfMissing\",\n    path,\n    value\n  };\n}\nfunction diffMatchPatch(currentValue, nextValue, path = []) {\n  const patches = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.makePatches)(currentValue, nextValue), patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.stringifyPatches)(patches);\n  return { type: \"diffMatchPatch\", path, value: patch };\n}\nfunction insert(items, position, path = []) {\n  return {\n    type: \"insert\",\n    path,\n    position,\n    items\n  };\n}\nfunction set(value, path = []) {\n  return { type: \"set\", path, value };\n}\nfunction unset(path = []) {\n  return { type: \"unset\", path };\n}\nfunction prefixPath(patch, segment) {\n  return {\n    ...patch,\n    path: [segment, ...patch.path]\n  };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9wYXRjaGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0U7QUFDUjtBQUNGO0FBQ2lFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTLG9CQUFvQixRQUFRLEtBQUssTUFBTTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkVBQTZFLE1BQU07QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsNENBQUs7QUFDekI7QUFDQTtBQUNBLFdBQVcsK0NBQVE7QUFDbkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUUsdURBQXVELDJDQUFJO0FBQzNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsV0FBVyxjQUFjLDBEQUEwRCwyQkFBMkIsc0JBQXNCO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsc0VBQVksQ0FBQyxvRUFBVTtBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsV0FBVyxjQUFjLHNCQUFzQiwyQkFBMkIsc0JBQXNCO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFRLGdDQUFnQywrQ0FBUTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQVcsbUNBQW1DLDBFQUFnQjtBQUNoRixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9wYXRjaGVzL2Rpc3QvaW5kZXguanM/OTUwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNPYmplY3QgZnJvbSBcImxvZGFzaC9pc09iamVjdC5qc1wiO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gXCJsb2Rhc2gvaXNTdHJpbmcuanNcIjtcbmltcG9ydCBmaW5kSW5kZXggZnJvbSBcImxvZGFzaC9maW5kSW5kZXguanNcIjtcbmltcG9ydCBjbG9uZSBmcm9tIFwibG9kYXNoL2Nsb25lLmpzXCI7XG5pbXBvcnQgb21pdCBmcm9tIFwibG9kYXNoL29taXQuanNcIjtcbmltcG9ydCB7IGFwcGx5UGF0Y2hlcywgcGFyc2VQYXRjaCwgbWFrZVBhdGNoZXMsIHN0cmluZ2lmeVBhdGNoZXMgfSBmcm9tIFwiQHNhbml0eS9kaWZmLW1hdGNoLXBhdGNoXCI7XG5jb25zdCBCRUZPUkUgPSBcImJlZm9yZVwiLCBBRlRFUiA9IFwiYWZ0ZXJcIjtcbmZ1bmN0aW9uIGluc2VydCQxKGFycmF5LCBwb3NpdGlvbiwgaW5kZXgsIC4uLmFyZ3MpIHtcbiAgaWYgKHBvc2l0aW9uICE9PSBCRUZPUkUgJiYgcG9zaXRpb24gIT09IEFGVEVSKVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3NpdGlvbiBcIiR7cG9zaXRpb259XCIsIG11c3QgYmUgZWl0aGVyICR7QkVGT1JFfSBvciAke0FGVEVSfWApO1xuICBjb25zdCBpdGVtcyA9IGZsYXR0ZW4oLi4uYXJncyk7XG4gIGlmIChhcnJheS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnJheS5sZW5ndGgsIGlkeCA9IE1hdGguYWJzKChsZW4gKyBpbmRleCkgJSBsZW4pICUgbGVuLCBub3JtYWxpemVkSWR4ID0gcG9zaXRpb24gPT09IFwiYWZ0ZXJcIiA/IGlkeCArIDEgOiBpZHgsIGNvcHkgPSBhcnJheS5zbGljZSgpO1xuICByZXR1cm4gY29weS5zcGxpY2Uobm9ybWFsaXplZElkeCwgMCwgLi4uZmxhdHRlbihpdGVtcykpLCBjb3B5O1xufVxuZnVuY3Rpb24gZmxhdHRlbiguLi52YWx1ZXMpIHtcbiAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoKHByZXYsIGl0ZW0pID0+IHByZXYuY29uY2F0KGl0ZW0pLCBbXSk7XG59XG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbmZ1bmN0aW9uIG1vdmUoYXJyLCBmcm9tLCB0bykge1xuICBjb25zdCBuZXh0VmFsdWUgPSBhcnIuc2xpY2UoKSwgdmFsID0gbmV4dFZhbHVlW2Zyb21dO1xuICByZXR1cm4gbmV4dFZhbHVlLnNwbGljZShmcm9tLCAxKSwgbmV4dFZhbHVlLnNwbGljZSh0bywgMCwgdmFsKSwgbmV4dFZhbHVlO1xufVxuZnVuY3Rpb24gZmluZFRhcmdldEluZGV4KGFycmF5LCBwYXRoU2VnbWVudCkge1xuICBpZiAodHlwZW9mIHBhdGhTZWdtZW50ID09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHBhdGhTZWdtZW50O1xuICBjb25zdCBpbmRleCA9IGZpbmRJbmRleChhcnJheSwgcGF0aFNlZ21lbnQpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gITEgOiBpbmRleDtcbn1cbmZ1bmN0aW9uIGFwcGx5JDModmFsdWUsIHBhdGNoKSB7XG4gIGNvbnN0IG5leHRWYWx1ZSA9IHZhbHVlLnNsaWNlKCk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChwYXRjaC50eXBlID09PSBcInNldElmTWlzc2luZ1wiKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0Y2gudmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHZhbHVlIG9mIGFuIGFycmF5IHRvIGEgbm9uLWFycmF5XCIpO1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBwYXRjaC52YWx1ZSA6IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoLnZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB2YWx1ZSBvZiBhbiBhcnJheSB0byBhIG5vbi1hcnJheVwiKTtcbiAgICAgIHJldHVybiBwYXRjaC52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHBhdGNoLnR5cGUgPT09IFwibW92ZVwiKSB7XG4gICAgICAgIGlmICghcGF0Y2gudmFsdWUgfHwgIWhhc093bihwYXRjaC52YWx1ZSwgXCJmcm9tXCIpIHx8ICFoYXNPd24ocGF0Y2gudmFsdWUsIFwidG9cIikpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgb2YgJ21vdmUnIHBhdGNoLiBFeHBlY3RlZCBhIHZhbHVlIHdpdGggXCJmcm9tXCIgYW5kIFwidG9cIiBpbmRleGVzLCBpbnN0ZWFkIGdvdDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgcGF0Y2gudmFsdWVcbiAgICAgICAgICAgICl9YFxuICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiBtb3ZlKG5leHRWYWx1ZSwgcGF0Y2gudmFsdWUuZnJvbSwgcGF0Y2gudmFsdWUudG8pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJyYXkgb3BlcmF0aW9uOiAke3BhdGNoLnR5cGV9YCk7XG4gIH1cbiAgY29uc3QgW2hlYWQsIC4uLnRhaWxdID0gcGF0Y2gucGF0aCwgaW5kZXggPSBmaW5kVGFyZ2V0SW5kZXgodmFsdWUsIGhlYWQpO1xuICBpZiAoaW5kZXggPT09ICExKVxuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIGlmICh0YWlsLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChwYXRjaC50eXBlID09PSBcImluc2VydFwiKSB7XG4gICAgICBjb25zdCB7IHBvc2l0aW9uLCBpdGVtcyB9ID0gcGF0Y2g7XG4gICAgICByZXR1cm4gaW5zZXJ0JDEodmFsdWUsIHBvc2l0aW9uLCBpbmRleCwgaXRlbXMpO1xuICAgIH0gZWxzZSBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiKSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXJyYXkgaW5kZXggdG8gYmUgYSBudW1iZXIsIGluc3RlYWQgZ290IFwiJHtpbmRleH1cImApO1xuICAgICAgcmV0dXJuIG5leHRWYWx1ZS5zcGxpY2UoaW5kZXgsIDEpLCBuZXh0VmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0VmFsdWVbaW5kZXhdID0gX2FwcGx5KG5leHRWYWx1ZVtpbmRleF0sIHtcbiAgICAuLi5wYXRjaCxcbiAgICBwYXRoOiB0YWlsXG4gIH0pLCBuZXh0VmFsdWU7XG59XG5mdW5jdGlvbiBhcHBseSQyKHZhbHVlLCBwYXRjaCkge1xuICBjb25zdCBuZXh0VmFsdWUgPSBjbG9uZSh2YWx1ZSk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChwYXRjaC50eXBlID09PSBcInNldFwiKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHBhdGNoLnZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB2YWx1ZSBvZiBhbiBvYmplY3QgdG8gYSBub24tb2JqZWN0XCIpO1xuICAgICAgcmV0dXJuIHBhdGNoLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRJZk1pc3NpbmdcIilcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBwYXRjaC52YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb2JqZWN0IG9wZXJhdGlvbjogJHtwYXRjaC50eXBlfWApO1xuICB9XG4gIGNvbnN0IFtoZWFkLCAuLi50YWlsXSA9IHBhdGNoLnBhdGg7XG4gIGlmICh0eXBlb2YgaGVhZCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZmllbGQgbmFtZSB0byBiZSBhIHN0cmluZywgaW5zdGFkIGdvdDogJHtoZWFkfWApO1xuICByZXR1cm4gdGFpbC5sZW5ndGggPT09IDAgJiYgcGF0Y2gudHlwZSA9PT0gXCJ1bnNldFwiID8gb21pdChuZXh0VmFsdWUsIGhlYWQpIDogKG5leHRWYWx1ZVtoZWFkXSA9IF9hcHBseShuZXh0VmFsdWVbaGVhZF0sIHtcbiAgICAuLi5wYXRjaCxcbiAgICBwYXRoOiB0YWlsXG4gIH0pLCBuZXh0VmFsdWUpO1xufVxuY29uc3QgT1BFUkFUSU9OUyQxID0ge1xuICByZXBsYWNlKF9jdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHNldChfY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICB9LFxuICBzZXRJZk1pc3NpbmcoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlID09PSB2b2lkIDAgPyBuZXh0VmFsdWUgOiBjdXJyZW50VmFsdWU7XG4gIH0sXG4gIHVuc2V0KF9jdXJyZW50VmFsdWUsIF9uZXh0VmFsdWUpIHtcbiAgfSxcbiAgaW5jKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSArIG5leHRWYWx1ZTtcbiAgfSxcbiAgZGVjKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSAtIG5leHRWYWx1ZTtcbiAgfVxufSwgU1VQUE9SVEVEX1BBVENIX1RZUEVTJDEgPSBPYmplY3Qua2V5cyhPUEVSQVRJT05TJDEpO1xuZnVuY3Rpb24gYXBwbHkkMSh2YWx1ZSwgcGF0Y2gpIHtcbiAgaWYgKCFTVVBQT1JURURfUEFUQ0hfVFlQRVMkMS5pbmNsdWRlcyhwYXRjaC50eXBlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVjZWl2ZWQgcGF0Y2ggb2YgdW5zdXBwb3J0ZWQgdHlwZTogXCIke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBwYXRjaC50eXBlXG4gICAgICApfVwiIGZvciBwcmltaXRpdmVzLiBUaGlzIGlzIG1vc3QgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgYXBwbHkgZGVlcCBvcGVyYXRpb25zIG9uIHByaW1pdGl2ZSB2YWx1ZXMuIFJlY2VpdmVkIHBhdGNoIHdpdGggdHlwZSBcIiR7cGF0Y2gudHlwZX1cIiBhbmQgcGF0aCBcIiR7cGF0Y2gucGF0aC5tYXAoKHBhdGgpID0+IEpTT04uc3RyaW5naWZ5KHBhdGgpKS5qb2luKFwiLlwiKX0gdGhhdCB0YXJnZXRlZCB0aGUgdmFsdWUgXCIke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cImBcbiAgICApO1xuICByZXR1cm4gT1BFUkFUSU9OUyQxW3BhdGNoLnR5cGVdKHZhbHVlLCBwYXRjaC52YWx1ZSk7XG59XG5jb25zdCBPUEVSQVRJT05TID0ge1xuICByZXBsYWNlKF9jdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHNldChfY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICB9LFxuICBzZXRJZk1pc3NpbmcoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlID09PSB2b2lkIDAgPyBuZXh0VmFsdWUgOiBjdXJyZW50VmFsdWU7XG4gIH0sXG4gIHVuc2V0KF9jdXJyZW50VmFsdWUsIF9uZXh0VmFsdWUpIHtcbiAgfSxcbiAgZGlmZk1hdGNoUGF0Y2goY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICBjb25zdCBbcmVzdWx0XSA9IGFwcGx5UGF0Y2hlcyhwYXJzZVBhdGNoKG5leHRWYWx1ZSksIGN1cnJlbnRWYWx1ZSwge1xuICAgICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiAhMFxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0sIFNVUFBPUlRFRF9QQVRDSF9UWVBFUyA9IE9iamVjdC5rZXlzKE9QRVJBVElPTlMpO1xuZnVuY3Rpb24gYXBwbHkodmFsdWUsIHBhdGNoKSB7XG4gIGlmICghU1VQUE9SVEVEX1BBVENIX1RZUEVTLmluY2x1ZGVzKHBhdGNoLnR5cGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZWNlaXZlZCBwYXRjaCBvZiB1bnN1cHBvcnRlZCB0eXBlOiBcIiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHBhdGNoLnR5cGVcbiAgICAgICl9XCIgZm9yIHN0cmluZy4gVGhpcyBpcyBtb3N0IGxpa2VseSBhIGJ1Zy5gXG4gICAgKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IGFwcGx5IGRlZXAgb3BlcmF0aW9ucyBvbiBzdHJpbmcgdmFsdWVzLiBSZWNlaXZlZCBwYXRjaCB3aXRoIHR5cGUgXCIke3BhdGNoLnR5cGV9XCIgYW5kIHBhdGggXCIke3BhdGNoLnBhdGguam9pbihcIi5cIil9IHRoYXQgdGFyZ2V0ZWQgdGhlIHZhbHVlIFwiJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XCJgXG4gICAgKTtcbiAgY29uc3QgZnVuYyA9IE9QRVJBVElPTlNbcGF0Y2gudHlwZV07XG4gIGlmIChmdW5jKVxuICAgIHJldHVybiBmdW5jKHZhbHVlLCBwYXRjaC52YWx1ZSk7XG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcGF0Y2ggdHlwZVwiKTtcbn1cbmZ1bmN0aW9uIGFwcGx5QWxsKHZhbHVlLCBwYXRjaGVzKSB7XG4gIHJldHVybiBwYXRjaGVzLnJlZHVjZShfYXBwbHksIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFwcGx5UGF0Y2godmFsdWUsIHBhdGNoKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGFwcGx5JDModmFsdWUsIHBhdGNoKSA6IGlzU3RyaW5nKHZhbHVlKSA/IGFwcGx5KHZhbHVlLCBwYXRjaCkgOiBpc09iamVjdCh2YWx1ZSkgPyBhcHBseSQyKHZhbHVlLCBwYXRjaCkgOiBhcHBseSQxKHZhbHVlLCBwYXRjaCk7XG59XG5mdW5jdGlvbiBfYXBwbHkodmFsdWUsIHBhdGNoKSB7XG4gIHJldHVybiBhcHBseVBhdGNoKHZhbHVlLCBwYXRjaCk7XG59XG5mdW5jdGlvbiBzZXRJZk1pc3NpbmcodmFsdWUsIHBhdGggPSBbXSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic2V0SWZNaXNzaW5nXCIsXG4gICAgcGF0aCxcbiAgICB2YWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gZGlmZk1hdGNoUGF0Y2goY3VycmVudFZhbHVlLCBuZXh0VmFsdWUsIHBhdGggPSBbXSkge1xuICBjb25zdCBwYXRjaGVzID0gbWFrZVBhdGNoZXMoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpLCBwYXRjaCA9IHN0cmluZ2lmeVBhdGNoZXMocGF0Y2hlcyk7XG4gIHJldHVybiB7IHR5cGU6IFwiZGlmZk1hdGNoUGF0Y2hcIiwgcGF0aCwgdmFsdWU6IHBhdGNoIH07XG59XG5mdW5jdGlvbiBpbnNlcnQoaXRlbXMsIHBvc2l0aW9uLCBwYXRoID0gW10pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImluc2VydFwiLFxuICAgIHBhdGgsXG4gICAgcG9zaXRpb24sXG4gICAgaXRlbXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldCh2YWx1ZSwgcGF0aCA9IFtdKSB7XG4gIHJldHVybiB7IHR5cGU6IFwic2V0XCIsIHBhdGgsIHZhbHVlIH07XG59XG5mdW5jdGlvbiB1bnNldChwYXRoID0gW10pIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJ1bnNldFwiLCBwYXRoIH07XG59XG5mdW5jdGlvbiBwcmVmaXhQYXRoKHBhdGNoLCBzZWdtZW50KSB7XG4gIHJldHVybiB7XG4gICAgLi4ucGF0Y2gsXG4gICAgcGF0aDogW3NlZ21lbnQsIC4uLnBhdGNoLnBhdGhdXG4gIH07XG59XG5leHBvcnQge1xuICBhcHBseUFsbCxcbiAgZGlmZk1hdGNoUGF0Y2gsXG4gIGluc2VydCxcbiAgcHJlZml4UGF0aCxcbiAgc2V0LFxuICBzZXRJZk1pc3NpbmcsXG4gIHVuc2V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/patches/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\n  _excluded2 = [\"listItem\"],\n  _excluded3 = [\"_key\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n\n\n\n\nconst defaultLists = {\n    number: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", {\n      children\n    }),\n    bullet: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n      children\n    })\n  },\n  DefaultListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  link = ({\n    children,\n    value\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n    href: value == null ? void 0 : value.href,\n    children\n  }),\n  underlineStyle = {\n    textDecoration: \"underline\"\n  },\n  defaultMarks = {\n    em: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"em\", {\n      children\n    }),\n    strong: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", {\n      children\n    }),\n    code: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", {\n      children\n    }),\n    underline: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: underlineStyle,\n      children\n    }),\n    \"strike-through\": ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"del\", {\n      children\n    }),\n    link\n  },\n  getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`,\n  unknownTypeWarning = typeName => getTemplate(`block type \"${typeName}\"`, \"types\"),\n  unknownMarkWarning = markType => getTemplate(`mark type \"${markType}\"`, \"marks\"),\n  unknownBlockStyleWarning = blockStyle => getTemplate(`block style \"${blockStyle}\"`, \"block\"),\n  unknownListStyleWarning = listStyle => getTemplate(`list style \"${listStyle}\"`, \"list\"),\n  unknownListItemStyleWarning = listStyle => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst hidden = {\n    display: \"none\"\n  },\n  DefaultUnknownType = ({\n    value,\n    isInline\n  }) => {\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: hidden,\n      children: warning\n    }) : /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      style: hidden,\n      children: warning\n    });\n  },\n  DefaultUnknownMark = ({\n    markType,\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n    className: `unknown__pt__mark__${markType}`,\n    children\n  }),\n  DefaultUnknownBlockStyle = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n    children\n  }),\n  DefaultUnknownList = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n    children\n  }),\n  DefaultUnknownListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  DefaultHardBreak = () => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {}),\n  defaultBlockStyles = {\n    normal: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n      children\n    }),\n    blockquote: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"blockquote\", {\n      children\n    }),\n    h1: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", {\n      children\n    }),\n    h2: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n      children\n    }),\n    h3: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n      children\n    }),\n    h4: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h4\", {\n      children\n    }),\n    h5: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h5\", {\n      children\n    }),\n    h6: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", {\n      children\n    })\n  },\n  defaultComponents = {\n    types: {},\n    block: defaultBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n  };\nfunction mergeComponents(parent, overrides) {\n  const {\n      block,\n      list,\n      listItem,\n      marks,\n      types\n    } = overrides,\n    rest = _objectWithoutProperties(overrides, _excluded);\n  return _objectSpread(_objectSpread({}, parent), {}, {\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\")\n  }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key],\n    parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;\n}\nfunction PortableText({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning\n}) {\n  const handleMissingComponent = missingComponentHandler || noop,\n    blocks = Array.isArray(input) ? input : [input],\n    nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.LIST_NEST_MODE_HTML),\n    components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]),\n    renderNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]),\n    rendered = nested.map((node, index) => renderNode({\n      node,\n      index,\n      isInline: !1,\n      renderNode\n    }));\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: rendered\n  });\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const {\n        node,\n        index,\n        isInline\n      } = options,\n      key = node._key || `node-${index}`;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitList)(node) ? renderList(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextListItemBlock)(node) ? renderListItem(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitSpan)(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextBlock)(node) ? renderBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitTextNode)(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);\n  }\n  function hasCustomComponentForNode(node) {\n    return node._type in components.types;\n  }\n  function renderListItem(node, index, key) {\n    const tree = serializeBlock({\n        node,\n        index,\n        isInline: !1,\n        renderNode\n      }),\n      renderer = components.listItem,\n      Li = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const {\n          listItem\n        } = node,\n        blockNode = _objectWithoutProperties(node, _excluded2);\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: !1,\n        renderNode\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Li, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderList(node, index, key) {\n    const children = node.children.map((child, childIndex) => renderNode({\n        node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n          _key: `li-${index}-${childIndex}`\n        }),\n        index: childIndex,\n        isInline: !1,\n        renderNode\n      })),\n      component = components.list,\n      List = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (List === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: \"listStyle\",\n        type: style\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(List, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderSpan(node, _index, key) {\n    const {\n        markDef,\n        markType,\n        markKey\n      } = node,\n      Span = components.marks[markType] || components.unknownMark,\n      children = node.children.map((child, childIndex) => renderNode({\n        node: child,\n        index: childIndex,\n        isInline: !0,\n        renderNode\n      }));\n    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {\n      nodeType: \"mark\",\n      type: markType\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Span, {\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderBlock(node, index, key, isInline) {\n    const _serializeBlock = serializeBlock({\n        node,\n        index,\n        isInline,\n        renderNode\n      }),\n      {\n        _key\n      } = _serializeBlock,\n      props = _objectWithoutProperties(_serializeBlock, _excluded3),\n      style = props.node.style || \"normal\",\n      Block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Block, _objectSpread(_objectSpread({}, props), {}, {\n      value: props.node,\n      renderNode\n    }), key);\n  }\n  function renderText(node, key) {\n    if (node.text === `\n`) {\n      const HardBreak = components.hardBreak;\n      return HardBreak ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardBreak, {}, key) : `\n`;\n    }\n    return node.text;\n  }\n  function renderUnknownType(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    };\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: \"block\",\n      type: node._type\n    });\n    const UnknownType = components.unknownType;\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnknownType, _objectSpread({}, nodeOptions), key);\n  }\n  function renderCustomBlock(node, index, key, isInline) {\n    const nodeOptions = {\n        value: node,\n        isInline,\n        index,\n        renderNode\n      },\n      Node = components.types[node._type];\n    return Node ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Node, _objectSpread({}, nodeOptions), key) : null;\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const {\n      node,\n      index,\n      isInline,\n      renderNode\n    } = options,\n    children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.buildMarksTree)(node).map((child, i) => renderNode({\n      node: child,\n      isInline: !0,\n      index: i,\n      renderNode\n    }));\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsMENBQTBDLDBCQUEwQixtREFBbUQsb0NBQW9DLHlDQUF5QyxZQUFZLGNBQWMsc0NBQXNDLHFEQUFxRDtBQUN6VCwrQ0FBK0MsMEJBQTBCLFlBQVksdUJBQXVCLDhCQUE4QixpQ0FBaUMsZUFBZTtBQUN4STtBQUM2TDtBQUMzTDtBQUNwQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssb0JBQW9CLHNEQUFHO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFB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O0FBQ0E7QUFDQTtBQUN5RTtBQUN6RSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3JlYWN0L2Rpc3QvaW5kZXguanM/ZjJhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBfZXhjbHVkZWQgPSBbXCJibG9ja1wiLCBcImxpc3RcIiwgXCJsaXN0SXRlbVwiLCBcIm1hcmtzXCIsIFwidHlwZXNcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJsaXN0SXRlbVwiXSxcbiAgX2V4Y2x1ZGVkMyA9IFtcIl9rZXlcIl07XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7IGlmIChudWxsID09IGUpIHJldHVybiB7fTsgdmFyIG8sIHIsIGkgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShlLCB0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyBmb3IgKHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKykgbyA9IG5bcl0sIHQuaW5kZXhPZihvKSA+PSAwIHx8IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgbykgJiYgKGlbb10gPSBlW29dKTsgfSByZXR1cm4gaTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkgeyBpZiAobnVsbCA9PSByKSByZXR1cm4ge307IHZhciB0ID0ge307IGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHsgaWYgKGUuaW5kZXhPZihuKSA+PSAwKSBjb250aW51ZTsgdFtuXSA9IHJbbl07IH0gcmV0dXJuIHQ7IH1cbmltcG9ydCB7IGpzeCwgRnJhZ21lbnQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IG5lc3RMaXN0cywgTElTVF9ORVNUX01PREVfSFRNTCwgaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdCwgaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuLCBpc1BvcnRhYmxlVGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZSwgc3BhblRvUGxhaW5UZXh0LCBidWlsZE1hcmtzVHJlZSB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3Rvb2xraXRcIjtcbmltcG9ydCB7IHRvUGxhaW5UZXh0IH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvdG9vbGtpdFwiO1xuaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3QgZGVmYXVsdExpc3RzID0ge1xuICAgIG51bWJlcjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwib2xcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBidWxsZXQ6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInVsXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgfSxcbiAgRGVmYXVsdExpc3RJdGVtID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJsaVwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIGxpbmsgPSAoe1xuICAgIGNoaWxkcmVuLFxuICAgIHZhbHVlXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImFcIiwge1xuICAgIGhyZWY6IHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5ocmVmLFxuICAgIGNoaWxkcmVuXG4gIH0pLFxuICB1bmRlcmxpbmVTdHlsZSA9IHtcbiAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICB9LFxuICBkZWZhdWx0TWFya3MgPSB7XG4gICAgZW06ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImVtXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgc3Ryb25nOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJzdHJvbmdcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBjb2RlOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJjb2RlXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgdW5kZXJsaW5lOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJzcGFuXCIsIHtcbiAgICAgIHN0eWxlOiB1bmRlcmxpbmVTdHlsZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgXCJzdHJpa2UtdGhyb3VnaFwiOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJkZWxcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBsaW5rXG4gIH0sXG4gIGdldFRlbXBsYXRlID0gKHR5cGUsIHByb3ApID0+IGBbQHBvcnRhYmxldGV4dC9yZWFjdF0gVW5rbm93biAke3R5cGV9LCBzcGVjaWZ5IGEgY29tcG9uZW50IGZvciBpdCBpbiB0aGUgXFxgY29tcG9uZW50cy4ke3Byb3B9XFxgIHByb3BgLFxuICB1bmtub3duVHlwZVdhcm5pbmcgPSB0eXBlTmFtZSA9PiBnZXRUZW1wbGF0ZShgYmxvY2sgdHlwZSBcIiR7dHlwZU5hbWV9XCJgLCBcInR5cGVzXCIpLFxuICB1bmtub3duTWFya1dhcm5pbmcgPSBtYXJrVHlwZSA9PiBnZXRUZW1wbGF0ZShgbWFyayB0eXBlIFwiJHttYXJrVHlwZX1cImAsIFwibWFya3NcIiksXG4gIHVua25vd25CbG9ja1N0eWxlV2FybmluZyA9IGJsb2NrU3R5bGUgPT4gZ2V0VGVtcGxhdGUoYGJsb2NrIHN0eWxlIFwiJHtibG9ja1N0eWxlfVwiYCwgXCJibG9ja1wiKSxcbiAgdW5rbm93bkxpc3RTdHlsZVdhcm5pbmcgPSBsaXN0U3R5bGUgPT4gZ2V0VGVtcGxhdGUoYGxpc3Qgc3R5bGUgXCIke2xpc3RTdHlsZX1cImAsIFwibGlzdFwiKSxcbiAgdW5rbm93bkxpc3RJdGVtU3R5bGVXYXJuaW5nID0gbGlzdFN0eWxlID0+IGdldFRlbXBsYXRlKGBsaXN0IGl0ZW0gc3R5bGUgXCIke2xpc3RTdHlsZX1cImAsIFwibGlzdEl0ZW1cIik7XG5mdW5jdGlvbiBwcmludFdhcm5pbmcobWVzc2FnZSkge1xuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59XG5jb25zdCBoaWRkZW4gPSB7XG4gICAgZGlzcGxheTogXCJub25lXCJcbiAgfSxcbiAgRGVmYXVsdFVua25vd25UeXBlID0gKHtcbiAgICB2YWx1ZSxcbiAgICBpc0lubGluZVxuICB9KSA9PiB7XG4gICAgY29uc3Qgd2FybmluZyA9IHVua25vd25UeXBlV2FybmluZyh2YWx1ZS5fdHlwZSk7XG4gICAgcmV0dXJuIGlzSW5saW5lID8gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XG4gICAgICBzdHlsZTogaGlkZGVuLFxuICAgICAgY2hpbGRyZW46IHdhcm5pbmdcbiAgICB9KSA6IC8qIEBfX1BVUkVfXyAqL2pzeChcImRpdlwiLCB7XG4gICAgICBzdHlsZTogaGlkZGVuLFxuICAgICAgY2hpbGRyZW46IHdhcm5pbmdcbiAgICB9KTtcbiAgfSxcbiAgRGVmYXVsdFVua25vd25NYXJrID0gKHtcbiAgICBtYXJrVHlwZSxcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IGB1bmtub3duX19wdF9fbWFya19fJHttYXJrVHlwZX1gLFxuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBEZWZhdWx0VW5rbm93bkJsb2NrU3R5bGUgPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInBcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBEZWZhdWx0VW5rbm93bkxpc3QgPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcInVsXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdFVua25vd25MaXN0SXRlbSA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwibGlcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBEZWZhdWx0SGFyZEJyZWFrID0gKCkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiYnJcIiwge30pLFxuICBkZWZhdWx0QmxvY2tTdHlsZXMgPSB7XG4gICAgbm9ybWFsOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJwXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgYmxvY2txdW90ZTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiYmxvY2txdW90ZVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGgxOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoMVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGgyOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoMlwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGgzOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoM1wiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGg0OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoNFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGg1OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoNVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGg2OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJoNlwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0sXG4gIGRlZmF1bHRDb21wb25lbnRzID0ge1xuICAgIHR5cGVzOiB7fSxcbiAgICBibG9jazogZGVmYXVsdEJsb2NrU3R5bGVzLFxuICAgIG1hcmtzOiBkZWZhdWx0TWFya3MsXG4gICAgbGlzdDogZGVmYXVsdExpc3RzLFxuICAgIGxpc3RJdGVtOiBEZWZhdWx0TGlzdEl0ZW0sXG4gICAgaGFyZEJyZWFrOiBEZWZhdWx0SGFyZEJyZWFrLFxuICAgIHVua25vd25UeXBlOiBEZWZhdWx0VW5rbm93blR5cGUsXG4gICAgdW5rbm93bk1hcms6IERlZmF1bHRVbmtub3duTWFyayxcbiAgICB1bmtub3duTGlzdDogRGVmYXVsdFVua25vd25MaXN0LFxuICAgIHVua25vd25MaXN0SXRlbTogRGVmYXVsdFVua25vd25MaXN0SXRlbSxcbiAgICB1bmtub3duQmxvY2tTdHlsZTogRGVmYXVsdFVua25vd25CbG9ja1N0eWxlXG4gIH07XG5mdW5jdGlvbiBtZXJnZUNvbXBvbmVudHMocGFyZW50LCBvdmVycmlkZXMpIHtcbiAgY29uc3Qge1xuICAgICAgYmxvY2ssXG4gICAgICBsaXN0LFxuICAgICAgbGlzdEl0ZW0sXG4gICAgICBtYXJrcyxcbiAgICAgIHR5cGVzXG4gICAgfSA9IG92ZXJyaWRlcyxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG92ZXJyaWRlcywgX2V4Y2x1ZGVkKTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50KSwge30sIHtcbiAgICBibG9jazogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwiYmxvY2tcIiksXG4gICAgbGlzdDogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibGlzdFwiKSxcbiAgICBsaXN0SXRlbTogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwibGlzdEl0ZW1cIiksXG4gICAgbWFya3M6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcIm1hcmtzXCIpLFxuICAgIHR5cGVzOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJ0eXBlc1wiKVxuICB9LCByZXN0KTtcbn1cbmZ1bmN0aW9uIG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBrZXkpIHtcbiAgY29uc3Qgb3ZlcnJpZGUgPSBvdmVycmlkZXNba2V5XSxcbiAgICBwYXJlbnRWYWwgPSBwYXJlbnRba2V5XTtcbiAgcmV0dXJuIHR5cGVvZiBvdmVycmlkZSA9PSBcImZ1bmN0aW9uXCIgfHwgb3ZlcnJpZGUgJiYgdHlwZW9mIHBhcmVudFZhbCA9PSBcImZ1bmN0aW9uXCIgPyBvdmVycmlkZSA6IG92ZXJyaWRlID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXJlbnRWYWwpLCBvdmVycmlkZSkgOiBwYXJlbnRWYWw7XG59XG5mdW5jdGlvbiBQb3J0YWJsZVRleHQoe1xuICB2YWx1ZTogaW5wdXQsXG4gIGNvbXBvbmVudHM6IGNvbXBvbmVudE92ZXJyaWRlcyxcbiAgbGlzdE5lc3RpbmdNb2RlLFxuICBvbk1pc3NpbmdDb21wb25lbnQ6IG1pc3NpbmdDb21wb25lbnRIYW5kbGVyID0gcHJpbnRXYXJuaW5nXG59KSB7XG4gIGNvbnN0IGhhbmRsZU1pc3NpbmdDb21wb25lbnQgPSBtaXNzaW5nQ29tcG9uZW50SGFuZGxlciB8fCBub29wLFxuICAgIGJsb2NrcyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdLFxuICAgIG5lc3RlZCA9IG5lc3RMaXN0cyhibG9ja3MsIGxpc3ROZXN0aW5nTW9kZSB8fCBMSVNUX05FU1RfTU9ERV9IVE1MKSxcbiAgICBjb21wb25lbnRzID0gdXNlTWVtbygoKSA9PiBjb21wb25lbnRPdmVycmlkZXMgPyBtZXJnZUNvbXBvbmVudHMoZGVmYXVsdENvbXBvbmVudHMsIGNvbXBvbmVudE92ZXJyaWRlcykgOiBkZWZhdWx0Q29tcG9uZW50cywgW2NvbXBvbmVudE92ZXJyaWRlc10pLFxuICAgIHJlbmRlck5vZGUgPSB1c2VNZW1vKCgpID0+IGdldE5vZGVSZW5kZXJlcihjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KSwgW2NvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnRdKSxcbiAgICByZW5kZXJlZCA9IG5lc3RlZC5tYXAoKG5vZGUsIGluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICAgIG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogcmVuZGVyZWRcbiAgfSk7XG59XG5jb25zdCBnZXROb2RlUmVuZGVyZXIgPSAoY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCkgPT4ge1xuICBmdW5jdGlvbiByZW5kZXJOb2RlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZVxuICAgICAgfSA9IG9wdGlvbnMsXG4gICAgICBrZXkgPSBub2RlLl9rZXkgfHwgYG5vZGUtJHtpbmRleH1gO1xuICAgIHJldHVybiBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KG5vZGUpID8gcmVuZGVyTGlzdChub2RlLCBpbmRleCwga2V5KSA6IGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhub2RlKSA/IHJlbmRlckxpc3RJdGVtKG5vZGUsIGluZGV4LCBrZXkpIDogaXNQb3J0YWJsZVRleHRUb29sa2l0U3Bhbihub2RlKSA/IHJlbmRlclNwYW4obm9kZSwgaW5kZXgsIGtleSkgOiBoYXNDdXN0b21Db21wb25lbnRGb3JOb2RlKG5vZGUpID8gcmVuZGVyQ3VzdG9tQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIDogaXNQb3J0YWJsZVRleHRCbG9jayhub2RlKSA/IHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKG5vZGUpID8gcmVuZGVyVGV4dChub2RlLCBrZXkpIDogcmVuZGVyVW5rbm93blR5cGUobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0N1c3RvbUNvbXBvbmVudEZvck5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLl90eXBlIGluIGNvbXBvbmVudHMudHlwZXM7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdEl0ZW0obm9kZSwgaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHRyZWUgPSBzZXJpYWxpemVCbG9jayh7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZTogITEsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pLFxuICAgICAgcmVuZGVyZXIgPSBjb21wb25lbnRzLmxpc3RJdGVtLFxuICAgICAgTGkgPSAodHlwZW9mIHJlbmRlcmVyID09IFwiZnVuY3Rpb25cIiA/IHJlbmRlcmVyIDogcmVuZGVyZXJbbm9kZS5saXN0SXRlbV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3RJdGVtO1xuICAgIGlmIChMaSA9PT0gY29tcG9uZW50cy51bmtub3duTGlzdEl0ZW0pIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5saXN0SXRlbSB8fCBcImJ1bGxldFwiO1xuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICAgIHR5cGU6IHN0eWxlLFxuICAgICAgICBub2RlVHlwZTogXCJsaXN0SXRlbVN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xuICAgIGlmIChub2RlLnN0eWxlICYmIG5vZGUuc3R5bGUgIT09IFwibm9ybWFsXCIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsaXN0SXRlbVxuICAgICAgICB9ID0gbm9kZSxcbiAgICAgICAgYmxvY2tOb2RlID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIpO1xuICAgICAgY2hpbGRyZW4gPSByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogYmxvY2tOb2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChMaSwge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0sIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdChub2RlLCBpbmRleCwga2V5KSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgICBub2RlOiBjaGlsZC5fa2V5ID8gY2hpbGQgOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkKSwge30sIHtcbiAgICAgICAgICBfa2V5OiBgbGktJHtpbmRleH0tJHtjaGlsZEluZGV4fWBcbiAgICAgICAgfSksXG4gICAgICAgIGluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBpc0lubGluZTogITEsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pKSxcbiAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHMubGlzdCxcbiAgICAgIExpc3QgPSAodHlwZW9mIGNvbXBvbmVudCA9PSBcImZ1bmN0aW9uXCIgPyBjb21wb25lbnQgOiBjb21wb25lbnRbbm9kZS5saXN0SXRlbV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3Q7XG4gICAgaWYgKExpc3QgPT09IGNvbXBvbmVudHMudW5rbm93bkxpc3QpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5saXN0SXRlbSB8fCBcImJ1bGxldFwiO1xuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdFN0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgICAgbm9kZVR5cGU6IFwibGlzdFN0eWxlXCIsXG4gICAgICAgIHR5cGU6IHN0eWxlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChMaXN0LCB7XG4gICAgICB2YWx1ZTogbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgcmVuZGVyTm9kZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJTcGFuKG5vZGUsIF9pbmRleCwga2V5KSB7XG4gICAgY29uc3Qge1xuICAgICAgICBtYXJrRGVmLFxuICAgICAgICBtYXJrVHlwZSxcbiAgICAgICAgbWFya0tleVxuICAgICAgfSA9IG5vZGUsXG4gICAgICBTcGFuID0gY29tcG9uZW50cy5tYXJrc1ttYXJrVHlwZV0gfHwgY29tcG9uZW50cy51bmtub3duTWFyayxcbiAgICAgIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkLCBjaGlsZEluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIGluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgICBpc0lubGluZTogITAsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pKTtcbiAgICByZXR1cm4gU3BhbiA9PT0gY29tcG9uZW50cy51bmtub3duTWFyayAmJiBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25NYXJrV2FybmluZyhtYXJrVHlwZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcIm1hcmtcIixcbiAgICAgIHR5cGU6IG1hcmtUeXBlXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChTcGFuLCB7XG4gICAgICB0ZXh0OiBzcGFuVG9QbGFpblRleHQobm9kZSksXG4gICAgICB2YWx1ZTogbWFya0RlZixcbiAgICAgIG1hcmtUeXBlLFxuICAgICAgbWFya0tleSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0sIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpIHtcbiAgICBjb25zdCBfc2VyaWFsaXplQmxvY2sgPSBzZXJpYWxpemVCbG9jayh7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBpc0lubGluZSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIF9rZXlcbiAgICAgIH0gPSBfc2VyaWFsaXplQmxvY2ssXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfc2VyaWFsaXplQmxvY2ssIF9leGNsdWRlZDMpLFxuICAgICAgc3R5bGUgPSBwcm9wcy5ub2RlLnN0eWxlIHx8IFwibm9ybWFsXCIsXG4gICAgICBCbG9jayA9ICh0eXBlb2YgY29tcG9uZW50cy5ibG9jayA9PSBcImZ1bmN0aW9uXCIgPyBjb21wb25lbnRzLmJsb2NrIDogY29tcG9uZW50cy5ibG9ja1tzdHlsZV0pIHx8IGNvbXBvbmVudHMudW5rbm93bkJsb2NrU3R5bGU7XG4gICAgcmV0dXJuIEJsb2NrID09PSBjb21wb25lbnRzLnVua25vd25CbG9ja1N0eWxlICYmIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkJsb2NrU3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgbm9kZVR5cGU6IFwiYmxvY2tTdHlsZVwiLFxuICAgICAgdHlwZTogc3R5bGVcbiAgICB9KSwgLyogQF9fUFVSRV9fICovanN4KEJsb2NrLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgIHZhbHVlOiBwcm9wcy5ub2RlLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pLCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclRleHQobm9kZSwga2V5KSB7XG4gICAgaWYgKG5vZGUudGV4dCA9PT0gYFxuYCkge1xuICAgICAgY29uc3QgSGFyZEJyZWFrID0gY29tcG9uZW50cy5oYXJkQnJlYWs7XG4gICAgICByZXR1cm4gSGFyZEJyZWFrID8gLyogQF9fUFVSRV9fICovanN4KEhhcmRCcmVhaywge30sIGtleSkgOiBgXG5gO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS50ZXh0O1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlclVua25vd25UeXBlKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSB7XG4gICAgY29uc3Qgbm9kZU9wdGlvbnMgPSB7XG4gICAgICB2YWx1ZTogbm9kZSxcbiAgICAgIGlzSW5saW5lLFxuICAgICAgaW5kZXgsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfTtcbiAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25UeXBlV2FybmluZyhub2RlLl90eXBlKSwge1xuICAgICAgbm9kZVR5cGU6IFwiYmxvY2tcIixcbiAgICAgIHR5cGU6IG5vZGUuX3R5cGVcbiAgICB9KTtcbiAgICBjb25zdCBVbmtub3duVHlwZSA9IGNvbXBvbmVudHMudW5rbm93blR5cGU7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChVbmtub3duVHlwZSwgX29iamVjdFNwcmVhZCh7fSwgbm9kZU9wdGlvbnMpLCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckN1c3RvbUJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSB7XG4gICAgY29uc3Qgbm9kZU9wdGlvbnMgPSB7XG4gICAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgICBpc0lubGluZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0sXG4gICAgICBOb2RlID0gY29tcG9uZW50cy50eXBlc1tub2RlLl90eXBlXTtcbiAgICByZXR1cm4gTm9kZSA/IC8qIEBfX1BVUkVfXyAqL2pzeChOb2RlLCBfb2JqZWN0U3ByZWFkKHt9LCBub2RlT3B0aW9ucyksIGtleSkgOiBudWxsO1xuICB9XG4gIHJldHVybiByZW5kZXJOb2RlO1xufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUJsb2NrKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgICAgbm9kZSxcbiAgICAgIGluZGV4LFxuICAgICAgaXNJbmxpbmUsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSA9IG9wdGlvbnMsXG4gICAgY2hpbGRyZW4gPSBidWlsZE1hcmtzVHJlZShub2RlKS5tYXAoKGNoaWxkLCBpKSA9PiByZW5kZXJOb2RlKHtcbiAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgaXNJbmxpbmU6ICEwLFxuICAgICAgaW5kZXg6IGksXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSkpO1xuICByZXR1cm4ge1xuICAgIF9rZXk6IG5vZGUuX2tleSB8fCBgYmxvY2stJHtpbmRleH1gLFxuICAgIGNoaWxkcmVuLFxuICAgIGluZGV4LFxuICAgIGlzSW5saW5lLFxuICAgIG5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZXhwb3J0IHsgUG9ydGFibGVUZXh0LCBkZWZhdWx0Q29tcG9uZW50cywgbWVyZ2VDb21wb25lbnRzLCB0b1BsYWluVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/toolkit/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/toolkit/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && (\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    !(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) &&\n    // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every(def => typeof def._key == \"string\")) &&\n    // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every(child => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) return [];\n  if (!span.marks.length) return [];\n  const marks = span.marks.slice(),\n    occurences = {};\n  return marks.forEach(mark => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;else break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA],\n    bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences) return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA),\n    bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a;\n  const {\n    children,\n    markDefs = []\n  } = block;\n  if (!children || !children.length) return [];\n  const sortedMarks = children.map(sortMarksByOccurences),\n    rootNode = {\n      _type: \"@span\",\n      children: [],\n      markType: \"<unknown>\"\n    };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span) continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {\n      const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\",\n        index = marksNeeded.indexOf(mark);\n      if (index === -1) break;\n      marksNeeded.splice(index, 1);\n    }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs.find(def => def._key === markKey),\n          markType = markDef ? markDef._type : markKey,\n          node = {\n            _type: \"@span\",\n            _key: span._key,\n            children: [],\n            markDef,\n            markType,\n            markKey\n          };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1;) lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(lines.map(text => ({\n          _type: \"@text\",\n          text\n        })));\n      } else currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1],\n            newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n              children: [...lastListItem.children, newList]\n            });\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else currentList.children.push(newList);\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, {\n            level: block.level || 1\n          });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1,\n    style = matching.listItem || \"normal\",\n    filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) return rootNode;\n  if (!(\"children\" in rootNode)) return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach(current => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/,\n  trailingSpace = /\\s$/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) return;\n    let pad = !1;\n    current.children.forEach(span => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\",\n  LIST_NEST_MODE_DIRECT = \"direct\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4QiwwQ0FBMEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsb0NBQW9DLHVFQUF1RTtBQUN6UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQSwySUFBMkk7QUFDM0k7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsbUJBQW1CO0FBQzVFO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCLE1BQU0sRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDaVM7QUFDalMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanM/NDI4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcInNwYW5cIiAmJiBcInRleHRcIiBpbiBub2RlICYmIHR5cGVvZiBub2RlLnRleHQgPT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIG5vZGUubWFya3MgPiBcInVcIiB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya3MpICYmIG5vZGUubWFya3MuZXZlcnkobWFyayA9PiB0eXBlb2YgbWFyayA9PSBcInN0cmluZ1wiKSk7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBBIGJsb2NrIGRvZXNuJ3QgX2hhdmVfIHRvIGJlIG5hbWVkICdibG9jaycgLSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW5cbiAgICAvLyBhbGxvd2VkIGNoaWxkIHR5cGVzIGFuZCBtYXJrcywgb25lIG1pZ2h0IG5hbWUgdGhlbSBkaWZmZXJlbnRseVxuICAgIHR5cGVvZiBub2RlLl90eXBlID09IFwic3RyaW5nXCIgJiZcbiAgICAvLyBUb29sa2l0LXR5cGVzIGxpa2UgbmVzdGVkIHNwYW5zIGFyZSBALXByZWZpeGVkXG4gICAgbm9kZS5fdHlwZVswXSAhPT0gXCJAXCIgJiYgKFxuICAgIC8vIGBtYXJrRGVmc2AgaXNuJ3QgX3JlcXVpcmVkXyBwZXIgc2F5LCBidXQgaWYgaXQncyB0aGVyZSwgaXQgbmVlZHMgdG8gYmUgYW4gYXJyYXlcbiAgICAhKFwibWFya0RlZnNcIiBpbiBub2RlKSB8fCAhbm9kZS5tYXJrRGVmcyB8fCBBcnJheS5pc0FycmF5KG5vZGUubWFya0RlZnMpICYmXG4gICAgLy8gRXZlcnkgbWFyayBkZWZpbml0aW9uIG5lZWRzIHRvIGhhdmUgYW4gYF9rZXlgIHRvIGJlIG1hcHBhYmxlIGluIGNoaWxkIHNwYW5zXG4gICAgbm9kZS5tYXJrRGVmcy5ldmVyeShkZWYgPT4gdHlwZW9mIGRlZi5fa2V5ID09IFwic3RyaW5nXCIpKSAmJlxuICAgIC8vIGBjaGlsZHJlbmAgaXMgcmVxdWlyZWQgYW5kIG5lZWRzIHRvIGJlIGFuIGFycmF5XG4gICAgXCJjaGlsZHJlblwiIGluIG5vZGUgJiYgQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSAmJlxuICAgIC8vIEFsbCBjaGlsZHJlbiBhcmUgb2JqZWN0cyB3aXRoIGBfdHlwZWAgKHVzdWFsbHkgc3BhbnMsIGJ1dCBjYW4gY29udGFpbiBvdGhlciBzdHVmZilcbiAgICBub2RlLmNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IHR5cGVvZiBjaGlsZCA9PSBcIm9iamVjdFwiICYmIFwiX3R5cGVcIiBpbiBjaGlsZClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhibG9jaykge1xuICByZXR1cm4gaXNQb3J0YWJsZVRleHRCbG9jayhibG9jaykgJiYgXCJsaXN0SXRlbVwiIGluIGJsb2NrICYmIHR5cGVvZiBibG9jay5saXN0SXRlbSA9PSBcInN0cmluZ1wiICYmICh0eXBlb2YgYmxvY2subGV2ZWwgPiBcInVcIiB8fCB0eXBlb2YgYmxvY2subGV2ZWwgPT0gXCJudW1iZXJcIik7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KGJsb2NrKSB7XG4gIHJldHVybiBibG9jay5fdHlwZSA9PT0gXCJAbGlzdFwiO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbihzcGFuKSB7XG4gIHJldHVybiBzcGFuLl90eXBlID09PSBcIkBzcGFuXCI7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcIkB0ZXh0XCI7XG59XG5jb25zdCBrbm93bkRlY29yYXRvcnMgPSBbXCJzdHJvbmdcIiwgXCJlbVwiLCBcImNvZGVcIiwgXCJ1bmRlcmxpbmVcIiwgXCJzdHJpa2UtdGhyb3VnaFwiXTtcbmZ1bmN0aW9uIHNvcnRNYXJrc0J5T2NjdXJlbmNlcyhzcGFuLCBpbmRleCwgYmxvY2tDaGlsZHJlbikge1xuICBpZiAoIWlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSB8fCAhc3Bhbi5tYXJrcykgcmV0dXJuIFtdO1xuICBpZiAoIXNwYW4ubWFya3MubGVuZ3RoKSByZXR1cm4gW107XG4gIGNvbnN0IG1hcmtzID0gc3Bhbi5tYXJrcy5zbGljZSgpLFxuICAgIG9jY3VyZW5jZXMgPSB7fTtcbiAgcmV0dXJuIG1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgb2NjdXJlbmNlc1ttYXJrXSA9IDE7XG4gICAgZm9yIChsZXQgc2libGluZ0luZGV4ID0gaW5kZXggKyAxOyBzaWJsaW5nSW5kZXggPCBibG9ja0NoaWxkcmVuLmxlbmd0aDsgc2libGluZ0luZGV4KyspIHtcbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBibG9ja0NoaWxkcmVuW3NpYmxpbmdJbmRleF07XG4gICAgICBpZiAoc2libGluZyAmJiBpc1BvcnRhYmxlVGV4dFNwYW4oc2libGluZykgJiYgQXJyYXkuaXNBcnJheShzaWJsaW5nLm1hcmtzKSAmJiBzaWJsaW5nLm1hcmtzLmluZGV4T2YobWFyaykgIT09IC0xKSBvY2N1cmVuY2VzW21hcmtdKys7ZWxzZSBicmVhaztcbiAgICB9XG4gIH0pLCBtYXJrcy5zb3J0KChtYXJrQSwgbWFya0IpID0+IHNvcnRNYXJrcyhvY2N1cmVuY2VzLCBtYXJrQSwgbWFya0IpKTtcbn1cbmZ1bmN0aW9uIHNvcnRNYXJrcyhvY2N1cmVuY2VzLCBtYXJrQSwgbWFya0IpIHtcbiAgY29uc3QgYU9jY3VyZW5jZXMgPSBvY2N1cmVuY2VzW21hcmtBXSxcbiAgICBiT2NjdXJlbmNlcyA9IG9jY3VyZW5jZXNbbWFya0JdO1xuICBpZiAoYU9jY3VyZW5jZXMgIT09IGJPY2N1cmVuY2VzKSByZXR1cm4gYk9jY3VyZW5jZXMgLSBhT2NjdXJlbmNlcztcbiAgY29uc3QgYUtub3duUG9zID0ga25vd25EZWNvcmF0b3JzLmluZGV4T2YobWFya0EpLFxuICAgIGJLbm93blBvcyA9IGtub3duRGVjb3JhdG9ycy5pbmRleE9mKG1hcmtCKTtcbiAgcmV0dXJuIGFLbm93blBvcyAhPT0gYktub3duUG9zID8gYUtub3duUG9zIC0gYktub3duUG9zIDogbWFya0EubG9jYWxlQ29tcGFyZShtYXJrQik7XG59XG5mdW5jdGlvbiBidWlsZE1hcmtzVHJlZShibG9jaykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBtYXJrRGVmcyA9IFtdXG4gIH0gPSBibG9jaztcbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSByZXR1cm4gW107XG4gIGNvbnN0IHNvcnRlZE1hcmtzID0gY2hpbGRyZW4ubWFwKHNvcnRNYXJrc0J5T2NjdXJlbmNlcyksXG4gICAgcm9vdE5vZGUgPSB7XG4gICAgICBfdHlwZTogXCJAc3BhblwiLFxuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgbWFya1R5cGU6IFwiPHVua25vd24+XCJcbiAgICB9O1xuICBsZXQgbm9kZVN0YWNrID0gW3Jvb3ROb2RlXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNwYW4gPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoIXNwYW4pIGNvbnRpbnVlO1xuICAgIGNvbnN0IG1hcmtzTmVlZGVkID0gc29ydGVkTWFya3NbaV0gfHwgW107XG4gICAgbGV0IHBvcyA9IDE7XG4gICAgaWYgKG5vZGVTdGFjay5sZW5ndGggPiAxKSBmb3IgKHBvczsgcG9zIDwgbm9kZVN0YWNrLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgIGNvbnN0IG1hcmsgPSAoKF9hID0gbm9kZVN0YWNrW3Bvc10pID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXJrS2V5KSB8fCBcIlwiLFxuICAgICAgICBpbmRleCA9IG1hcmtzTmVlZGVkLmluZGV4T2YobWFyayk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSBicmVhaztcbiAgICAgIG1hcmtzTmVlZGVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIG5vZGVTdGFjayA9IG5vZGVTdGFjay5zbGljZSgwLCBwb3MpO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGVTdGFja1tub2RlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgICBmb3IgKGNvbnN0IG1hcmtLZXkgb2YgbWFya3NOZWVkZWQpIHtcbiAgICAgICAgY29uc3QgbWFya0RlZiA9IG1hcmtEZWZzLmZpbmQoZGVmID0+IGRlZi5fa2V5ID09PSBtYXJrS2V5KSxcbiAgICAgICAgICBtYXJrVHlwZSA9IG1hcmtEZWYgPyBtYXJrRGVmLl90eXBlIDogbWFya0tleSxcbiAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgX3R5cGU6IFwiQHNwYW5cIixcbiAgICAgICAgICAgIF9rZXk6IHNwYW4uX2tleSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIG1hcmtEZWYsXG4gICAgICAgICAgICBtYXJrVHlwZSxcbiAgICAgICAgICAgIG1hcmtLZXlcbiAgICAgICAgICB9O1xuICAgICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKG5vZGUpLCBub2RlU3RhY2sucHVzaChub2RlKSwgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHNwYW4udGV4dC5zcGxpdChgXG5gKTtcbiAgICAgICAgZm9yIChsZXQgbGluZSA9IGxpbmVzLmxlbmd0aDsgbGluZS0tID4gMTspIGxpbmVzLnNwbGljZShsaW5lLCAwLCBgXG5gKTtcbiAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQobGluZXMubWFwKHRleHQgPT4gKHtcbiAgICAgICAgICBfdHlwZTogXCJAdGV4dFwiLFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfSkpKTtcbiAgICAgIH0gZWxzZSBjdXJyZW50Tm9kZS5jaGlsZHJlbiA9IGN1cnJlbnROb2RlLmNoaWxkcmVuLmNvbmNhdChzcGFuKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3ROb2RlLmNoaWxkcmVuO1xufVxuZnVuY3Rpb24gbmVzdExpc3RzKGJsb2NrcywgbW9kZSkge1xuICBjb25zdCB0cmVlID0gW107XG4gIGxldCBjdXJyZW50TGlzdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICBpZiAoYmxvY2spIHtcbiAgICAgIGlmICghaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKGJsb2NrKSkge1xuICAgICAgICB0cmVlLnB1c2goYmxvY2spLCBjdXJyZW50TGlzdCA9IHZvaWQgMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWN1cnJlbnRMaXN0KSB7XG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSksIHRyZWUucHVzaChjdXJyZW50TGlzdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2NrTWF0Y2hlc0xpc3QoYmxvY2ssIGN1cnJlbnRMaXN0KSkge1xuICAgICAgICBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoKGJsb2NrLmxldmVsIHx8IDEpID4gY3VycmVudExpc3QubGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbmV3TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpO1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgICBjb25zdCBsYXN0TGlzdEl0ZW0gPSBjdXJyZW50TGlzdC5jaGlsZHJlbltjdXJyZW50TGlzdC5jaGlsZHJlbi5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIG5ld0xhc3RDaGlsZCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbGFzdExpc3RJdGVtKSwge30sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFsuLi5sYXN0TGlzdEl0ZW0uY2hpbGRyZW4sIG5ld0xpc3RdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJyZW50TGlzdC5jaGlsZHJlbltjdXJyZW50TGlzdC5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IG5ld0xhc3RDaGlsZDtcbiAgICAgICAgfSBlbHNlIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2gobmV3TGlzdCk7XG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbmV3TGlzdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoKGJsb2NrLmxldmVsIHx8IDEpIDwgY3VycmVudExpc3QubGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdCcmFuY2ggPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaGluZ0JyYW5jaCAmJiBmaW5kTGlzdE1hdGNoaW5nKG1hdGNoaW5nQnJhbmNoLCBibG9jayk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGN1cnJlbnRMaXN0ID0gbWF0Y2gsIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goYmxvY2spO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSksIHRyZWUucHVzaChjdXJyZW50TGlzdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJsb2NrLmxpc3RJdGVtICE9PSBjdXJyZW50TGlzdC5saXN0SXRlbSkge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0JyYW5jaCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXSxcbiAgICAgICAgICBtYXRjaCA9IG1hdGNoaW5nQnJhbmNoICYmIGZpbmRMaXN0TWF0Y2hpbmcobWF0Y2hpbmdCcmFuY2gsIHtcbiAgICAgICAgICAgIGxldmVsOiBibG9jay5sZXZlbCB8fCAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5saXN0SXRlbSA9PT0gYmxvY2subGlzdEl0ZW0pIHtcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IG1hdGNoLCBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIHN0YXRlIGVuY291bnRlcmVkIGZvciBibG9ja1wiLCBibG9jayksIHRyZWUucHVzaChibG9jayk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmVlO1xufVxuZnVuY3Rpb24gYmxvY2tNYXRjaGVzTGlzdChibG9jaywgbGlzdCkge1xuICByZXR1cm4gKGJsb2NrLmxldmVsIHx8IDEpID09PSBsaXN0LmxldmVsICYmIGJsb2NrLmxpc3RJdGVtID09PSBsaXN0Lmxpc3RJdGVtO1xufVxuZnVuY3Rpb24gbGlzdEZyb21CbG9jayhibG9jaywgaW5kZXgsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBfdHlwZTogXCJAbGlzdFwiLFxuICAgIF9rZXk6IGAke2Jsb2NrLl9rZXkgfHwgYCR7aW5kZXh9YH0tcGFyZW50YCxcbiAgICBtb2RlLFxuICAgIGxldmVsOiBibG9jay5sZXZlbCB8fCAxLFxuICAgIGxpc3RJdGVtOiBibG9jay5saXN0SXRlbSxcbiAgICBjaGlsZHJlbjogW2Jsb2NrXVxuICB9O1xufVxuZnVuY3Rpb24gZmluZExpc3RNYXRjaGluZyhyb290Tm9kZSwgbWF0Y2hpbmcpIHtcbiAgY29uc3QgbGV2ZWwgPSBtYXRjaGluZy5sZXZlbCB8fCAxLFxuICAgIHN0eWxlID0gbWF0Y2hpbmcubGlzdEl0ZW0gfHwgXCJub3JtYWxcIixcbiAgICBmaWx0ZXJPblR5cGUgPSB0eXBlb2YgbWF0Y2hpbmcubGlzdEl0ZW0gPT0gXCJzdHJpbmdcIjtcbiAgaWYgKGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3Qocm9vdE5vZGUpICYmIChyb290Tm9kZS5sZXZlbCB8fCAxKSA9PT0gbGV2ZWwgJiYgZmlsdGVyT25UeXBlICYmIChyb290Tm9kZS5saXN0SXRlbSB8fCBcIm5vcm1hbFwiKSA9PT0gc3R5bGUpIHJldHVybiByb290Tm9kZTtcbiAgaWYgKCEoXCJjaGlsZHJlblwiIGluIHJvb3ROb2RlKSkgcmV0dXJuO1xuICBjb25zdCBub2RlID0gcm9vdE5vZGUuY2hpbGRyZW5bcm9vdE5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIHJldHVybiBub2RlICYmICFpc1BvcnRhYmxlVGV4dFNwYW4obm9kZSkgPyBmaW5kTGlzdE1hdGNoaW5nKG5vZGUsIG1hdGNoaW5nKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHNwYW5Ub1BsYWluVGV4dChzcGFuKSB7XG4gIGxldCB0ZXh0ID0gXCJcIjtcbiAgcmV0dXJuIHNwYW4uY2hpbGRyZW4uZm9yRWFjaChjdXJyZW50ID0+IHtcbiAgICBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShjdXJyZW50KSA/IHRleHQgKz0gY3VycmVudC50ZXh0IDogaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbihjdXJyZW50KSAmJiAodGV4dCArPSBzcGFuVG9QbGFpblRleHQoY3VycmVudCkpO1xuICB9KSwgdGV4dDtcbn1cbmNvbnN0IGxlYWRpbmdTcGFjZSA9IC9eXFxzLyxcbiAgdHJhaWxpbmdTcGFjZSA9IC9cXHMkLztcbmZ1bmN0aW9uIHRvUGxhaW5UZXh0KGJsb2NrKSB7XG4gIGNvbnN0IGJsb2NrcyA9IEFycmF5LmlzQXJyYXkoYmxvY2spID8gYmxvY2sgOiBbYmxvY2tdO1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHJldHVybiBibG9ja3MuZm9yRWFjaCgoY3VycmVudCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWlzUG9ydGFibGVUZXh0QmxvY2soY3VycmVudCkpIHJldHVybjtcbiAgICBsZXQgcGFkID0gITE7XG4gICAgY3VycmVudC5jaGlsZHJlbi5mb3JFYWNoKHNwYW4gPT4ge1xuICAgICAgaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pID8gKHRleHQgKz0gcGFkICYmIHRleHQgJiYgIXRyYWlsaW5nU3BhY2UudGVzdCh0ZXh0KSAmJiAhbGVhZGluZ1NwYWNlLnRlc3Qoc3Bhbi50ZXh0KSA/IFwiIFwiIDogXCJcIiwgdGV4dCArPSBzcGFuLnRleHQsIHBhZCA9ICExKSA6IHBhZCA9ICEwO1xuICAgIH0pLCBpbmRleCAhPT0gYmxvY2tzLmxlbmd0aCAtIDEgJiYgKHRleHQgKz0gYFxuXG5gKTtcbiAgfSksIHRleHQ7XG59XG5jb25zdCBMSVNUX05FU1RfTU9ERV9IVE1MID0gXCJodG1sXCIsXG4gIExJU1RfTkVTVF9NT0RFX0RJUkVDVCA9IFwiZGlyZWN0XCI7XG5leHBvcnQgeyBMSVNUX05FU1RfTU9ERV9ESVJFQ1QsIExJU1RfTkVTVF9NT0RFX0hUTUwsIGJ1aWxkTWFya3NUcmVlLCBpc1BvcnRhYmxlVGV4dEJsb2NrLCBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2ssIGlzUG9ydGFibGVUZXh0U3BhbiwgaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdCwgaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbiwgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUsIG5lc3RMaXN0cywgc29ydE1hcmtzQnlPY2N1cmVuY2VzLCBzcGFuVG9QbGFpblRleHQsIHRvUGxhaW5UZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ })

};
;