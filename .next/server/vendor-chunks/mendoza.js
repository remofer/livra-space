"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mendoza";
exports.ids = ["vendor-chunks/mendoza"];
exports.modules = {

/***/ "(ssr)/./node_modules/mendoza/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/mendoza/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPatch: () => (/* binding */ applyPatch),\n/* harmony export */   incremental: () => (/* binding */ incrementalPatcher)\n/* harmony export */ });\nconst OPS = [\n  \"Value\",\n  \"Copy\",\n  \"Blank\",\n  \"ReturnIntoArray\",\n  \"ReturnIntoObject\",\n  \"ReturnIntoObjectSameKey\",\n  \"PushField\",\n  \"PushElement\",\n  \"PushParent\",\n  \"Pop\",\n  \"PushFieldCopy\",\n  \"PushFieldBlank\",\n  \"PushElementCopy\",\n  \"PushElementBlank\",\n  \"ReturnIntoObjectPop\",\n  \"ReturnIntoObjectSameKeyPop\",\n  \"ReturnIntoArrayPop\",\n  \"ObjectSetFieldValue\",\n  \"ObjectCopyField\",\n  \"ObjectDeleteField\",\n  \"ArrayAppendValue\",\n  \"ArrayAppendSlice\",\n  \"StringAppendString\",\n  \"StringAppendSlice\"\n];\nclass Patcher {\n  constructor(model, root, patch) {\n    this.model = model, this.root = root, this.patch = patch, this.i = 0, this.inputStack = [], this.outputStack = [];\n  }\n  read() {\n    return this.patch[this.i++];\n  }\n  process() {\n    for (this.inputStack.push({ value: this.root }), this.outputStack.push({ value: this.root }); this.i < this.patch.length; ) {\n      let opcode = this.read(), op = OPS[opcode];\n      if (!op)\n        throw new Error(`Unknown opcode: ${opcode}`);\n      let processor = `process${op}`;\n      this[processor].apply(this);\n    }\n    let entry = this.outputStack.pop();\n    return this.finalizeOutput(entry);\n  }\n  inputEntry() {\n    return this.inputStack[this.inputStack.length - 1];\n  }\n  inputKey(entry, idx) {\n    return entry.keys || (entry.keys = this.model.objectGetKeys(entry.value).sort()), entry.keys[idx];\n  }\n  outputEntry() {\n    return this.outputStack[this.outputStack.length - 1];\n  }\n  outputArray() {\n    let entry = this.outputEntry();\n    return entry.writeValue || (entry.writeValue = this.model.copyArray(entry.value)), entry.writeValue;\n  }\n  outputObject() {\n    let entry = this.outputEntry();\n    return entry.writeValue || (entry.writeValue = this.model.copyObject(entry.value)), entry.writeValue;\n  }\n  outputString() {\n    let entry = this.outputEntry();\n    return entry.writeValue || (entry.writeValue = this.model.copyString(entry.value)), entry.writeValue;\n  }\n  finalizeOutput(entry) {\n    return entry.writeValue ? this.model.finalize(entry.writeValue) : entry.value;\n  }\n  // Processors:\n  processValue() {\n    let value = this.model.wrap(this.read());\n    this.outputStack.push({ value });\n  }\n  processCopy() {\n    let input = this.inputEntry();\n    this.outputStack.push({ value: input.value });\n  }\n  processBlank() {\n    this.outputStack.push({ value: null });\n  }\n  processReturnIntoArray() {\n    let entry = this.outputStack.pop(), result = this.finalizeOutput(entry), arr = this.outputArray();\n    this.model.arrayAppendValue(arr, result);\n  }\n  processReturnIntoObject() {\n    let key = this.read(), entry = this.outputStack.pop(), result = this.finalizeOutput(entry);\n    result = this.model.markChanged(result);\n    let obj = this.outputObject();\n    this.model.objectSetField(obj, key, result);\n  }\n  processReturnIntoObjectSameKey() {\n    let input = this.inputEntry(), entry = this.outputStack.pop(), result = this.finalizeOutput(entry), obj = this.outputObject();\n    this.model.objectSetField(obj, input.key, result);\n  }\n  processPushField() {\n    let idx = this.read(), entry = this.inputEntry(), key = this.inputKey(entry, idx), value = this.model.objectGetField(entry.value, key);\n    this.inputStack.push({ value, key });\n  }\n  processPushElement() {\n    let idx = this.read(), entry = this.inputEntry(), value = this.model.arrayGetElement(entry.value, idx);\n    this.inputStack.push({ value });\n  }\n  processPop() {\n    this.inputStack.pop();\n  }\n  processPushFieldCopy() {\n    this.processPushField(), this.processCopy();\n  }\n  processPushFieldBlank() {\n    this.processPushField(), this.processBlank();\n  }\n  processPushElementCopy() {\n    this.processPushElement(), this.processCopy();\n  }\n  processPushElementBlank() {\n    this.processPushElement(), this.processBlank();\n  }\n  processReturnIntoObjectPop() {\n    this.processReturnIntoObject(), this.processPop();\n  }\n  processReturnIntoObjectSameKeyPop() {\n    this.processReturnIntoObjectSameKey(), this.processPop();\n  }\n  processReturnIntoArrayPop() {\n    this.processReturnIntoArray(), this.processPop();\n  }\n  processObjectSetFieldValue() {\n    this.processValue(), this.processReturnIntoObject();\n  }\n  processObjectCopyField() {\n    this.processPushField(), this.processCopy(), this.processReturnIntoObjectSameKey(), this.processPop();\n  }\n  processObjectDeleteField() {\n    let idx = this.read(), entry = this.inputEntry(), key = this.inputKey(entry, idx), obj = this.outputObject();\n    this.model.objectDeleteField(obj, key);\n  }\n  processArrayAppendValue() {\n    let value = this.model.wrap(this.read()), arr = this.outputArray();\n    this.model.arrayAppendValue(arr, value);\n  }\n  processArrayAppendSlice() {\n    let left = this.read(), right = this.read(), str = this.outputArray(), val = this.inputEntry().value;\n    this.model.arrayAppendSlice(str, val, left, right);\n  }\n  processStringAppendString() {\n    let value = this.model.wrap(this.read()), str = this.outputString();\n    this.model.stringAppendValue(str, value);\n  }\n  processStringAppendSlice() {\n    let left = this.read(), right = this.read(), str = this.outputString(), val = this.inputEntry().value;\n    this.model.stringAppendSlice(str, val, left, right);\n  }\n}\nfunction utf8charSize(code) {\n  return code >> 16 ? 4 : code >> 11 ? 3 : code >> 7 ? 2 : 1;\n}\nfunction utf8stringSize(str) {\n  let b = 0;\n  for (let i = 0; i < str.length; i++) {\n    let code = str.codePointAt(i), size = utf8charSize(code);\n    size == 4 && i++, b += size;\n  }\n  return b;\n}\nfunction utf8resolveIndex(str, idx, start = 0) {\n  let byteCount = start, ucsIdx = 0;\n  for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n    let code = str.codePointAt(ucsIdx), size = utf8charSize(code);\n    size === 4 && ucsIdx++, byteCount += size;\n  }\n  return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n  let len = Math.min(str.length, str2.length), b = 0;\n  for (let i = 0; i < len; ) {\n    let aPoint = str.codePointAt(i), bPoint = str2.codePointAt(i);\n    if (aPoint !== bPoint)\n      return b;\n    let size = utf8charSize(aPoint);\n    b += size, i += size === 4 ? 2 : 1;\n  }\n  return b;\n}\nfunction commonSuffix(str, str2, prefix = 0) {\n  let len = Math.min(str.length, str2.length) - prefix, b = 0;\n  for (let i = 0; i < len; ) {\n    let aPoint = str.codePointAt(str.length - 1 - i), bPoint = str2.codePointAt(str2.length - 1 - i);\n    if (aPoint !== bPoint)\n      return b;\n    let size = utf8charSize(aPoint);\n    b += size, i += size === 4 ? 2 : 1;\n  }\n  return b;\n}\nclass IncrementalModel {\n  constructor(meta) {\n    this.meta = meta;\n  }\n  wrap(data) {\n    return this.wrapWithMeta(data, this.meta, this.meta);\n  }\n  wrapWithMeta(data, startMeta, endMeta = this.meta) {\n    return { data, startMeta, endMeta };\n  }\n  asObject(value) {\n    if (!value.content) {\n      let fields = {};\n      for (let [key, val] of Object.entries(value.data))\n        fields[key] = this.wrapWithMeta(val, value.startMeta);\n      value.content = { type: \"object\", fields };\n    }\n    return value.content;\n  }\n  asArray(value) {\n    if (!value.content) {\n      let elements = value.data.map(\n        (item) => this.wrapWithMeta(item, value.startMeta)\n      ), metas = elements.map(() => this.meta);\n      value.content = { type: \"array\", elements, metas };\n    }\n    return value.content;\n  }\n  asString(value) {\n    if (!value.content) {\n      let str = value.data, part = {\n        value: str,\n        utf8size: utf8stringSize(str),\n        uses: [],\n        startMeta: value.startMeta,\n        endMeta: value.endMeta\n      };\n      value.content = this.stringFromParts([part]);\n    }\n    return value.content;\n  }\n  stringFromParts(parts) {\n    let str = {\n      type: \"string\",\n      parts\n    };\n    for (let part of parts)\n      part.uses.push(str);\n    return str;\n  }\n  objectGetKeys(value) {\n    return value.content ? Object.keys(value.content.fields) : Object.keys(value.data);\n  }\n  objectGetField(value, key) {\n    return this.asObject(value).fields[key];\n  }\n  arrayGetElement(value, idx) {\n    return this.asArray(value).elements[idx];\n  }\n  finalize(content) {\n    return this.updateEndMeta(content), { content, startMeta: this.meta, endMeta: this.meta };\n  }\n  markChanged(value) {\n    return this.wrap(unwrap(value));\n  }\n  updateEndMeta(content) {\n    if (content.type == \"string\")\n      for (let part of content.parts)\n        part.endMeta = this.meta;\n    else if (content.type === \"array\")\n      for (let val of content.elements)\n        val.content && val.endMeta !== this.meta && this.updateEndMeta(val.content), val.endMeta = this.meta;\n    else\n      for (let val of Object.values(content.fields))\n        val.content && val.endMeta !== this.meta && this.updateEndMeta(val.content), val.endMeta = this.meta;\n  }\n  copyString(value) {\n    if (value) {\n      let other = this.asString(value);\n      return this.stringFromParts(other.parts.slice());\n    } else\n      return {\n        type: \"string\",\n        parts: []\n      };\n  }\n  copyObject(value) {\n    let obj = {\n      type: \"object\",\n      fields: {}\n    };\n    if (value) {\n      let other = this.asObject(value);\n      Object.assign(obj.fields, other.fields);\n    }\n    return obj;\n  }\n  copyArray(value) {\n    let arr = value ? this.asArray(value) : null, elements = arr ? arr.elements : [], metas = arr ? arr.metas : [];\n    return {\n      type: \"array\",\n      elements,\n      metas\n    };\n  }\n  objectSetField(target, key, value) {\n    target.fields[key] = value;\n  }\n  objectDeleteField(target, key) {\n    delete target.fields[key];\n  }\n  arrayAppendValue(target, value) {\n    target.elements.push(value), target.metas.push(this.meta);\n  }\n  arrayAppendSlice(target, source, left, right) {\n    let arr = this.asArray(source), samePosition = arr.elements.length === left;\n    if (target.elements.push(...arr.elements.slice(left, right)), samePosition)\n      target.metas.push(...arr.metas.slice(left, right));\n    else\n      for (let i = left; i < right; i++)\n        target.metas.push(this.meta);\n  }\n  stringAppendValue(target, value) {\n    let str = this.asString(value);\n    for (let part of str.parts)\n      this.stringAppendPart(target, part);\n  }\n  stringAppendPart(target, part) {\n    target.parts.push(part), part.uses.push(target);\n  }\n  resolveStringPart(str, from, len) {\n    if (len === 0)\n      return from;\n    for (let i = from; i < str.parts.length; i++) {\n      let part = str.parts[i];\n      if (len === part.utf8size)\n        return i + 1;\n      if (len < part.utf8size)\n        return this.splitString(part, len), i + 1;\n      len -= part.utf8size;\n    }\n    throw new Error(\"splitting string out of bounds\");\n  }\n  splitString(part, idx) {\n    let leftValue, rightValue, leftSize = idx, rightSize = part.utf8size - leftSize;\n    if (part.utf8size !== part.value.length) {\n      let byteCount = 0;\n      for (idx = 0; byteCount < leftSize; idx++) {\n        let code = part.value.codePointAt(idx), size = utf8charSize(code);\n        size === 4 && idx++, byteCount += size;\n      }\n    }\n    leftValue = part.value.slice(0, idx), rightValue = part.value.slice(idx);\n    let newPart = {\n      value: rightValue,\n      utf8size: rightSize,\n      uses: part.uses.slice(),\n      startMeta: part.startMeta,\n      endMeta: part.endMeta\n    };\n    part.value = leftValue, part.utf8size = leftSize;\n    for (let use of part.uses) {\n      let ndx = use.parts.indexOf(part);\n      if (ndx === -1)\n        throw new Error(\"bug: mismatch between string parts and use.\");\n      use.parts.splice(ndx + 1, 0, newPart);\n    }\n  }\n  stringAppendSlice(target, source, left, right) {\n    let str = this.asString(source), firstPart = this.resolveStringPart(str, 0, left), lastPart = this.resolveStringPart(str, firstPart, right - left);\n    for (let i = firstPart; i < lastPart; i++) {\n      let part = str.parts[i];\n      this.stringAppendPart(target, part);\n    }\n  }\n}\nfunction wrap(data, meta) {\n  return { data, startMeta: meta, endMeta: meta };\n}\nfunction unwrap(value) {\n  if (typeof value.data < \"u\")\n    return value.data;\n  let result, content = value.content;\n  switch (content.type) {\n    case \"string\":\n      result = content.parts.map((part) => part.value).join(\"\");\n      break;\n    case \"array\":\n      result = content.elements.map((val) => unwrap(val));\n      break;\n    case \"object\": {\n      result = {};\n      for (let [key, val] of Object.entries(content.fields))\n        result[key] = unwrap(val);\n    }\n  }\n  return value.data = result, result;\n}\nfunction getType(value) {\n  return value.content ? value.content.type : Array.isArray(value.data) ? \"array\" : value.data === null ? \"null\" : typeof value.data;\n}\nfunction rebaseValue(left, right) {\n  let leftType = getType(left), rightType = getType(right);\n  if (leftType !== rightType)\n    return right;\n  let leftModel = new IncrementalModel(left.endMeta), rightModel = new IncrementalModel(right.endMeta);\n  switch (leftType) {\n    case \"object\": {\n      let leftObj = leftModel.asObject(left), rightObj = rightModel.asObject(right), identicalFieldCount = 0, leftFieldCount = Object.keys(leftObj.fields).length, rightFieldCount = Object.keys(rightObj.fields).length;\n      for (let [key, rightVal] of Object.entries(rightObj.fields)) {\n        let leftVal = leftObj.fields[key];\n        leftVal && (rightObj.fields[key] = rebaseValue(leftVal, rightVal), rightObj.fields[key] === leftVal && identicalFieldCount++);\n      }\n      return leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount ? left : right;\n    }\n    case \"array\": {\n      let leftArr = leftModel.asArray(left), rightArr = rightModel.asArray(right);\n      if (leftArr.elements.length !== rightArr.elements.length)\n        break;\n      let numRebased = 0;\n      for (let i = 0; i < rightArr.elements.length; i++)\n        rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]), rightArr.elements[i] !== leftArr.elements[i] && numRebased++;\n      return numRebased === 0 ? left : right;\n    }\n    case \"null\":\n    case \"boolean\":\n    case \"number\": {\n      if (unwrap(left) === unwrap(right))\n        return left;\n      break;\n    }\n    case \"string\": {\n      let leftRaw = unwrap(left), rightRaw = unwrap(right);\n      if (leftRaw === rightRaw)\n        return left;\n      let result = rightModel.copyString(null), prefix = commonPrefix(leftRaw, rightRaw), suffix = commonSuffix(leftRaw, rightRaw, prefix), rightLen = utf8stringSize(rightRaw), leftLen = utf8stringSize(leftRaw);\n      0 < prefix && rightModel.stringAppendSlice(result, left, 0, prefix), prefix < rightLen - suffix && rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix), leftLen - suffix < leftLen && rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n      let value = rightModel.finalize(result);\n      if (unwrap(value) !== rightRaw)\n        throw new Error(\"incorrect string rebase\");\n      return value;\n    }\n  }\n  return right;\n}\nfunction applyPatch$1(left, patch, startMeta) {\n  let model = new IncrementalModel(startMeta);\n  return new Patcher(model, left, patch).process();\n}\nvar incrementalPatcher = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  applyPatch: applyPatch$1,\n  getType,\n  rebaseValue,\n  unwrap,\n  wrap\n});\nclass SimpleModel {\n  wrap(data) {\n    return data;\n  }\n  finalize(b) {\n    return Array.isArray(b) ? b : b.data;\n  }\n  markChanged(value) {\n    return value;\n  }\n  objectGetKeys(value) {\n    return Object.keys(value);\n  }\n  objectGetField(value, key) {\n    return value[key];\n  }\n  arrayGetElement(value, idx) {\n    return value[idx];\n  }\n  copyObject(value) {\n    let res = {\n      type: \"object\",\n      data: {}\n    };\n    if (value !== null)\n      for (let [key, val] of Object.entries(value))\n        res.data[key] = val;\n    return res;\n  }\n  copyArray(value) {\n    return value === null ? [] : value.slice();\n  }\n  copyString(value) {\n    return {\n      type: \"string\",\n      data: value === null ? \"\" : value\n    };\n  }\n  objectSetField(target, key, value) {\n    target.data[key] = value;\n  }\n  objectDeleteField(target, key) {\n    delete target.data[key];\n  }\n  arrayAppendValue(target, value) {\n    target.push(value);\n  }\n  arrayAppendSlice(target, source, left, right) {\n    target.push(...source.slice(left, right));\n  }\n  stringAppendSlice(target, source, left, right) {\n    const sourceString = source, leftPos = utf8resolveIndex(sourceString, left), rightPos = utf8resolveIndex(sourceString, right, leftPos);\n    target.data += sourceString.slice(leftPos, rightPos);\n  }\n  stringAppendValue(target, value) {\n    target.data += value;\n  }\n}\nfunction applyPatch(left, patch) {\n  let root = left;\n  return new Patcher(new SimpleModel(), root, patch).process();\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCLDJCQUEyQixrQkFBa0IsR0FBRyw0QkFBNEI7QUFDOUg7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xELGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21lbmRvemEvZGlzdC9pbmRleC5qcz8yZTVkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE9QUyA9IFtcbiAgXCJWYWx1ZVwiLFxuICBcIkNvcHlcIixcbiAgXCJCbGFua1wiLFxuICBcIlJldHVybkludG9BcnJheVwiLFxuICBcIlJldHVybkludG9PYmplY3RcIixcbiAgXCJSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVwiLFxuICBcIlB1c2hGaWVsZFwiLFxuICBcIlB1c2hFbGVtZW50XCIsXG4gIFwiUHVzaFBhcmVudFwiLFxuICBcIlBvcFwiLFxuICBcIlB1c2hGaWVsZENvcHlcIixcbiAgXCJQdXNoRmllbGRCbGFua1wiLFxuICBcIlB1c2hFbGVtZW50Q29weVwiLFxuICBcIlB1c2hFbGVtZW50QmxhbmtcIixcbiAgXCJSZXR1cm5JbnRvT2JqZWN0UG9wXCIsXG4gIFwiUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3BcIixcbiAgXCJSZXR1cm5JbnRvQXJyYXlQb3BcIixcbiAgXCJPYmplY3RTZXRGaWVsZFZhbHVlXCIsXG4gIFwiT2JqZWN0Q29weUZpZWxkXCIsXG4gIFwiT2JqZWN0RGVsZXRlRmllbGRcIixcbiAgXCJBcnJheUFwcGVuZFZhbHVlXCIsXG4gIFwiQXJyYXlBcHBlbmRTbGljZVwiLFxuICBcIlN0cmluZ0FwcGVuZFN0cmluZ1wiLFxuICBcIlN0cmluZ0FwcGVuZFNsaWNlXCJcbl07XG5jbGFzcyBQYXRjaGVyIHtcbiAgY29uc3RydWN0b3IobW9kZWwsIHJvb3QsIHBhdGNoKSB7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsLCB0aGlzLnJvb3QgPSByb290LCB0aGlzLnBhdGNoID0gcGF0Y2gsIHRoaXMuaSA9IDAsIHRoaXMuaW5wdXRTdGFjayA9IFtdLCB0aGlzLm91dHB1dFN0YWNrID0gW107XG4gIH1cbiAgcmVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRjaFt0aGlzLmkrK107XG4gIH1cbiAgcHJvY2VzcygpIHtcbiAgICBmb3IgKHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHRoaXMucm9vdCB9KSwgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IHRoaXMucm9vdCB9KTsgdGhpcy5pIDwgdGhpcy5wYXRjaC5sZW5ndGg7ICkge1xuICAgICAgbGV0IG9wY29kZSA9IHRoaXMucmVhZCgpLCBvcCA9IE9QU1tvcGNvZGVdO1xuICAgICAgaWYgKCFvcClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wY29kZTogJHtvcGNvZGV9YCk7XG4gICAgICBsZXQgcHJvY2Vzc29yID0gYHByb2Nlc3Mke29wfWA7XG4gICAgICB0aGlzW3Byb2Nlc3Nvcl0uYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICB9XG4gIGlucHV0RW50cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRTdGFja1t0aGlzLmlucHV0U3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgaW5wdXRLZXkoZW50cnksIGlkeCkge1xuICAgIHJldHVybiBlbnRyeS5rZXlzIHx8IChlbnRyeS5rZXlzID0gdGhpcy5tb2RlbC5vYmplY3RHZXRLZXlzKGVudHJ5LnZhbHVlKS5zb3J0KCkpLCBlbnRyeS5rZXlzW2lkeF07XG4gIH1cbiAgb3V0cHV0RW50cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0U3RhY2tbdGhpcy5vdXRwdXRTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuICBvdXRwdXRBcnJheSgpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWUgfHwgKGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlBcnJheShlbnRyeS52YWx1ZSkpLCBlbnRyeS53cml0ZVZhbHVlO1xuICB9XG4gIG91dHB1dE9iamVjdCgpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWUgfHwgKGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlPYmplY3QoZW50cnkudmFsdWUpKSwgZW50cnkud3JpdGVWYWx1ZTtcbiAgfVxuICBvdXRwdXRTdHJpbmcoKSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlIHx8IChlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5U3RyaW5nKGVudHJ5LnZhbHVlKSksIGVudHJ5LndyaXRlVmFsdWU7XG4gIH1cbiAgZmluYWxpemVPdXRwdXQoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZSA/IHRoaXMubW9kZWwuZmluYWxpemUoZW50cnkud3JpdGVWYWx1ZSkgOiBlbnRyeS52YWx1ZTtcbiAgfVxuICAvLyBQcm9jZXNzb3JzOlxuICBwcm9jZXNzVmFsdWUoKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZSB9KTtcbiAgfVxuICBwcm9jZXNzQ29weSgpIHtcbiAgICBsZXQgaW5wdXQgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogaW5wdXQudmFsdWUgfSk7XG4gIH1cbiAgcHJvY2Vzc0JsYW5rKCkge1xuICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiBudWxsIH0pO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvQXJyYXkoKSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKSwgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSksIGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kVmFsdWUoYXJyLCByZXN1bHQpO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCkge1xuICAgIGxldCBrZXkgPSB0aGlzLnJlYWQoKSwgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpLCByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICByZXN1bHQgPSB0aGlzLm1vZGVsLm1hcmtDaGFuZ2VkKHJlc3VsdCk7XG4gICAgbGV0IG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgdGhpcy5tb2RlbC5vYmplY3RTZXRGaWVsZChvYmosIGtleSwgcmVzdWx0KTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKSB7XG4gICAgbGV0IGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCksIGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKSwgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSksIG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgdGhpcy5tb2RlbC5vYmplY3RTZXRGaWVsZChvYmosIGlucHV0LmtleSwgcmVzdWx0KTtcbiAgfVxuICBwcm9jZXNzUHVzaEZpZWxkKCkge1xuICAgIGxldCBpZHggPSB0aGlzLnJlYWQoKSwgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKSwga2V5ID0gdGhpcy5pbnB1dEtleShlbnRyeSwgaWR4KSwgdmFsdWUgPSB0aGlzLm1vZGVsLm9iamVjdEdldEZpZWxkKGVudHJ5LnZhbHVlLCBrZXkpO1xuICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWUsIGtleSB9KTtcbiAgfVxuICBwcm9jZXNzUHVzaEVsZW1lbnQoKSB7XG4gICAgbGV0IGlkeCA9IHRoaXMucmVhZCgpLCBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpLCB2YWx1ZSA9IHRoaXMubW9kZWwuYXJyYXlHZXRFbGVtZW50KGVudHJ5LnZhbHVlLCBpZHgpO1xuICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWUgfSk7XG4gIH1cbiAgcHJvY2Vzc1BvcCgpIHtcbiAgICB0aGlzLmlucHV0U3RhY2sucG9wKCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hGaWVsZENvcHkoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCksIHRoaXMucHJvY2Vzc0NvcHkoKTtcbiAgfVxuICBwcm9jZXNzUHVzaEZpZWxkQmxhbmsoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCksIHRoaXMucHJvY2Vzc0JsYW5rKCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hFbGVtZW50Q29weSgpIHtcbiAgICB0aGlzLnByb2Nlc3NQdXNoRWxlbWVudCgpLCB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hFbGVtZW50QmxhbmsoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKSwgdGhpcy5wcm9jZXNzQmxhbmsoKTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b09iamVjdFBvcCgpIHtcbiAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCksIHRoaXMucHJvY2Vzc1BvcCgpO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCgpIHtcbiAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpLCB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b0FycmF5UG9wKCkge1xuICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9BcnJheSgpLCB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgfVxuICBwcm9jZXNzT2JqZWN0U2V0RmllbGRWYWx1ZSgpIHtcbiAgICB0aGlzLnByb2Nlc3NWYWx1ZSgpLCB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCk7XG4gIH1cbiAgcHJvY2Vzc09iamVjdENvcHlGaWVsZCgpIHtcbiAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKSwgdGhpcy5wcm9jZXNzQ29weSgpLCB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpLCB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgfVxuICBwcm9jZXNzT2JqZWN0RGVsZXRlRmllbGQoKSB7XG4gICAgbGV0IGlkeCA9IHRoaXMucmVhZCgpLCBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpLCBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpLCBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgIHRoaXMubW9kZWwub2JqZWN0RGVsZXRlRmllbGQob2JqLCBrZXkpO1xuICB9XG4gIHByb2Nlc3NBcnJheUFwcGVuZFZhbHVlKCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSksIGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kVmFsdWUoYXJyLCB2YWx1ZSk7XG4gIH1cbiAgcHJvY2Vzc0FycmF5QXBwZW5kU2xpY2UoKSB7XG4gICAgbGV0IGxlZnQgPSB0aGlzLnJlYWQoKSwgcmlnaHQgPSB0aGlzLnJlYWQoKSwgc3RyID0gdGhpcy5vdXRwdXRBcnJheSgpLCB2YWwgPSB0aGlzLmlucHV0RW50cnkoKS52YWx1ZTtcbiAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kU2xpY2Uoc3RyLCB2YWwsIGxlZnQsIHJpZ2h0KTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nQXBwZW5kU3RyaW5nKCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSksIHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XG4gICAgdGhpcy5tb2RlbC5zdHJpbmdBcHBlbmRWYWx1ZShzdHIsIHZhbHVlKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nQXBwZW5kU2xpY2UoKSB7XG4gICAgbGV0IGxlZnQgPSB0aGlzLnJlYWQoKSwgcmlnaHQgPSB0aGlzLnJlYWQoKSwgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKSwgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgdGhpcy5tb2RlbC5zdHJpbmdBcHBlbmRTbGljZShzdHIsIHZhbCwgbGVmdCwgcmlnaHQpO1xuICB9XG59XG5mdW5jdGlvbiB1dGY4Y2hhclNpemUoY29kZSkge1xuICByZXR1cm4gY29kZSA+PiAxNiA/IDQgOiBjb2RlID4+IDExID8gMyA6IGNvZGUgPj4gNyA/IDIgOiAxO1xufVxuZnVuY3Rpb24gdXRmOHN0cmluZ1NpemUoc3RyKSB7XG4gIGxldCBiID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY29kZSA9IHN0ci5jb2RlUG9pbnRBdChpKSwgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICBzaXplID09IDQgJiYgaSsrLCBiICs9IHNpemU7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiB1dGY4cmVzb2x2ZUluZGV4KHN0ciwgaWR4LCBzdGFydCA9IDApIHtcbiAgbGV0IGJ5dGVDb3VudCA9IHN0YXJ0LCB1Y3NJZHggPSAwO1xuICBmb3IgKHVjc0lkeCA9IHN0YXJ0OyBieXRlQ291bnQgPCBpZHg7IHVjc0lkeCsrKSB7XG4gICAgbGV0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQodWNzSWR4KSwgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICBzaXplID09PSA0ICYmIHVjc0lkeCsrLCBieXRlQ291bnQgKz0gc2l6ZTtcbiAgfVxuICByZXR1cm4gdWNzSWR4O1xufVxuZnVuY3Rpb24gY29tbW9uUHJlZml4KHN0ciwgc3RyMikge1xuICBsZXQgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgc3RyMi5sZW5ndGgpLCBiID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICkge1xuICAgIGxldCBhUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoaSksIGJQb2ludCA9IHN0cjIuY29kZVBvaW50QXQoaSk7XG4gICAgaWYgKGFQb2ludCAhPT0gYlBvaW50KVxuICAgICAgcmV0dXJuIGI7XG4gICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcbiAgICBiICs9IHNpemUsIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xuICB9XG4gIHJldHVybiBiO1xufVxuZnVuY3Rpb24gY29tbW9uU3VmZml4KHN0ciwgc3RyMiwgcHJlZml4ID0gMCkge1xuICBsZXQgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgc3RyMi5sZW5ndGgpIC0gcHJlZml4LCBiID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICkge1xuICAgIGxldCBhUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoc3RyLmxlbmd0aCAtIDEgLSBpKSwgYlBvaW50ID0gc3RyMi5jb2RlUG9pbnRBdChzdHIyLmxlbmd0aCAtIDEgLSBpKTtcbiAgICBpZiAoYVBvaW50ICE9PSBiUG9pbnQpXG4gICAgICByZXR1cm4gYjtcbiAgICBsZXQgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShhUG9pbnQpO1xuICAgIGIgKz0gc2l6ZSwgaSArPSBzaXplID09PSA0ID8gMiA6IDE7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG5jbGFzcyBJbmNyZW1lbnRhbE1vZGVsIHtcbiAgY29uc3RydWN0b3IobWV0YSkge1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgd3JhcChkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFdpdGhNZXRhKGRhdGEsIHRoaXMubWV0YSwgdGhpcy5tZXRhKTtcbiAgfVxuICB3cmFwV2l0aE1ldGEoZGF0YSwgc3RhcnRNZXRhLCBlbmRNZXRhID0gdGhpcy5tZXRhKSB7XG4gICAgcmV0dXJuIHsgZGF0YSwgc3RhcnRNZXRhLCBlbmRNZXRhIH07XG4gIH1cbiAgYXNPYmplY3QodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLmNvbnRlbnQpIHtcbiAgICAgIGxldCBmaWVsZHMgPSB7fTtcbiAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUuZGF0YSkpXG4gICAgICAgIGZpZWxkc1trZXldID0gdGhpcy53cmFwV2l0aE1ldGEodmFsLCB2YWx1ZS5zdGFydE1ldGEpO1xuICAgICAgdmFsdWUuY29udGVudCA9IHsgdHlwZTogXCJvYmplY3RcIiwgZmllbGRzIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICB9XG4gIGFzQXJyYXkodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLmNvbnRlbnQpIHtcbiAgICAgIGxldCBlbGVtZW50cyA9IHZhbHVlLmRhdGEubWFwKFxuICAgICAgICAoaXRlbSkgPT4gdGhpcy53cmFwV2l0aE1ldGEoaXRlbSwgdmFsdWUuc3RhcnRNZXRhKVxuICAgICAgKSwgbWV0YXMgPSBlbGVtZW50cy5tYXAoKCkgPT4gdGhpcy5tZXRhKTtcbiAgICAgIHZhbHVlLmNvbnRlbnQgPSB7IHR5cGU6IFwiYXJyYXlcIiwgZWxlbWVudHMsIG1ldGFzIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICB9XG4gIGFzU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICBsZXQgc3RyID0gdmFsdWUuZGF0YSwgcGFydCA9IHtcbiAgICAgICAgdmFsdWU6IHN0cixcbiAgICAgICAgdXRmOHNpemU6IHV0ZjhzdHJpbmdTaXplKHN0ciksXG4gICAgICAgIHVzZXM6IFtdLFxuICAgICAgICBzdGFydE1ldGE6IHZhbHVlLnN0YXJ0TWV0YSxcbiAgICAgICAgZW5kTWV0YTogdmFsdWUuZW5kTWV0YVxuICAgICAgfTtcbiAgICAgIHZhbHVlLmNvbnRlbnQgPSB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhbcGFydF0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgfVxuICBzdHJpbmdGcm9tUGFydHMocGFydHMpIHtcbiAgICBsZXQgc3RyID0ge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHBhcnRzXG4gICAgfTtcbiAgICBmb3IgKGxldCBwYXJ0IG9mIHBhcnRzKVxuICAgICAgcGFydC51c2VzLnB1c2goc3RyKTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIG9iamVjdEdldEtleXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY29udGVudCA/IE9iamVjdC5rZXlzKHZhbHVlLmNvbnRlbnQuZmllbGRzKSA6IE9iamVjdC5rZXlzKHZhbHVlLmRhdGEpO1xuICB9XG4gIG9iamVjdEdldEZpZWxkKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5hc09iamVjdCh2YWx1ZSkuZmllbGRzW2tleV07XG4gIH1cbiAgYXJyYXlHZXRFbGVtZW50KHZhbHVlLCBpZHgpIHtcbiAgICByZXR1cm4gdGhpcy5hc0FycmF5KHZhbHVlKS5lbGVtZW50c1tpZHhdO1xuICB9XG4gIGZpbmFsaXplKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVFbmRNZXRhKGNvbnRlbnQpLCB7IGNvbnRlbnQsIHN0YXJ0TWV0YTogdGhpcy5tZXRhLCBlbmRNZXRhOiB0aGlzLm1ldGEgfTtcbiAgfVxuICBtYXJrQ2hhbmdlZCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLndyYXAodW53cmFwKHZhbHVlKSk7XG4gIH1cbiAgdXBkYXRlRW5kTWV0YShjb250ZW50KSB7XG4gICAgaWYgKGNvbnRlbnQudHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgZm9yIChsZXQgcGFydCBvZiBjb250ZW50LnBhcnRzKVxuICAgICAgICBwYXJ0LmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgZWxzZSBpZiAoY29udGVudC50eXBlID09PSBcImFycmF5XCIpXG4gICAgICBmb3IgKGxldCB2YWwgb2YgY29udGVudC5lbGVtZW50cylcbiAgICAgICAgdmFsLmNvbnRlbnQgJiYgdmFsLmVuZE1ldGEgIT09IHRoaXMubWV0YSAmJiB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpLCB2YWwuZW5kTWV0YSA9IHRoaXMubWV0YTtcbiAgICBlbHNlXG4gICAgICBmb3IgKGxldCB2YWwgb2YgT2JqZWN0LnZhbHVlcyhjb250ZW50LmZpZWxkcykpXG4gICAgICAgIHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEgJiYgdGhpcy51cGRhdGVFbmRNZXRhKHZhbC5jb250ZW50KSwgdmFsLmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gIH1cbiAgY29weVN0cmluZyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgbGV0IG90aGVyID0gdGhpcy5hc1N0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmdGcm9tUGFydHMob3RoZXIucGFydHMuc2xpY2UoKSk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBwYXJ0czogW11cbiAgICAgIH07XG4gIH1cbiAgY29weU9iamVjdCh2YWx1ZSkge1xuICAgIGxldCBvYmogPSB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgZmllbGRzOiB7fVxuICAgIH07XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBsZXQgb3RoZXIgPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcbiAgICAgIE9iamVjdC5hc3NpZ24ob2JqLmZpZWxkcywgb3RoZXIuZmllbGRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBjb3B5QXJyYXkodmFsdWUpIHtcbiAgICBsZXQgYXJyID0gdmFsdWUgPyB0aGlzLmFzQXJyYXkodmFsdWUpIDogbnVsbCwgZWxlbWVudHMgPSBhcnIgPyBhcnIuZWxlbWVudHMgOiBbXSwgbWV0YXMgPSBhcnIgPyBhcnIubWV0YXMgOiBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBtZXRhc1xuICAgIH07XG4gIH1cbiAgb2JqZWN0U2V0RmllbGQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgdGFyZ2V0LmZpZWxkc1trZXldID0gdmFsdWU7XG4gIH1cbiAgb2JqZWN0RGVsZXRlRmllbGQodGFyZ2V0LCBrZXkpIHtcbiAgICBkZWxldGUgdGFyZ2V0LmZpZWxkc1trZXldO1xuICB9XG4gIGFycmF5QXBwZW5kVmFsdWUodGFyZ2V0LCB2YWx1ZSkge1xuICAgIHRhcmdldC5lbGVtZW50cy5wdXNoKHZhbHVlKSwgdGFyZ2V0Lm1ldGFzLnB1c2godGhpcy5tZXRhKTtcbiAgfVxuICBhcnJheUFwcGVuZFNsaWNlKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgIGxldCBhcnIgPSB0aGlzLmFzQXJyYXkoc291cmNlKSwgc2FtZVBvc2l0aW9uID0gYXJyLmVsZW1lbnRzLmxlbmd0aCA9PT0gbGVmdDtcbiAgICBpZiAodGFyZ2V0LmVsZW1lbnRzLnB1c2goLi4uYXJyLmVsZW1lbnRzLnNsaWNlKGxlZnQsIHJpZ2h0KSksIHNhbWVQb3NpdGlvbilcbiAgICAgIHRhcmdldC5tZXRhcy5wdXNoKC4uLmFyci5tZXRhcy5zbGljZShsZWZ0LCByaWdodCkpO1xuICAgIGVsc2VcbiAgICAgIGZvciAobGV0IGkgPSBsZWZ0OyBpIDwgcmlnaHQ7IGkrKylcbiAgICAgICAgdGFyZ2V0Lm1ldGFzLnB1c2godGhpcy5tZXRhKTtcbiAgfVxuICBzdHJpbmdBcHBlbmRWYWx1ZSh0YXJnZXQsIHZhbHVlKSB7XG4gICAgbGV0IHN0ciA9IHRoaXMuYXNTdHJpbmcodmFsdWUpO1xuICAgIGZvciAobGV0IHBhcnQgb2Ygc3RyLnBhcnRzKVxuICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XG4gIH1cbiAgc3RyaW5nQXBwZW5kUGFydCh0YXJnZXQsIHBhcnQpIHtcbiAgICB0YXJnZXQucGFydHMucHVzaChwYXJ0KSwgcGFydC51c2VzLnB1c2godGFyZ2V0KTtcbiAgfVxuICByZXNvbHZlU3RyaW5nUGFydChzdHIsIGZyb20sIGxlbikge1xuICAgIGlmIChsZW4gPT09IDApXG4gICAgICByZXR1cm4gZnJvbTtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHN0ci5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICBpZiAobGVuID09PSBwYXJ0LnV0ZjhzaXplKVxuICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICBpZiAobGVuIDwgcGFydC51dGY4c2l6ZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRTdHJpbmcocGFydCwgbGVuKSwgaSArIDE7XG4gICAgICBsZW4gLT0gcGFydC51dGY4c2l6ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3BsaXR0aW5nIHN0cmluZyBvdXQgb2YgYm91bmRzXCIpO1xuICB9XG4gIHNwbGl0U3RyaW5nKHBhcnQsIGlkeCkge1xuICAgIGxldCBsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUsIGxlZnRTaXplID0gaWR4LCByaWdodFNpemUgPSBwYXJ0LnV0ZjhzaXplIC0gbGVmdFNpemU7XG4gICAgaWYgKHBhcnQudXRmOHNpemUgIT09IHBhcnQudmFsdWUubGVuZ3RoKSB7XG4gICAgICBsZXQgYnl0ZUNvdW50ID0gMDtcbiAgICAgIGZvciAoaWR4ID0gMDsgYnl0ZUNvdW50IDwgbGVmdFNpemU7IGlkeCsrKSB7XG4gICAgICAgIGxldCBjb2RlID0gcGFydC52YWx1ZS5jb2RlUG9pbnRBdChpZHgpLCBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xuICAgICAgICBzaXplID09PSA0ICYmIGlkeCsrLCBieXRlQ291bnQgKz0gc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGVmdFZhbHVlID0gcGFydC52YWx1ZS5zbGljZSgwLCBpZHgpLCByaWdodFZhbHVlID0gcGFydC52YWx1ZS5zbGljZShpZHgpO1xuICAgIGxldCBuZXdQYXJ0ID0ge1xuICAgICAgdmFsdWU6IHJpZ2h0VmFsdWUsXG4gICAgICB1dGY4c2l6ZTogcmlnaHRTaXplLFxuICAgICAgdXNlczogcGFydC51c2VzLnNsaWNlKCksXG4gICAgICBzdGFydE1ldGE6IHBhcnQuc3RhcnRNZXRhLFxuICAgICAgZW5kTWV0YTogcGFydC5lbmRNZXRhXG4gICAgfTtcbiAgICBwYXJ0LnZhbHVlID0gbGVmdFZhbHVlLCBwYXJ0LnV0ZjhzaXplID0gbGVmdFNpemU7XG4gICAgZm9yIChsZXQgdXNlIG9mIHBhcnQudXNlcykge1xuICAgICAgbGV0IG5keCA9IHVzZS5wYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgaWYgKG5keCA9PT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZzogbWlzbWF0Y2ggYmV0d2VlbiBzdHJpbmcgcGFydHMgYW5kIHVzZS5cIik7XG4gICAgICB1c2UucGFydHMuc3BsaWNlKG5keCArIDEsIDAsIG5ld1BhcnQpO1xuICAgIH1cbiAgfVxuICBzdHJpbmdBcHBlbmRTbGljZSh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgc3RyID0gdGhpcy5hc1N0cmluZyhzb3VyY2UpLCBmaXJzdFBhcnQgPSB0aGlzLnJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgMCwgbGVmdCksIGxhc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIGZpcnN0UGFydCwgcmlnaHQgLSBsZWZ0KTtcbiAgICBmb3IgKGxldCBpID0gZmlyc3RQYXJ0OyBpIDwgbGFzdFBhcnQ7IGkrKykge1xuICAgICAgbGV0IHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICB0aGlzLnN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXAoZGF0YSwgbWV0YSkge1xuICByZXR1cm4geyBkYXRhLCBzdGFydE1ldGE6IG1ldGEsIGVuZE1ldGE6IG1ldGEgfTtcbn1cbmZ1bmN0aW9uIHVud3JhcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlLmRhdGEgPCBcInVcIilcbiAgICByZXR1cm4gdmFsdWUuZGF0YTtcbiAgbGV0IHJlc3VsdCwgY29udGVudCA9IHZhbHVlLmNvbnRlbnQ7XG4gIHN3aXRjaCAoY29udGVudC50eXBlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmVzdWx0ID0gY29udGVudC5wYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQudmFsdWUpLmpvaW4oXCJcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJlc3VsdCA9IGNvbnRlbnQuZWxlbWVudHMubWFwKCh2YWwpID0+IHVud3JhcCh2YWwpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGNvbnRlbnQuZmllbGRzKSlcbiAgICAgICAgcmVzdWx0W2tleV0gPSB1bndyYXAodmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlLmRhdGEgPSByZXN1bHQsIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLmNvbnRlbnQgPyB2YWx1ZS5jb250ZW50LnR5cGUgOiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpID8gXCJhcnJheVwiIDogdmFsdWUuZGF0YSA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHZhbHVlLmRhdGE7XG59XG5mdW5jdGlvbiByZWJhc2VWYWx1ZShsZWZ0LCByaWdodCkge1xuICBsZXQgbGVmdFR5cGUgPSBnZXRUeXBlKGxlZnQpLCByaWdodFR5cGUgPSBnZXRUeXBlKHJpZ2h0KTtcbiAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpXG4gICAgcmV0dXJuIHJpZ2h0O1xuICBsZXQgbGVmdE1vZGVsID0gbmV3IEluY3JlbWVudGFsTW9kZWwobGVmdC5lbmRNZXRhKSwgcmlnaHRNb2RlbCA9IG5ldyBJbmNyZW1lbnRhbE1vZGVsKHJpZ2h0LmVuZE1ldGEpO1xuICBzd2l0Y2ggKGxlZnRUeXBlKSB7XG4gICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICBsZXQgbGVmdE9iaiA9IGxlZnRNb2RlbC5hc09iamVjdChsZWZ0KSwgcmlnaHRPYmogPSByaWdodE1vZGVsLmFzT2JqZWN0KHJpZ2h0KSwgaWRlbnRpY2FsRmllbGRDb3VudCA9IDAsIGxlZnRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMobGVmdE9iai5maWVsZHMpLmxlbmd0aCwgcmlnaHRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMocmlnaHRPYmouZmllbGRzKS5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBba2V5LCByaWdodFZhbF0gb2YgT2JqZWN0LmVudHJpZXMocmlnaHRPYmouZmllbGRzKSkge1xuICAgICAgICBsZXQgbGVmdFZhbCA9IGxlZnRPYmouZmllbGRzW2tleV07XG4gICAgICAgIGxlZnRWYWwgJiYgKHJpZ2h0T2JqLmZpZWxkc1trZXldID0gcmViYXNlVmFsdWUobGVmdFZhbCwgcmlnaHRWYWwpLCByaWdodE9iai5maWVsZHNba2V5XSA9PT0gbGVmdFZhbCAmJiBpZGVudGljYWxGaWVsZENvdW50KyspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnRGaWVsZENvdW50ID09PSByaWdodEZpZWxkQ291bnQgJiYgbGVmdEZpZWxkQ291bnQgPT09IGlkZW50aWNhbEZpZWxkQ291bnQgPyBsZWZ0IDogcmlnaHQ7XG4gICAgfVxuICAgIGNhc2UgXCJhcnJheVwiOiB7XG4gICAgICBsZXQgbGVmdEFyciA9IGxlZnRNb2RlbC5hc0FycmF5KGxlZnQpLCByaWdodEFyciA9IHJpZ2h0TW9kZWwuYXNBcnJheShyaWdodCk7XG4gICAgICBpZiAobGVmdEFyci5lbGVtZW50cy5sZW5ndGggIT09IHJpZ2h0QXJyLmVsZW1lbnRzLmxlbmd0aClcbiAgICAgICAgYnJlYWs7XG4gICAgICBsZXQgbnVtUmViYXNlZCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJpZ2h0QXJyLmVsZW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICByaWdodEFyci5lbGVtZW50c1tpXSA9IHJlYmFzZVZhbHVlKGxlZnRBcnIuZWxlbWVudHNbaV0sIHJpZ2h0QXJyLmVsZW1lbnRzW2ldKSwgcmlnaHRBcnIuZWxlbWVudHNbaV0gIT09IGxlZnRBcnIuZWxlbWVudHNbaV0gJiYgbnVtUmViYXNlZCsrO1xuICAgICAgcmV0dXJuIG51bVJlYmFzZWQgPT09IDAgPyBsZWZ0IDogcmlnaHQ7XG4gICAgfVxuICAgIGNhc2UgXCJudWxsXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6IHtcbiAgICAgIGlmICh1bndyYXAobGVmdCkgPT09IHVud3JhcChyaWdodCkpXG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgbGV0IGxlZnRSYXcgPSB1bndyYXAobGVmdCksIHJpZ2h0UmF3ID0gdW53cmFwKHJpZ2h0KTtcbiAgICAgIGlmIChsZWZ0UmF3ID09PSByaWdodFJhdylcbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICBsZXQgcmVzdWx0ID0gcmlnaHRNb2RlbC5jb3B5U3RyaW5nKG51bGwpLCBwcmVmaXggPSBjb21tb25QcmVmaXgobGVmdFJhdywgcmlnaHRSYXcpLCBzdWZmaXggPSBjb21tb25TdWZmaXgobGVmdFJhdywgcmlnaHRSYXcsIHByZWZpeCksIHJpZ2h0TGVuID0gdXRmOHN0cmluZ1NpemUocmlnaHRSYXcpLCBsZWZ0TGVuID0gdXRmOHN0cmluZ1NpemUobGVmdFJhdyk7XG4gICAgICAwIDwgcHJlZml4ICYmIHJpZ2h0TW9kZWwuc3RyaW5nQXBwZW5kU2xpY2UocmVzdWx0LCBsZWZ0LCAwLCBwcmVmaXgpLCBwcmVmaXggPCByaWdodExlbiAtIHN1ZmZpeCAmJiByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgcmlnaHQsIHByZWZpeCwgcmlnaHRMZW4gLSBzdWZmaXgpLCBsZWZ0TGVuIC0gc3VmZml4IDwgbGVmdExlbiAmJiByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgbGVmdExlbiAtIHN1ZmZpeCwgbGVmdExlbik7XG4gICAgICBsZXQgdmFsdWUgPSByaWdodE1vZGVsLmZpbmFsaXplKHJlc3VsdCk7XG4gICAgICBpZiAodW53cmFwKHZhbHVlKSAhPT0gcmlnaHRSYXcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImluY29ycmVjdCBzdHJpbmcgcmViYXNlXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmlnaHQ7XG59XG5mdW5jdGlvbiBhcHBseVBhdGNoJDEobGVmdCwgcGF0Y2gsIHN0YXJ0TWV0YSkge1xuICBsZXQgbW9kZWwgPSBuZXcgSW5jcmVtZW50YWxNb2RlbChzdGFydE1ldGEpO1xuICByZXR1cm4gbmV3IFBhdGNoZXIobW9kZWwsIGxlZnQsIHBhdGNoKS5wcm9jZXNzKCk7XG59XG52YXIgaW5jcmVtZW50YWxQYXRjaGVyID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFwcGx5UGF0Y2g6IGFwcGx5UGF0Y2gkMSxcbiAgZ2V0VHlwZSxcbiAgcmViYXNlVmFsdWUsXG4gIHVud3JhcCxcbiAgd3JhcFxufSk7XG5jbGFzcyBTaW1wbGVNb2RlbCB7XG4gIHdyYXAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGZpbmFsaXplKGIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSA/IGIgOiBiLmRhdGE7XG4gIH1cbiAgbWFya0NoYW5nZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgb2JqZWN0R2V0S2V5cyh2YWx1ZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIH1cbiAgb2JqZWN0R2V0RmllbGQodmFsdWUsIGtleSkge1xuICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICB9XG4gIGFycmF5R2V0RWxlbWVudCh2YWx1ZSwgaWR4KSB7XG4gICAgcmV0dXJuIHZhbHVlW2lkeF07XG4gIH1cbiAgY29weU9iamVjdCh2YWx1ZSkge1xuICAgIGxldCByZXMgPSB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgZGF0YToge31cbiAgICB9O1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbClcbiAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKVxuICAgICAgICByZXMuZGF0YVtrZXldID0gdmFsO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgY29weUFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gW10gOiB2YWx1ZS5zbGljZSgpO1xuICB9XG4gIGNvcHlTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIGRhdGE6IHZhbHVlID09PSBudWxsID8gXCJcIiA6IHZhbHVlXG4gICAgfTtcbiAgfVxuICBvYmplY3RTZXRGaWVsZCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICB0YXJnZXQuZGF0YVtrZXldID0gdmFsdWU7XG4gIH1cbiAgb2JqZWN0RGVsZXRlRmllbGQodGFyZ2V0LCBrZXkpIHtcbiAgICBkZWxldGUgdGFyZ2V0LmRhdGFba2V5XTtcbiAgfVxuICBhcnJheUFwcGVuZFZhbHVlKHRhcmdldCwgdmFsdWUpIHtcbiAgICB0YXJnZXQucHVzaCh2YWx1ZSk7XG4gIH1cbiAgYXJyYXlBcHBlbmRTbGljZSh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICB0YXJnZXQucHVzaCguLi5zb3VyY2Uuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgfVxuICBzdHJpbmdBcHBlbmRTbGljZSh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBzb3VyY2VTdHJpbmcgPSBzb3VyY2UsIGxlZnRQb3MgPSB1dGY4cmVzb2x2ZUluZGV4KHNvdXJjZVN0cmluZywgbGVmdCksIHJpZ2h0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIHJpZ2h0LCBsZWZ0UG9zKTtcbiAgICB0YXJnZXQuZGF0YSArPSBzb3VyY2VTdHJpbmcuc2xpY2UobGVmdFBvcywgcmlnaHRQb3MpO1xuICB9XG4gIHN0cmluZ0FwcGVuZFZhbHVlKHRhcmdldCwgdmFsdWUpIHtcbiAgICB0YXJnZXQuZGF0YSArPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYXBwbHlQYXRjaChsZWZ0LCBwYXRjaCkge1xuICBsZXQgcm9vdCA9IGxlZnQ7XG4gIHJldHVybiBuZXcgUGF0Y2hlcihuZXcgU2ltcGxlTW9kZWwoKSwgcm9vdCwgcGF0Y2gpLnByb2Nlc3MoKTtcbn1cbmV4cG9ydCB7XG4gIGFwcGx5UGF0Y2gsXG4gIGluY3JlbWVudGFsUGF0Y2hlciBhcyBpbmNyZW1lbnRhbFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mendoza/dist/index.js\n");

/***/ })

};
;